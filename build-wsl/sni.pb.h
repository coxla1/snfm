// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sni.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_sni_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_sni_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_sni_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_sni_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[46]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_sni_2eproto;
class BootFileRequest;
struct BootFileRequestDefaultTypeInternal;
extern BootFileRequestDefaultTypeInternal _BootFileRequest_default_instance_;
class BootFileResponse;
struct BootFileResponseDefaultTypeInternal;
extern BootFileResponseDefaultTypeInternal _BootFileResponse_default_instance_;
class DetectMemoryMappingRequest;
struct DetectMemoryMappingRequestDefaultTypeInternal;
extern DetectMemoryMappingRequestDefaultTypeInternal _DetectMemoryMappingRequest_default_instance_;
class DetectMemoryMappingResponse;
struct DetectMemoryMappingResponseDefaultTypeInternal;
extern DetectMemoryMappingResponseDefaultTypeInternal _DetectMemoryMappingResponse_default_instance_;
class DevicesRequest;
struct DevicesRequestDefaultTypeInternal;
extern DevicesRequestDefaultTypeInternal _DevicesRequest_default_instance_;
class DevicesResponse;
struct DevicesResponseDefaultTypeInternal;
extern DevicesResponseDefaultTypeInternal _DevicesResponse_default_instance_;
class DevicesResponse_Device;
struct DevicesResponse_DeviceDefaultTypeInternal;
extern DevicesResponse_DeviceDefaultTypeInternal _DevicesResponse_Device_default_instance_;
class DirEntry;
struct DirEntryDefaultTypeInternal;
extern DirEntryDefaultTypeInternal _DirEntry_default_instance_;
class FieldsRequest;
struct FieldsRequestDefaultTypeInternal;
extern FieldsRequestDefaultTypeInternal _FieldsRequest_default_instance_;
class FieldsResponse;
struct FieldsResponseDefaultTypeInternal;
extern FieldsResponseDefaultTypeInternal _FieldsResponse_default_instance_;
class GetFileRequest;
struct GetFileRequestDefaultTypeInternal;
extern GetFileRequestDefaultTypeInternal _GetFileRequest_default_instance_;
class GetFileResponse;
struct GetFileResponseDefaultTypeInternal;
extern GetFileResponseDefaultTypeInternal _GetFileResponse_default_instance_;
class MakeDirectoryRequest;
struct MakeDirectoryRequestDefaultTypeInternal;
extern MakeDirectoryRequestDefaultTypeInternal _MakeDirectoryRequest_default_instance_;
class MakeDirectoryResponse;
struct MakeDirectoryResponseDefaultTypeInternal;
extern MakeDirectoryResponseDefaultTypeInternal _MakeDirectoryResponse_default_instance_;
class MultiReadMemoryRequest;
struct MultiReadMemoryRequestDefaultTypeInternal;
extern MultiReadMemoryRequestDefaultTypeInternal _MultiReadMemoryRequest_default_instance_;
class MultiReadMemoryResponse;
struct MultiReadMemoryResponseDefaultTypeInternal;
extern MultiReadMemoryResponseDefaultTypeInternal _MultiReadMemoryResponse_default_instance_;
class MultiWriteMemoryRequest;
struct MultiWriteMemoryRequestDefaultTypeInternal;
extern MultiWriteMemoryRequestDefaultTypeInternal _MultiWriteMemoryRequest_default_instance_;
class MultiWriteMemoryResponse;
struct MultiWriteMemoryResponseDefaultTypeInternal;
extern MultiWriteMemoryResponseDefaultTypeInternal _MultiWriteMemoryResponse_default_instance_;
class NWACommandRequest;
struct NWACommandRequestDefaultTypeInternal;
extern NWACommandRequestDefaultTypeInternal _NWACommandRequest_default_instance_;
class NWACommandResponse;
struct NWACommandResponseDefaultTypeInternal;
extern NWACommandResponseDefaultTypeInternal _NWACommandResponse_default_instance_;
class NWACommandResponse_NWAASCIIItem;
struct NWACommandResponse_NWAASCIIItemDefaultTypeInternal;
extern NWACommandResponse_NWAASCIIItemDefaultTypeInternal _NWACommandResponse_NWAASCIIItem_default_instance_;
class NWACommandResponse_NWAASCIIItem_ItemEntry_DoNotUse;
struct NWACommandResponse_NWAASCIIItem_ItemEntry_DoNotUseDefaultTypeInternal;
extern NWACommandResponse_NWAASCIIItem_ItemEntry_DoNotUseDefaultTypeInternal _NWACommandResponse_NWAASCIIItem_ItemEntry_DoNotUse_default_instance_;
class PauseEmulationRequest;
struct PauseEmulationRequestDefaultTypeInternal;
extern PauseEmulationRequestDefaultTypeInternal _PauseEmulationRequest_default_instance_;
class PauseEmulationResponse;
struct PauseEmulationResponseDefaultTypeInternal;
extern PauseEmulationResponseDefaultTypeInternal _PauseEmulationResponse_default_instance_;
class PauseToggleEmulationRequest;
struct PauseToggleEmulationRequestDefaultTypeInternal;
extern PauseToggleEmulationRequestDefaultTypeInternal _PauseToggleEmulationRequest_default_instance_;
class PauseToggleEmulationResponse;
struct PauseToggleEmulationResponseDefaultTypeInternal;
extern PauseToggleEmulationResponseDefaultTypeInternal _PauseToggleEmulationResponse_default_instance_;
class PutFileRequest;
struct PutFileRequestDefaultTypeInternal;
extern PutFileRequestDefaultTypeInternal _PutFileRequest_default_instance_;
class PutFileResponse;
struct PutFileResponseDefaultTypeInternal;
extern PutFileResponseDefaultTypeInternal _PutFileResponse_default_instance_;
class ReadDirectoryRequest;
struct ReadDirectoryRequestDefaultTypeInternal;
extern ReadDirectoryRequestDefaultTypeInternal _ReadDirectoryRequest_default_instance_;
class ReadDirectoryResponse;
struct ReadDirectoryResponseDefaultTypeInternal;
extern ReadDirectoryResponseDefaultTypeInternal _ReadDirectoryResponse_default_instance_;
class ReadMemoryRequest;
struct ReadMemoryRequestDefaultTypeInternal;
extern ReadMemoryRequestDefaultTypeInternal _ReadMemoryRequest_default_instance_;
class ReadMemoryResponse;
struct ReadMemoryResponseDefaultTypeInternal;
extern ReadMemoryResponseDefaultTypeInternal _ReadMemoryResponse_default_instance_;
class RemoveFileRequest;
struct RemoveFileRequestDefaultTypeInternal;
extern RemoveFileRequestDefaultTypeInternal _RemoveFileRequest_default_instance_;
class RemoveFileResponse;
struct RemoveFileResponseDefaultTypeInternal;
extern RemoveFileResponseDefaultTypeInternal _RemoveFileResponse_default_instance_;
class RenameFileRequest;
struct RenameFileRequestDefaultTypeInternal;
extern RenameFileRequestDefaultTypeInternal _RenameFileRequest_default_instance_;
class RenameFileResponse;
struct RenameFileResponseDefaultTypeInternal;
extern RenameFileResponseDefaultTypeInternal _RenameFileResponse_default_instance_;
class ResetSystemRequest;
struct ResetSystemRequestDefaultTypeInternal;
extern ResetSystemRequestDefaultTypeInternal _ResetSystemRequest_default_instance_;
class ResetSystemResponse;
struct ResetSystemResponseDefaultTypeInternal;
extern ResetSystemResponseDefaultTypeInternal _ResetSystemResponse_default_instance_;
class ResetToMenuRequest;
struct ResetToMenuRequestDefaultTypeInternal;
extern ResetToMenuRequestDefaultTypeInternal _ResetToMenuRequest_default_instance_;
class ResetToMenuResponse;
struct ResetToMenuResponseDefaultTypeInternal;
extern ResetToMenuResponseDefaultTypeInternal _ResetToMenuResponse_default_instance_;
class SingleReadMemoryRequest;
struct SingleReadMemoryRequestDefaultTypeInternal;
extern SingleReadMemoryRequestDefaultTypeInternal _SingleReadMemoryRequest_default_instance_;
class SingleReadMemoryResponse;
struct SingleReadMemoryResponseDefaultTypeInternal;
extern SingleReadMemoryResponseDefaultTypeInternal _SingleReadMemoryResponse_default_instance_;
class SingleWriteMemoryRequest;
struct SingleWriteMemoryRequestDefaultTypeInternal;
extern SingleWriteMemoryRequestDefaultTypeInternal _SingleWriteMemoryRequest_default_instance_;
class SingleWriteMemoryResponse;
struct SingleWriteMemoryResponseDefaultTypeInternal;
extern SingleWriteMemoryResponseDefaultTypeInternal _SingleWriteMemoryResponse_default_instance_;
class WriteMemoryRequest;
struct WriteMemoryRequestDefaultTypeInternal;
extern WriteMemoryRequestDefaultTypeInternal _WriteMemoryRequest_default_instance_;
class WriteMemoryResponse;
struct WriteMemoryResponseDefaultTypeInternal;
extern WriteMemoryResponseDefaultTypeInternal _WriteMemoryResponse_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::BootFileRequest* Arena::CreateMaybeMessage<::BootFileRequest>(Arena*);
template<> ::BootFileResponse* Arena::CreateMaybeMessage<::BootFileResponse>(Arena*);
template<> ::DetectMemoryMappingRequest* Arena::CreateMaybeMessage<::DetectMemoryMappingRequest>(Arena*);
template<> ::DetectMemoryMappingResponse* Arena::CreateMaybeMessage<::DetectMemoryMappingResponse>(Arena*);
template<> ::DevicesRequest* Arena::CreateMaybeMessage<::DevicesRequest>(Arena*);
template<> ::DevicesResponse* Arena::CreateMaybeMessage<::DevicesResponse>(Arena*);
template<> ::DevicesResponse_Device* Arena::CreateMaybeMessage<::DevicesResponse_Device>(Arena*);
template<> ::DirEntry* Arena::CreateMaybeMessage<::DirEntry>(Arena*);
template<> ::FieldsRequest* Arena::CreateMaybeMessage<::FieldsRequest>(Arena*);
template<> ::FieldsResponse* Arena::CreateMaybeMessage<::FieldsResponse>(Arena*);
template<> ::GetFileRequest* Arena::CreateMaybeMessage<::GetFileRequest>(Arena*);
template<> ::GetFileResponse* Arena::CreateMaybeMessage<::GetFileResponse>(Arena*);
template<> ::MakeDirectoryRequest* Arena::CreateMaybeMessage<::MakeDirectoryRequest>(Arena*);
template<> ::MakeDirectoryResponse* Arena::CreateMaybeMessage<::MakeDirectoryResponse>(Arena*);
template<> ::MultiReadMemoryRequest* Arena::CreateMaybeMessage<::MultiReadMemoryRequest>(Arena*);
template<> ::MultiReadMemoryResponse* Arena::CreateMaybeMessage<::MultiReadMemoryResponse>(Arena*);
template<> ::MultiWriteMemoryRequest* Arena::CreateMaybeMessage<::MultiWriteMemoryRequest>(Arena*);
template<> ::MultiWriteMemoryResponse* Arena::CreateMaybeMessage<::MultiWriteMemoryResponse>(Arena*);
template<> ::NWACommandRequest* Arena::CreateMaybeMessage<::NWACommandRequest>(Arena*);
template<> ::NWACommandResponse* Arena::CreateMaybeMessage<::NWACommandResponse>(Arena*);
template<> ::NWACommandResponse_NWAASCIIItem* Arena::CreateMaybeMessage<::NWACommandResponse_NWAASCIIItem>(Arena*);
template<> ::NWACommandResponse_NWAASCIIItem_ItemEntry_DoNotUse* Arena::CreateMaybeMessage<::NWACommandResponse_NWAASCIIItem_ItemEntry_DoNotUse>(Arena*);
template<> ::PauseEmulationRequest* Arena::CreateMaybeMessage<::PauseEmulationRequest>(Arena*);
template<> ::PauseEmulationResponse* Arena::CreateMaybeMessage<::PauseEmulationResponse>(Arena*);
template<> ::PauseToggleEmulationRequest* Arena::CreateMaybeMessage<::PauseToggleEmulationRequest>(Arena*);
template<> ::PauseToggleEmulationResponse* Arena::CreateMaybeMessage<::PauseToggleEmulationResponse>(Arena*);
template<> ::PutFileRequest* Arena::CreateMaybeMessage<::PutFileRequest>(Arena*);
template<> ::PutFileResponse* Arena::CreateMaybeMessage<::PutFileResponse>(Arena*);
template<> ::ReadDirectoryRequest* Arena::CreateMaybeMessage<::ReadDirectoryRequest>(Arena*);
template<> ::ReadDirectoryResponse* Arena::CreateMaybeMessage<::ReadDirectoryResponse>(Arena*);
template<> ::ReadMemoryRequest* Arena::CreateMaybeMessage<::ReadMemoryRequest>(Arena*);
template<> ::ReadMemoryResponse* Arena::CreateMaybeMessage<::ReadMemoryResponse>(Arena*);
template<> ::RemoveFileRequest* Arena::CreateMaybeMessage<::RemoveFileRequest>(Arena*);
template<> ::RemoveFileResponse* Arena::CreateMaybeMessage<::RemoveFileResponse>(Arena*);
template<> ::RenameFileRequest* Arena::CreateMaybeMessage<::RenameFileRequest>(Arena*);
template<> ::RenameFileResponse* Arena::CreateMaybeMessage<::RenameFileResponse>(Arena*);
template<> ::ResetSystemRequest* Arena::CreateMaybeMessage<::ResetSystemRequest>(Arena*);
template<> ::ResetSystemResponse* Arena::CreateMaybeMessage<::ResetSystemResponse>(Arena*);
template<> ::ResetToMenuRequest* Arena::CreateMaybeMessage<::ResetToMenuRequest>(Arena*);
template<> ::ResetToMenuResponse* Arena::CreateMaybeMessage<::ResetToMenuResponse>(Arena*);
template<> ::SingleReadMemoryRequest* Arena::CreateMaybeMessage<::SingleReadMemoryRequest>(Arena*);
template<> ::SingleReadMemoryResponse* Arena::CreateMaybeMessage<::SingleReadMemoryResponse>(Arena*);
template<> ::SingleWriteMemoryRequest* Arena::CreateMaybeMessage<::SingleWriteMemoryRequest>(Arena*);
template<> ::SingleWriteMemoryResponse* Arena::CreateMaybeMessage<::SingleWriteMemoryResponse>(Arena*);
template<> ::WriteMemoryRequest* Arena::CreateMaybeMessage<::WriteMemoryRequest>(Arena*);
template<> ::WriteMemoryResponse* Arena::CreateMaybeMessage<::WriteMemoryResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum AddressSpace : int {
  FxPakPro = 0,
  SnesABus = 1,
  Raw = 2,
  AddressSpace_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AddressSpace_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AddressSpace_IsValid(int value);
constexpr AddressSpace AddressSpace_MIN = FxPakPro;
constexpr AddressSpace AddressSpace_MAX = Raw;
constexpr int AddressSpace_ARRAYSIZE = AddressSpace_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AddressSpace_descriptor();
template<typename T>
inline const std::string& AddressSpace_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AddressSpace>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AddressSpace_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AddressSpace_descriptor(), enum_t_value);
}
inline bool AddressSpace_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AddressSpace* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AddressSpace>(
    AddressSpace_descriptor(), name, value);
}
enum MemoryMapping : int {
  Unknown = 0,
  HiROM = 1,
  LoROM = 2,
  ExHiROM = 3,
  MemoryMapping_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MemoryMapping_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MemoryMapping_IsValid(int value);
constexpr MemoryMapping MemoryMapping_MIN = Unknown;
constexpr MemoryMapping MemoryMapping_MAX = ExHiROM;
constexpr int MemoryMapping_ARRAYSIZE = MemoryMapping_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MemoryMapping_descriptor();
template<typename T>
inline const std::string& MemoryMapping_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MemoryMapping>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MemoryMapping_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MemoryMapping_descriptor(), enum_t_value);
}
inline bool MemoryMapping_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MemoryMapping* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MemoryMapping>(
    MemoryMapping_descriptor(), name, value);
}
enum DeviceCapability : int {
  None = 0,
  ReadMemory = 1,
  WriteMemory = 2,
  ExecuteASM = 3,
  ResetSystem = 4,
  PauseUnpauseEmulation = 5,
  PauseToggleEmulation = 6,
  ResetToMenu = 7,
  FetchFields = 8,
  ReadDirectory = 10,
  MakeDirectory = 11,
  RemoveFile = 12,
  RenameFile = 13,
  PutFile = 14,
  GetFile = 15,
  BootFile = 16,
  NWACommand = 20,
  DeviceCapability_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DeviceCapability_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DeviceCapability_IsValid(int value);
constexpr DeviceCapability DeviceCapability_MIN = None;
constexpr DeviceCapability DeviceCapability_MAX = NWACommand;
constexpr int DeviceCapability_ARRAYSIZE = DeviceCapability_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DeviceCapability_descriptor();
template<typename T>
inline const std::string& DeviceCapability_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DeviceCapability>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DeviceCapability_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DeviceCapability_descriptor(), enum_t_value);
}
inline bool DeviceCapability_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceCapability* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DeviceCapability>(
    DeviceCapability_descriptor(), name, value);
}
enum Field : int {
  DeviceName = 0,
  DeviceVersion = 1,
  DeviceStatus = 2,
  CoreName = 20,
  CoreVersion = 21,
  CorePlatform = 22,
  RomFileName = 40,
  RomHashType = 41,
  RomHashValue = 42,
  Field_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Field_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Field_IsValid(int value);
constexpr Field Field_MIN = DeviceName;
constexpr Field Field_MAX = RomHashValue;
constexpr int Field_ARRAYSIZE = Field_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Field_descriptor();
template<typename T>
inline const std::string& Field_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Field>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Field_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Field_descriptor(), enum_t_value);
}
inline bool Field_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Field* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Field>(
    Field_descriptor(), name, value);
}
enum DirEntryType : int {
  Directory = 0,
  File = 1,
  DirEntryType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DirEntryType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DirEntryType_IsValid(int value);
constexpr DirEntryType DirEntryType_MIN = Directory;
constexpr DirEntryType DirEntryType_MAX = File;
constexpr int DirEntryType_ARRAYSIZE = DirEntryType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DirEntryType_descriptor();
template<typename T>
inline const std::string& DirEntryType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DirEntryType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DirEntryType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DirEntryType_descriptor(), enum_t_value);
}
inline bool DirEntryType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DirEntryType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DirEntryType>(
    DirEntryType_descriptor(), name, value);
}
// ===================================================================

class DevicesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DevicesRequest) */ {
 public:
  inline DevicesRequest() : DevicesRequest(nullptr) {}
  ~DevicesRequest() override;
  explicit constexpr DevicesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DevicesRequest(const DevicesRequest& from);
  DevicesRequest(DevicesRequest&& from) noexcept
    : DevicesRequest() {
    *this = ::std::move(from);
  }

  inline DevicesRequest& operator=(const DevicesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DevicesRequest& operator=(DevicesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DevicesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DevicesRequest* internal_default_instance() {
    return reinterpret_cast<const DevicesRequest*>(
               &_DevicesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DevicesRequest& a, DevicesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DevicesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DevicesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DevicesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DevicesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DevicesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DevicesRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DevicesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DevicesRequest";
  }
  protected:
  explicit DevicesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKindsFieldNumber = 1,
  };
  // repeated string kinds = 1;
  int kinds_size() const;
  private:
  int _internal_kinds_size() const;
  public:
  void clear_kinds();
  const std::string& kinds(int index) const;
  std::string* mutable_kinds(int index);
  void set_kinds(int index, const std::string& value);
  void set_kinds(int index, std::string&& value);
  void set_kinds(int index, const char* value);
  void set_kinds(int index, const char* value, size_t size);
  std::string* add_kinds();
  void add_kinds(const std::string& value);
  void add_kinds(std::string&& value);
  void add_kinds(const char* value);
  void add_kinds(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& kinds() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_kinds();
  private:
  const std::string& _internal_kinds(int index) const;
  std::string* _internal_add_kinds();
  public:

  // @@protoc_insertion_point(class_scope:DevicesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> kinds_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sni_2eproto;
};
// -------------------------------------------------------------------

class DevicesResponse_Device final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DevicesResponse.Device) */ {
 public:
  inline DevicesResponse_Device() : DevicesResponse_Device(nullptr) {}
  ~DevicesResponse_Device() override;
  explicit constexpr DevicesResponse_Device(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DevicesResponse_Device(const DevicesResponse_Device& from);
  DevicesResponse_Device(DevicesResponse_Device&& from) noexcept
    : DevicesResponse_Device() {
    *this = ::std::move(from);
  }

  inline DevicesResponse_Device& operator=(const DevicesResponse_Device& from) {
    CopyFrom(from);
    return *this;
  }
  inline DevicesResponse_Device& operator=(DevicesResponse_Device&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DevicesResponse_Device& default_instance() {
    return *internal_default_instance();
  }
  static inline const DevicesResponse_Device* internal_default_instance() {
    return reinterpret_cast<const DevicesResponse_Device*>(
               &_DevicesResponse_Device_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DevicesResponse_Device& a, DevicesResponse_Device& b) {
    a.Swap(&b);
  }
  inline void Swap(DevicesResponse_Device* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DevicesResponse_Device* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DevicesResponse_Device* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DevicesResponse_Device>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DevicesResponse_Device& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DevicesResponse_Device& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DevicesResponse_Device* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DevicesResponse.Device";
  }
  protected:
  explicit DevicesResponse_Device(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCapabilitiesFieldNumber = 4,
    kUriFieldNumber = 1,
    kDisplayNameFieldNumber = 2,
    kKindFieldNumber = 3,
    kSystemFieldNumber = 6,
    kDefaultAddressSpaceFieldNumber = 5,
  };
  // repeated .DeviceCapability capabilities = 4;
  int capabilities_size() const;
  private:
  int _internal_capabilities_size() const;
  public:
  void clear_capabilities();
  private:
  ::DeviceCapability _internal_capabilities(int index) const;
  void _internal_add_capabilities(::DeviceCapability value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_capabilities();
  public:
  ::DeviceCapability capabilities(int index) const;
  void set_capabilities(int index, ::DeviceCapability value);
  void add_capabilities(::DeviceCapability value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& capabilities() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_capabilities();

  // string uri = 1;
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // string displayName = 2;
  void clear_displayname();
  const std::string& displayname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_displayname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_displayname();
  PROTOBUF_NODISCARD std::string* release_displayname();
  void set_allocated_displayname(std::string* displayname);
  private:
  const std::string& _internal_displayname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_displayname(const std::string& value);
  std::string* _internal_mutable_displayname();
  public:

  // string kind = 3;
  void clear_kind();
  const std::string& kind() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_kind(ArgT0&& arg0, ArgT... args);
  std::string* mutable_kind();
  PROTOBUF_NODISCARD std::string* release_kind();
  void set_allocated_kind(std::string* kind);
  private:
  const std::string& _internal_kind() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_kind(const std::string& value);
  std::string* _internal_mutable_kind();
  public:

  // string system = 6 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_system();
  PROTOBUF_DEPRECATED const std::string& system() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_system(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_system();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_system();
  PROTOBUF_DEPRECATED void set_allocated_system(std::string* system);
  private:
  const std::string& _internal_system() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_system(const std::string& value);
  std::string* _internal_mutable_system();
  public:

  // .AddressSpace defaultAddressSpace = 5;
  void clear_defaultaddressspace();
  ::AddressSpace defaultaddressspace() const;
  void set_defaultaddressspace(::AddressSpace value);
  private:
  ::AddressSpace _internal_defaultaddressspace() const;
  void _internal_set_defaultaddressspace(::AddressSpace value);
  public:

  // @@protoc_insertion_point(class_scope:DevicesResponse.Device)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> capabilities_;
  mutable std::atomic<int> _capabilities_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr displayname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr kind_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr system_;
  int defaultaddressspace_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sni_2eproto;
};
// -------------------------------------------------------------------

class DevicesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DevicesResponse) */ {
 public:
  inline DevicesResponse() : DevicesResponse(nullptr) {}
  ~DevicesResponse() override;
  explicit constexpr DevicesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DevicesResponse(const DevicesResponse& from);
  DevicesResponse(DevicesResponse&& from) noexcept
    : DevicesResponse() {
    *this = ::std::move(from);
  }

  inline DevicesResponse& operator=(const DevicesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DevicesResponse& operator=(DevicesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DevicesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DevicesResponse* internal_default_instance() {
    return reinterpret_cast<const DevicesResponse*>(
               &_DevicesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DevicesResponse& a, DevicesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DevicesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DevicesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DevicesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DevicesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DevicesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DevicesResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DevicesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DevicesResponse";
  }
  protected:
  explicit DevicesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DevicesResponse_Device Device;

  // accessors -------------------------------------------------------

  enum : int {
    kDevicesFieldNumber = 1,
  };
  // repeated .DevicesResponse.Device devices = 1;
  int devices_size() const;
  private:
  int _internal_devices_size() const;
  public:
  void clear_devices();
  ::DevicesResponse_Device* mutable_devices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DevicesResponse_Device >*
      mutable_devices();
  private:
  const ::DevicesResponse_Device& _internal_devices(int index) const;
  ::DevicesResponse_Device* _internal_add_devices();
  public:
  const ::DevicesResponse_Device& devices(int index) const;
  ::DevicesResponse_Device* add_devices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DevicesResponse_Device >&
      devices() const;

  // @@protoc_insertion_point(class_scope:DevicesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DevicesResponse_Device > devices_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sni_2eproto;
};
// -------------------------------------------------------------------

class ResetSystemRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ResetSystemRequest) */ {
 public:
  inline ResetSystemRequest() : ResetSystemRequest(nullptr) {}
  ~ResetSystemRequest() override;
  explicit constexpr ResetSystemRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResetSystemRequest(const ResetSystemRequest& from);
  ResetSystemRequest(ResetSystemRequest&& from) noexcept
    : ResetSystemRequest() {
    *this = ::std::move(from);
  }

  inline ResetSystemRequest& operator=(const ResetSystemRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResetSystemRequest& operator=(ResetSystemRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResetSystemRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResetSystemRequest* internal_default_instance() {
    return reinterpret_cast<const ResetSystemRequest*>(
               &_ResetSystemRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ResetSystemRequest& a, ResetSystemRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ResetSystemRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResetSystemRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResetSystemRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResetSystemRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResetSystemRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResetSystemRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResetSystemRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ResetSystemRequest";
  }
  protected:
  explicit ResetSystemRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUriFieldNumber = 1,
  };
  // string uri = 1;
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // @@protoc_insertion_point(class_scope:ResetSystemRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sni_2eproto;
};
// -------------------------------------------------------------------

class ResetSystemResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ResetSystemResponse) */ {
 public:
  inline ResetSystemResponse() : ResetSystemResponse(nullptr) {}
  ~ResetSystemResponse() override;
  explicit constexpr ResetSystemResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResetSystemResponse(const ResetSystemResponse& from);
  ResetSystemResponse(ResetSystemResponse&& from) noexcept
    : ResetSystemResponse() {
    *this = ::std::move(from);
  }

  inline ResetSystemResponse& operator=(const ResetSystemResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResetSystemResponse& operator=(ResetSystemResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResetSystemResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResetSystemResponse* internal_default_instance() {
    return reinterpret_cast<const ResetSystemResponse*>(
               &_ResetSystemResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ResetSystemResponse& a, ResetSystemResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ResetSystemResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResetSystemResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResetSystemResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResetSystemResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResetSystemResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResetSystemResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResetSystemResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ResetSystemResponse";
  }
  protected:
  explicit ResetSystemResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUriFieldNumber = 1,
  };
  // string uri = 1;
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // @@protoc_insertion_point(class_scope:ResetSystemResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sni_2eproto;
};
// -------------------------------------------------------------------

class ResetToMenuRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ResetToMenuRequest) */ {
 public:
  inline ResetToMenuRequest() : ResetToMenuRequest(nullptr) {}
  ~ResetToMenuRequest() override;
  explicit constexpr ResetToMenuRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResetToMenuRequest(const ResetToMenuRequest& from);
  ResetToMenuRequest(ResetToMenuRequest&& from) noexcept
    : ResetToMenuRequest() {
    *this = ::std::move(from);
  }

  inline ResetToMenuRequest& operator=(const ResetToMenuRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResetToMenuRequest& operator=(ResetToMenuRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResetToMenuRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResetToMenuRequest* internal_default_instance() {
    return reinterpret_cast<const ResetToMenuRequest*>(
               &_ResetToMenuRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ResetToMenuRequest& a, ResetToMenuRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ResetToMenuRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResetToMenuRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResetToMenuRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResetToMenuRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResetToMenuRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResetToMenuRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResetToMenuRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ResetToMenuRequest";
  }
  protected:
  explicit ResetToMenuRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUriFieldNumber = 1,
  };
  // string uri = 1;
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // @@protoc_insertion_point(class_scope:ResetToMenuRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sni_2eproto;
};
// -------------------------------------------------------------------

class ResetToMenuResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ResetToMenuResponse) */ {
 public:
  inline ResetToMenuResponse() : ResetToMenuResponse(nullptr) {}
  ~ResetToMenuResponse() override;
  explicit constexpr ResetToMenuResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResetToMenuResponse(const ResetToMenuResponse& from);
  ResetToMenuResponse(ResetToMenuResponse&& from) noexcept
    : ResetToMenuResponse() {
    *this = ::std::move(from);
  }

  inline ResetToMenuResponse& operator=(const ResetToMenuResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResetToMenuResponse& operator=(ResetToMenuResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResetToMenuResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResetToMenuResponse* internal_default_instance() {
    return reinterpret_cast<const ResetToMenuResponse*>(
               &_ResetToMenuResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ResetToMenuResponse& a, ResetToMenuResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ResetToMenuResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResetToMenuResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResetToMenuResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResetToMenuResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResetToMenuResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResetToMenuResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResetToMenuResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ResetToMenuResponse";
  }
  protected:
  explicit ResetToMenuResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUriFieldNumber = 1,
  };
  // string uri = 1;
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // @@protoc_insertion_point(class_scope:ResetToMenuResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sni_2eproto;
};
// -------------------------------------------------------------------

class PauseEmulationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PauseEmulationRequest) */ {
 public:
  inline PauseEmulationRequest() : PauseEmulationRequest(nullptr) {}
  ~PauseEmulationRequest() override;
  explicit constexpr PauseEmulationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PauseEmulationRequest(const PauseEmulationRequest& from);
  PauseEmulationRequest(PauseEmulationRequest&& from) noexcept
    : PauseEmulationRequest() {
    *this = ::std::move(from);
  }

  inline PauseEmulationRequest& operator=(const PauseEmulationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PauseEmulationRequest& operator=(PauseEmulationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PauseEmulationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PauseEmulationRequest* internal_default_instance() {
    return reinterpret_cast<const PauseEmulationRequest*>(
               &_PauseEmulationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(PauseEmulationRequest& a, PauseEmulationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PauseEmulationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PauseEmulationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PauseEmulationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PauseEmulationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PauseEmulationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PauseEmulationRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PauseEmulationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PauseEmulationRequest";
  }
  protected:
  explicit PauseEmulationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUriFieldNumber = 1,
    kPausedFieldNumber = 2,
  };
  // string uri = 1;
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // bool paused = 2;
  void clear_paused();
  bool paused() const;
  void set_paused(bool value);
  private:
  bool _internal_paused() const;
  void _internal_set_paused(bool value);
  public:

  // @@protoc_insertion_point(class_scope:PauseEmulationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
  bool paused_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sni_2eproto;
};
// -------------------------------------------------------------------

class PauseEmulationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PauseEmulationResponse) */ {
 public:
  inline PauseEmulationResponse() : PauseEmulationResponse(nullptr) {}
  ~PauseEmulationResponse() override;
  explicit constexpr PauseEmulationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PauseEmulationResponse(const PauseEmulationResponse& from);
  PauseEmulationResponse(PauseEmulationResponse&& from) noexcept
    : PauseEmulationResponse() {
    *this = ::std::move(from);
  }

  inline PauseEmulationResponse& operator=(const PauseEmulationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PauseEmulationResponse& operator=(PauseEmulationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PauseEmulationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PauseEmulationResponse* internal_default_instance() {
    return reinterpret_cast<const PauseEmulationResponse*>(
               &_PauseEmulationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(PauseEmulationResponse& a, PauseEmulationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PauseEmulationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PauseEmulationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PauseEmulationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PauseEmulationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PauseEmulationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PauseEmulationResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PauseEmulationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PauseEmulationResponse";
  }
  protected:
  explicit PauseEmulationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUriFieldNumber = 1,
    kPausedFieldNumber = 2,
  };
  // string uri = 1;
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // bool paused = 2;
  void clear_paused();
  bool paused() const;
  void set_paused(bool value);
  private:
  bool _internal_paused() const;
  void _internal_set_paused(bool value);
  public:

  // @@protoc_insertion_point(class_scope:PauseEmulationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
  bool paused_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sni_2eproto;
};
// -------------------------------------------------------------------

class PauseToggleEmulationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PauseToggleEmulationRequest) */ {
 public:
  inline PauseToggleEmulationRequest() : PauseToggleEmulationRequest(nullptr) {}
  ~PauseToggleEmulationRequest() override;
  explicit constexpr PauseToggleEmulationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PauseToggleEmulationRequest(const PauseToggleEmulationRequest& from);
  PauseToggleEmulationRequest(PauseToggleEmulationRequest&& from) noexcept
    : PauseToggleEmulationRequest() {
    *this = ::std::move(from);
  }

  inline PauseToggleEmulationRequest& operator=(const PauseToggleEmulationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PauseToggleEmulationRequest& operator=(PauseToggleEmulationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PauseToggleEmulationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PauseToggleEmulationRequest* internal_default_instance() {
    return reinterpret_cast<const PauseToggleEmulationRequest*>(
               &_PauseToggleEmulationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(PauseToggleEmulationRequest& a, PauseToggleEmulationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PauseToggleEmulationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PauseToggleEmulationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PauseToggleEmulationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PauseToggleEmulationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PauseToggleEmulationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PauseToggleEmulationRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PauseToggleEmulationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PauseToggleEmulationRequest";
  }
  protected:
  explicit PauseToggleEmulationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUriFieldNumber = 1,
  };
  // string uri = 1;
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // @@protoc_insertion_point(class_scope:PauseToggleEmulationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sni_2eproto;
};
// -------------------------------------------------------------------

class PauseToggleEmulationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PauseToggleEmulationResponse) */ {
 public:
  inline PauseToggleEmulationResponse() : PauseToggleEmulationResponse(nullptr) {}
  ~PauseToggleEmulationResponse() override;
  explicit constexpr PauseToggleEmulationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PauseToggleEmulationResponse(const PauseToggleEmulationResponse& from);
  PauseToggleEmulationResponse(PauseToggleEmulationResponse&& from) noexcept
    : PauseToggleEmulationResponse() {
    *this = ::std::move(from);
  }

  inline PauseToggleEmulationResponse& operator=(const PauseToggleEmulationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PauseToggleEmulationResponse& operator=(PauseToggleEmulationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PauseToggleEmulationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PauseToggleEmulationResponse* internal_default_instance() {
    return reinterpret_cast<const PauseToggleEmulationResponse*>(
               &_PauseToggleEmulationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(PauseToggleEmulationResponse& a, PauseToggleEmulationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PauseToggleEmulationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PauseToggleEmulationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PauseToggleEmulationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PauseToggleEmulationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PauseToggleEmulationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PauseToggleEmulationResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PauseToggleEmulationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PauseToggleEmulationResponse";
  }
  protected:
  explicit PauseToggleEmulationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUriFieldNumber = 1,
  };
  // string uri = 1;
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // @@protoc_insertion_point(class_scope:PauseToggleEmulationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sni_2eproto;
};
// -------------------------------------------------------------------

class DetectMemoryMappingRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DetectMemoryMappingRequest) */ {
 public:
  inline DetectMemoryMappingRequest() : DetectMemoryMappingRequest(nullptr) {}
  ~DetectMemoryMappingRequest() override;
  explicit constexpr DetectMemoryMappingRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DetectMemoryMappingRequest(const DetectMemoryMappingRequest& from);
  DetectMemoryMappingRequest(DetectMemoryMappingRequest&& from) noexcept
    : DetectMemoryMappingRequest() {
    *this = ::std::move(from);
  }

  inline DetectMemoryMappingRequest& operator=(const DetectMemoryMappingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DetectMemoryMappingRequest& operator=(DetectMemoryMappingRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DetectMemoryMappingRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DetectMemoryMappingRequest* internal_default_instance() {
    return reinterpret_cast<const DetectMemoryMappingRequest*>(
               &_DetectMemoryMappingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(DetectMemoryMappingRequest& a, DetectMemoryMappingRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DetectMemoryMappingRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DetectMemoryMappingRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DetectMemoryMappingRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DetectMemoryMappingRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DetectMemoryMappingRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DetectMemoryMappingRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DetectMemoryMappingRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DetectMemoryMappingRequest";
  }
  protected:
  explicit DetectMemoryMappingRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUriFieldNumber = 1,
    kRomHeader00FFB0FieldNumber = 3,
    kFallbackMemoryMappingFieldNumber = 2,
  };
  // string uri = 1;
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // optional bytes romHeader00FFB0 = 3;
  bool has_romheader00ffb0() const;
  private:
  bool _internal_has_romheader00ffb0() const;
  public:
  void clear_romheader00ffb0();
  const std::string& romheader00ffb0() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_romheader00ffb0(ArgT0&& arg0, ArgT... args);
  std::string* mutable_romheader00ffb0();
  PROTOBUF_NODISCARD std::string* release_romheader00ffb0();
  void set_allocated_romheader00ffb0(std::string* romheader00ffb0);
  private:
  const std::string& _internal_romheader00ffb0() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_romheader00ffb0(const std::string& value);
  std::string* _internal_mutable_romheader00ffb0();
  public:

  // optional .MemoryMapping fallbackMemoryMapping = 2;
  bool has_fallbackmemorymapping() const;
  private:
  bool _internal_has_fallbackmemorymapping() const;
  public:
  void clear_fallbackmemorymapping();
  ::MemoryMapping fallbackmemorymapping() const;
  void set_fallbackmemorymapping(::MemoryMapping value);
  private:
  ::MemoryMapping _internal_fallbackmemorymapping() const;
  void _internal_set_fallbackmemorymapping(::MemoryMapping value);
  public:

  // @@protoc_insertion_point(class_scope:DetectMemoryMappingRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr romheader00ffb0_;
  int fallbackmemorymapping_;
  friend struct ::TableStruct_sni_2eproto;
};
// -------------------------------------------------------------------

class DetectMemoryMappingResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DetectMemoryMappingResponse) */ {
 public:
  inline DetectMemoryMappingResponse() : DetectMemoryMappingResponse(nullptr) {}
  ~DetectMemoryMappingResponse() override;
  explicit constexpr DetectMemoryMappingResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DetectMemoryMappingResponse(const DetectMemoryMappingResponse& from);
  DetectMemoryMappingResponse(DetectMemoryMappingResponse&& from) noexcept
    : DetectMemoryMappingResponse() {
    *this = ::std::move(from);
  }

  inline DetectMemoryMappingResponse& operator=(const DetectMemoryMappingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DetectMemoryMappingResponse& operator=(DetectMemoryMappingResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DetectMemoryMappingResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DetectMemoryMappingResponse* internal_default_instance() {
    return reinterpret_cast<const DetectMemoryMappingResponse*>(
               &_DetectMemoryMappingResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(DetectMemoryMappingResponse& a, DetectMemoryMappingResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DetectMemoryMappingResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DetectMemoryMappingResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DetectMemoryMappingResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DetectMemoryMappingResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DetectMemoryMappingResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DetectMemoryMappingResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DetectMemoryMappingResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DetectMemoryMappingResponse";
  }
  protected:
  explicit DetectMemoryMappingResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUriFieldNumber = 1,
    kRomHeader00FFB0FieldNumber = 4,
    kMemoryMappingFieldNumber = 2,
    kConfidenceFieldNumber = 3,
  };
  // string uri = 1;
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // bytes romHeader00FFB0 = 4;
  void clear_romheader00ffb0();
  const std::string& romheader00ffb0() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_romheader00ffb0(ArgT0&& arg0, ArgT... args);
  std::string* mutable_romheader00ffb0();
  PROTOBUF_NODISCARD std::string* release_romheader00ffb0();
  void set_allocated_romheader00ffb0(std::string* romheader00ffb0);
  private:
  const std::string& _internal_romheader00ffb0() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_romheader00ffb0(const std::string& value);
  std::string* _internal_mutable_romheader00ffb0();
  public:

  // .MemoryMapping memoryMapping = 2;
  void clear_memorymapping();
  ::MemoryMapping memorymapping() const;
  void set_memorymapping(::MemoryMapping value);
  private:
  ::MemoryMapping _internal_memorymapping() const;
  void _internal_set_memorymapping(::MemoryMapping value);
  public:

  // bool confidence = 3;
  void clear_confidence();
  bool confidence() const;
  void set_confidence(bool value);
  private:
  bool _internal_confidence() const;
  void _internal_set_confidence(bool value);
  public:

  // @@protoc_insertion_point(class_scope:DetectMemoryMappingResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr romheader00ffb0_;
  int memorymapping_;
  bool confidence_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sni_2eproto;
};
// -------------------------------------------------------------------

class ReadMemoryRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ReadMemoryRequest) */ {
 public:
  inline ReadMemoryRequest() : ReadMemoryRequest(nullptr) {}
  ~ReadMemoryRequest() override;
  explicit constexpr ReadMemoryRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadMemoryRequest(const ReadMemoryRequest& from);
  ReadMemoryRequest(ReadMemoryRequest&& from) noexcept
    : ReadMemoryRequest() {
    *this = ::std::move(from);
  }

  inline ReadMemoryRequest& operator=(const ReadMemoryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadMemoryRequest& operator=(ReadMemoryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadMemoryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadMemoryRequest* internal_default_instance() {
    return reinterpret_cast<const ReadMemoryRequest*>(
               &_ReadMemoryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ReadMemoryRequest& a, ReadMemoryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadMemoryRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadMemoryRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadMemoryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadMemoryRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadMemoryRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReadMemoryRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadMemoryRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ReadMemoryRequest";
  }
  protected:
  explicit ReadMemoryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestAddressFieldNumber = 1,
    kRequestAddressSpaceFieldNumber = 2,
    kSizeFieldNumber = 3,
    kRequestMemoryMappingFieldNumber = 4,
  };
  // uint32 requestAddress = 1;
  void clear_requestaddress();
  uint32_t requestaddress() const;
  void set_requestaddress(uint32_t value);
  private:
  uint32_t _internal_requestaddress() const;
  void _internal_set_requestaddress(uint32_t value);
  public:

  // .AddressSpace requestAddressSpace = 2;
  void clear_requestaddressspace();
  ::AddressSpace requestaddressspace() const;
  void set_requestaddressspace(::AddressSpace value);
  private:
  ::AddressSpace _internal_requestaddressspace() const;
  void _internal_set_requestaddressspace(::AddressSpace value);
  public:

  // uint32 size = 3;
  void clear_size();
  uint32_t size() const;
  void set_size(uint32_t value);
  private:
  uint32_t _internal_size() const;
  void _internal_set_size(uint32_t value);
  public:

  // .MemoryMapping requestMemoryMapping = 4;
  void clear_requestmemorymapping();
  ::MemoryMapping requestmemorymapping() const;
  void set_requestmemorymapping(::MemoryMapping value);
  private:
  ::MemoryMapping _internal_requestmemorymapping() const;
  void _internal_set_requestmemorymapping(::MemoryMapping value);
  public:

  // @@protoc_insertion_point(class_scope:ReadMemoryRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t requestaddress_;
  int requestaddressspace_;
  uint32_t size_;
  int requestmemorymapping_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sni_2eproto;
};
// -------------------------------------------------------------------

class ReadMemoryResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ReadMemoryResponse) */ {
 public:
  inline ReadMemoryResponse() : ReadMemoryResponse(nullptr) {}
  ~ReadMemoryResponse() override;
  explicit constexpr ReadMemoryResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadMemoryResponse(const ReadMemoryResponse& from);
  ReadMemoryResponse(ReadMemoryResponse&& from) noexcept
    : ReadMemoryResponse() {
    *this = ::std::move(from);
  }

  inline ReadMemoryResponse& operator=(const ReadMemoryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadMemoryResponse& operator=(ReadMemoryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadMemoryResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadMemoryResponse* internal_default_instance() {
    return reinterpret_cast<const ReadMemoryResponse*>(
               &_ReadMemoryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ReadMemoryResponse& a, ReadMemoryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadMemoryResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadMemoryResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadMemoryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadMemoryResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadMemoryResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReadMemoryResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadMemoryResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ReadMemoryResponse";
  }
  protected:
  explicit ReadMemoryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 5,
    kRequestAddressFieldNumber = 1,
    kRequestAddressSpaceFieldNumber = 2,
    kDeviceAddressFieldNumber = 3,
    kDeviceAddressSpaceFieldNumber = 4,
    kRequestMemoryMappingFieldNumber = 6,
  };
  // bytes data = 5;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // uint32 requestAddress = 1;
  void clear_requestaddress();
  uint32_t requestaddress() const;
  void set_requestaddress(uint32_t value);
  private:
  uint32_t _internal_requestaddress() const;
  void _internal_set_requestaddress(uint32_t value);
  public:

  // .AddressSpace requestAddressSpace = 2;
  void clear_requestaddressspace();
  ::AddressSpace requestaddressspace() const;
  void set_requestaddressspace(::AddressSpace value);
  private:
  ::AddressSpace _internal_requestaddressspace() const;
  void _internal_set_requestaddressspace(::AddressSpace value);
  public:

  // uint32 deviceAddress = 3;
  void clear_deviceaddress();
  uint32_t deviceaddress() const;
  void set_deviceaddress(uint32_t value);
  private:
  uint32_t _internal_deviceaddress() const;
  void _internal_set_deviceaddress(uint32_t value);
  public:

  // .AddressSpace deviceAddressSpace = 4;
  void clear_deviceaddressspace();
  ::AddressSpace deviceaddressspace() const;
  void set_deviceaddressspace(::AddressSpace value);
  private:
  ::AddressSpace _internal_deviceaddressspace() const;
  void _internal_set_deviceaddressspace(::AddressSpace value);
  public:

  // .MemoryMapping requestMemoryMapping = 6;
  void clear_requestmemorymapping();
  ::MemoryMapping requestmemorymapping() const;
  void set_requestmemorymapping(::MemoryMapping value);
  private:
  ::MemoryMapping _internal_requestmemorymapping() const;
  void _internal_set_requestmemorymapping(::MemoryMapping value);
  public:

  // @@protoc_insertion_point(class_scope:ReadMemoryResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  uint32_t requestaddress_;
  int requestaddressspace_;
  uint32_t deviceaddress_;
  int deviceaddressspace_;
  int requestmemorymapping_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sni_2eproto;
};
// -------------------------------------------------------------------

class WriteMemoryRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:WriteMemoryRequest) */ {
 public:
  inline WriteMemoryRequest() : WriteMemoryRequest(nullptr) {}
  ~WriteMemoryRequest() override;
  explicit constexpr WriteMemoryRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WriteMemoryRequest(const WriteMemoryRequest& from);
  WriteMemoryRequest(WriteMemoryRequest&& from) noexcept
    : WriteMemoryRequest() {
    *this = ::std::move(from);
  }

  inline WriteMemoryRequest& operator=(const WriteMemoryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WriteMemoryRequest& operator=(WriteMemoryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WriteMemoryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const WriteMemoryRequest* internal_default_instance() {
    return reinterpret_cast<const WriteMemoryRequest*>(
               &_WriteMemoryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(WriteMemoryRequest& a, WriteMemoryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(WriteMemoryRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WriteMemoryRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WriteMemoryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WriteMemoryRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WriteMemoryRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WriteMemoryRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriteMemoryRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "WriteMemoryRequest";
  }
  protected:
  explicit WriteMemoryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 3,
    kRequestAddressFieldNumber = 1,
    kRequestAddressSpaceFieldNumber = 2,
    kRequestMemoryMappingFieldNumber = 4,
  };
  // bytes data = 3;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // uint32 requestAddress = 1;
  void clear_requestaddress();
  uint32_t requestaddress() const;
  void set_requestaddress(uint32_t value);
  private:
  uint32_t _internal_requestaddress() const;
  void _internal_set_requestaddress(uint32_t value);
  public:

  // .AddressSpace requestAddressSpace = 2;
  void clear_requestaddressspace();
  ::AddressSpace requestaddressspace() const;
  void set_requestaddressspace(::AddressSpace value);
  private:
  ::AddressSpace _internal_requestaddressspace() const;
  void _internal_set_requestaddressspace(::AddressSpace value);
  public:

  // .MemoryMapping requestMemoryMapping = 4;
  void clear_requestmemorymapping();
  ::MemoryMapping requestmemorymapping() const;
  void set_requestmemorymapping(::MemoryMapping value);
  private:
  ::MemoryMapping _internal_requestmemorymapping() const;
  void _internal_set_requestmemorymapping(::MemoryMapping value);
  public:

  // @@protoc_insertion_point(class_scope:WriteMemoryRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  uint32_t requestaddress_;
  int requestaddressspace_;
  int requestmemorymapping_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sni_2eproto;
};
// -------------------------------------------------------------------

class WriteMemoryResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:WriteMemoryResponse) */ {
 public:
  inline WriteMemoryResponse() : WriteMemoryResponse(nullptr) {}
  ~WriteMemoryResponse() override;
  explicit constexpr WriteMemoryResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WriteMemoryResponse(const WriteMemoryResponse& from);
  WriteMemoryResponse(WriteMemoryResponse&& from) noexcept
    : WriteMemoryResponse() {
    *this = ::std::move(from);
  }

  inline WriteMemoryResponse& operator=(const WriteMemoryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline WriteMemoryResponse& operator=(WriteMemoryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WriteMemoryResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const WriteMemoryResponse* internal_default_instance() {
    return reinterpret_cast<const WriteMemoryResponse*>(
               &_WriteMemoryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(WriteMemoryResponse& a, WriteMemoryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(WriteMemoryResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WriteMemoryResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WriteMemoryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WriteMemoryResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WriteMemoryResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WriteMemoryResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriteMemoryResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "WriteMemoryResponse";
  }
  protected:
  explicit WriteMemoryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestAddressFieldNumber = 1,
    kRequestAddressSpaceFieldNumber = 2,
    kDeviceAddressFieldNumber = 3,
    kDeviceAddressSpaceFieldNumber = 4,
    kSizeFieldNumber = 5,
    kRequestMemoryMappingFieldNumber = 6,
  };
  // uint32 requestAddress = 1;
  void clear_requestaddress();
  uint32_t requestaddress() const;
  void set_requestaddress(uint32_t value);
  private:
  uint32_t _internal_requestaddress() const;
  void _internal_set_requestaddress(uint32_t value);
  public:

  // .AddressSpace requestAddressSpace = 2;
  void clear_requestaddressspace();
  ::AddressSpace requestaddressspace() const;
  void set_requestaddressspace(::AddressSpace value);
  private:
  ::AddressSpace _internal_requestaddressspace() const;
  void _internal_set_requestaddressspace(::AddressSpace value);
  public:

  // uint32 deviceAddress = 3;
  void clear_deviceaddress();
  uint32_t deviceaddress() const;
  void set_deviceaddress(uint32_t value);
  private:
  uint32_t _internal_deviceaddress() const;
  void _internal_set_deviceaddress(uint32_t value);
  public:

  // .AddressSpace deviceAddressSpace = 4;
  void clear_deviceaddressspace();
  ::AddressSpace deviceaddressspace() const;
  void set_deviceaddressspace(::AddressSpace value);
  private:
  ::AddressSpace _internal_deviceaddressspace() const;
  void _internal_set_deviceaddressspace(::AddressSpace value);
  public:

  // uint32 size = 5;
  void clear_size();
  uint32_t size() const;
  void set_size(uint32_t value);
  private:
  uint32_t _internal_size() const;
  void _internal_set_size(uint32_t value);
  public:

  // .MemoryMapping requestMemoryMapping = 6;
  void clear_requestmemorymapping();
  ::MemoryMapping requestmemorymapping() const;
  void set_requestmemorymapping(::MemoryMapping value);
  private:
  ::MemoryMapping _internal_requestmemorymapping() const;
  void _internal_set_requestmemorymapping(::MemoryMapping value);
  public:

  // @@protoc_insertion_point(class_scope:WriteMemoryResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t requestaddress_;
  int requestaddressspace_;
  uint32_t deviceaddress_;
  int deviceaddressspace_;
  uint32_t size_;
  int requestmemorymapping_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sni_2eproto;
};
// -------------------------------------------------------------------

class SingleReadMemoryRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SingleReadMemoryRequest) */ {
 public:
  inline SingleReadMemoryRequest() : SingleReadMemoryRequest(nullptr) {}
  ~SingleReadMemoryRequest() override;
  explicit constexpr SingleReadMemoryRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SingleReadMemoryRequest(const SingleReadMemoryRequest& from);
  SingleReadMemoryRequest(SingleReadMemoryRequest&& from) noexcept
    : SingleReadMemoryRequest() {
    *this = ::std::move(from);
  }

  inline SingleReadMemoryRequest& operator=(const SingleReadMemoryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SingleReadMemoryRequest& operator=(SingleReadMemoryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SingleReadMemoryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SingleReadMemoryRequest* internal_default_instance() {
    return reinterpret_cast<const SingleReadMemoryRequest*>(
               &_SingleReadMemoryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(SingleReadMemoryRequest& a, SingleReadMemoryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SingleReadMemoryRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SingleReadMemoryRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SingleReadMemoryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SingleReadMemoryRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SingleReadMemoryRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SingleReadMemoryRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SingleReadMemoryRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SingleReadMemoryRequest";
  }
  protected:
  explicit SingleReadMemoryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUriFieldNumber = 1,
    kRequestFieldNumber = 2,
  };
  // string uri = 1;
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // .ReadMemoryRequest request = 2;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::ReadMemoryRequest& request() const;
  PROTOBUF_NODISCARD ::ReadMemoryRequest* release_request();
  ::ReadMemoryRequest* mutable_request();
  void set_allocated_request(::ReadMemoryRequest* request);
  private:
  const ::ReadMemoryRequest& _internal_request() const;
  ::ReadMemoryRequest* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::ReadMemoryRequest* request);
  ::ReadMemoryRequest* unsafe_arena_release_request();

  // @@protoc_insertion_point(class_scope:SingleReadMemoryRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
  ::ReadMemoryRequest* request_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sni_2eproto;
};
// -------------------------------------------------------------------

class SingleReadMemoryResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SingleReadMemoryResponse) */ {
 public:
  inline SingleReadMemoryResponse() : SingleReadMemoryResponse(nullptr) {}
  ~SingleReadMemoryResponse() override;
  explicit constexpr SingleReadMemoryResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SingleReadMemoryResponse(const SingleReadMemoryResponse& from);
  SingleReadMemoryResponse(SingleReadMemoryResponse&& from) noexcept
    : SingleReadMemoryResponse() {
    *this = ::std::move(from);
  }

  inline SingleReadMemoryResponse& operator=(const SingleReadMemoryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SingleReadMemoryResponse& operator=(SingleReadMemoryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SingleReadMemoryResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SingleReadMemoryResponse* internal_default_instance() {
    return reinterpret_cast<const SingleReadMemoryResponse*>(
               &_SingleReadMemoryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(SingleReadMemoryResponse& a, SingleReadMemoryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SingleReadMemoryResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SingleReadMemoryResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SingleReadMemoryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SingleReadMemoryResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SingleReadMemoryResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SingleReadMemoryResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SingleReadMemoryResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SingleReadMemoryResponse";
  }
  protected:
  explicit SingleReadMemoryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUriFieldNumber = 1,
    kResponseFieldNumber = 2,
  };
  // string uri = 1;
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // .ReadMemoryResponse response = 2;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::ReadMemoryResponse& response() const;
  PROTOBUF_NODISCARD ::ReadMemoryResponse* release_response();
  ::ReadMemoryResponse* mutable_response();
  void set_allocated_response(::ReadMemoryResponse* response);
  private:
  const ::ReadMemoryResponse& _internal_response() const;
  ::ReadMemoryResponse* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::ReadMemoryResponse* response);
  ::ReadMemoryResponse* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:SingleReadMemoryResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
  ::ReadMemoryResponse* response_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sni_2eproto;
};
// -------------------------------------------------------------------

class SingleWriteMemoryRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SingleWriteMemoryRequest) */ {
 public:
  inline SingleWriteMemoryRequest() : SingleWriteMemoryRequest(nullptr) {}
  ~SingleWriteMemoryRequest() override;
  explicit constexpr SingleWriteMemoryRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SingleWriteMemoryRequest(const SingleWriteMemoryRequest& from);
  SingleWriteMemoryRequest(SingleWriteMemoryRequest&& from) noexcept
    : SingleWriteMemoryRequest() {
    *this = ::std::move(from);
  }

  inline SingleWriteMemoryRequest& operator=(const SingleWriteMemoryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SingleWriteMemoryRequest& operator=(SingleWriteMemoryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SingleWriteMemoryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SingleWriteMemoryRequest* internal_default_instance() {
    return reinterpret_cast<const SingleWriteMemoryRequest*>(
               &_SingleWriteMemoryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(SingleWriteMemoryRequest& a, SingleWriteMemoryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SingleWriteMemoryRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SingleWriteMemoryRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SingleWriteMemoryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SingleWriteMemoryRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SingleWriteMemoryRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SingleWriteMemoryRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SingleWriteMemoryRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SingleWriteMemoryRequest";
  }
  protected:
  explicit SingleWriteMemoryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUriFieldNumber = 1,
    kRequestFieldNumber = 2,
  };
  // string uri = 1;
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // .WriteMemoryRequest request = 2;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::WriteMemoryRequest& request() const;
  PROTOBUF_NODISCARD ::WriteMemoryRequest* release_request();
  ::WriteMemoryRequest* mutable_request();
  void set_allocated_request(::WriteMemoryRequest* request);
  private:
  const ::WriteMemoryRequest& _internal_request() const;
  ::WriteMemoryRequest* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::WriteMemoryRequest* request);
  ::WriteMemoryRequest* unsafe_arena_release_request();

  // @@protoc_insertion_point(class_scope:SingleWriteMemoryRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
  ::WriteMemoryRequest* request_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sni_2eproto;
};
// -------------------------------------------------------------------

class SingleWriteMemoryResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SingleWriteMemoryResponse) */ {
 public:
  inline SingleWriteMemoryResponse() : SingleWriteMemoryResponse(nullptr) {}
  ~SingleWriteMemoryResponse() override;
  explicit constexpr SingleWriteMemoryResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SingleWriteMemoryResponse(const SingleWriteMemoryResponse& from);
  SingleWriteMemoryResponse(SingleWriteMemoryResponse&& from) noexcept
    : SingleWriteMemoryResponse() {
    *this = ::std::move(from);
  }

  inline SingleWriteMemoryResponse& operator=(const SingleWriteMemoryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SingleWriteMemoryResponse& operator=(SingleWriteMemoryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SingleWriteMemoryResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SingleWriteMemoryResponse* internal_default_instance() {
    return reinterpret_cast<const SingleWriteMemoryResponse*>(
               &_SingleWriteMemoryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(SingleWriteMemoryResponse& a, SingleWriteMemoryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SingleWriteMemoryResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SingleWriteMemoryResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SingleWriteMemoryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SingleWriteMemoryResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SingleWriteMemoryResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SingleWriteMemoryResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SingleWriteMemoryResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SingleWriteMemoryResponse";
  }
  protected:
  explicit SingleWriteMemoryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUriFieldNumber = 1,
    kResponseFieldNumber = 2,
  };
  // string uri = 1;
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // .WriteMemoryResponse response = 2;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::WriteMemoryResponse& response() const;
  PROTOBUF_NODISCARD ::WriteMemoryResponse* release_response();
  ::WriteMemoryResponse* mutable_response();
  void set_allocated_response(::WriteMemoryResponse* response);
  private:
  const ::WriteMemoryResponse& _internal_response() const;
  ::WriteMemoryResponse* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::WriteMemoryResponse* response);
  ::WriteMemoryResponse* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:SingleWriteMemoryResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
  ::WriteMemoryResponse* response_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sni_2eproto;
};
// -------------------------------------------------------------------

class MultiReadMemoryRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MultiReadMemoryRequest) */ {
 public:
  inline MultiReadMemoryRequest() : MultiReadMemoryRequest(nullptr) {}
  ~MultiReadMemoryRequest() override;
  explicit constexpr MultiReadMemoryRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MultiReadMemoryRequest(const MultiReadMemoryRequest& from);
  MultiReadMemoryRequest(MultiReadMemoryRequest&& from) noexcept
    : MultiReadMemoryRequest() {
    *this = ::std::move(from);
  }

  inline MultiReadMemoryRequest& operator=(const MultiReadMemoryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MultiReadMemoryRequest& operator=(MultiReadMemoryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MultiReadMemoryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MultiReadMemoryRequest* internal_default_instance() {
    return reinterpret_cast<const MultiReadMemoryRequest*>(
               &_MultiReadMemoryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(MultiReadMemoryRequest& a, MultiReadMemoryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MultiReadMemoryRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MultiReadMemoryRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MultiReadMemoryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MultiReadMemoryRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MultiReadMemoryRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MultiReadMemoryRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiReadMemoryRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MultiReadMemoryRequest";
  }
  protected:
  explicit MultiReadMemoryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestsFieldNumber = 2,
    kUriFieldNumber = 1,
  };
  // repeated .ReadMemoryRequest requests = 2;
  int requests_size() const;
  private:
  int _internal_requests_size() const;
  public:
  void clear_requests();
  ::ReadMemoryRequest* mutable_requests(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ReadMemoryRequest >*
      mutable_requests();
  private:
  const ::ReadMemoryRequest& _internal_requests(int index) const;
  ::ReadMemoryRequest* _internal_add_requests();
  public:
  const ::ReadMemoryRequest& requests(int index) const;
  ::ReadMemoryRequest* add_requests();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ReadMemoryRequest >&
      requests() const;

  // string uri = 1;
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // @@protoc_insertion_point(class_scope:MultiReadMemoryRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ReadMemoryRequest > requests_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sni_2eproto;
};
// -------------------------------------------------------------------

class MultiReadMemoryResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MultiReadMemoryResponse) */ {
 public:
  inline MultiReadMemoryResponse() : MultiReadMemoryResponse(nullptr) {}
  ~MultiReadMemoryResponse() override;
  explicit constexpr MultiReadMemoryResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MultiReadMemoryResponse(const MultiReadMemoryResponse& from);
  MultiReadMemoryResponse(MultiReadMemoryResponse&& from) noexcept
    : MultiReadMemoryResponse() {
    *this = ::std::move(from);
  }

  inline MultiReadMemoryResponse& operator=(const MultiReadMemoryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MultiReadMemoryResponse& operator=(MultiReadMemoryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MultiReadMemoryResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MultiReadMemoryResponse* internal_default_instance() {
    return reinterpret_cast<const MultiReadMemoryResponse*>(
               &_MultiReadMemoryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(MultiReadMemoryResponse& a, MultiReadMemoryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MultiReadMemoryResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MultiReadMemoryResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MultiReadMemoryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MultiReadMemoryResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MultiReadMemoryResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MultiReadMemoryResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiReadMemoryResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MultiReadMemoryResponse";
  }
  protected:
  explicit MultiReadMemoryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponsesFieldNumber = 2,
    kUriFieldNumber = 1,
  };
  // repeated .ReadMemoryResponse responses = 2;
  int responses_size() const;
  private:
  int _internal_responses_size() const;
  public:
  void clear_responses();
  ::ReadMemoryResponse* mutable_responses(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ReadMemoryResponse >*
      mutable_responses();
  private:
  const ::ReadMemoryResponse& _internal_responses(int index) const;
  ::ReadMemoryResponse* _internal_add_responses();
  public:
  const ::ReadMemoryResponse& responses(int index) const;
  ::ReadMemoryResponse* add_responses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ReadMemoryResponse >&
      responses() const;

  // string uri = 1;
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // @@protoc_insertion_point(class_scope:MultiReadMemoryResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ReadMemoryResponse > responses_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sni_2eproto;
};
// -------------------------------------------------------------------

class MultiWriteMemoryRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MultiWriteMemoryRequest) */ {
 public:
  inline MultiWriteMemoryRequest() : MultiWriteMemoryRequest(nullptr) {}
  ~MultiWriteMemoryRequest() override;
  explicit constexpr MultiWriteMemoryRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MultiWriteMemoryRequest(const MultiWriteMemoryRequest& from);
  MultiWriteMemoryRequest(MultiWriteMemoryRequest&& from) noexcept
    : MultiWriteMemoryRequest() {
    *this = ::std::move(from);
  }

  inline MultiWriteMemoryRequest& operator=(const MultiWriteMemoryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MultiWriteMemoryRequest& operator=(MultiWriteMemoryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MultiWriteMemoryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MultiWriteMemoryRequest* internal_default_instance() {
    return reinterpret_cast<const MultiWriteMemoryRequest*>(
               &_MultiWriteMemoryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(MultiWriteMemoryRequest& a, MultiWriteMemoryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MultiWriteMemoryRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MultiWriteMemoryRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MultiWriteMemoryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MultiWriteMemoryRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MultiWriteMemoryRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MultiWriteMemoryRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiWriteMemoryRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MultiWriteMemoryRequest";
  }
  protected:
  explicit MultiWriteMemoryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestsFieldNumber = 2,
    kUriFieldNumber = 1,
  };
  // repeated .WriteMemoryRequest requests = 2;
  int requests_size() const;
  private:
  int _internal_requests_size() const;
  public:
  void clear_requests();
  ::WriteMemoryRequest* mutable_requests(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::WriteMemoryRequest >*
      mutable_requests();
  private:
  const ::WriteMemoryRequest& _internal_requests(int index) const;
  ::WriteMemoryRequest* _internal_add_requests();
  public:
  const ::WriteMemoryRequest& requests(int index) const;
  ::WriteMemoryRequest* add_requests();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::WriteMemoryRequest >&
      requests() const;

  // string uri = 1;
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // @@protoc_insertion_point(class_scope:MultiWriteMemoryRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::WriteMemoryRequest > requests_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sni_2eproto;
};
// -------------------------------------------------------------------

class MultiWriteMemoryResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MultiWriteMemoryResponse) */ {
 public:
  inline MultiWriteMemoryResponse() : MultiWriteMemoryResponse(nullptr) {}
  ~MultiWriteMemoryResponse() override;
  explicit constexpr MultiWriteMemoryResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MultiWriteMemoryResponse(const MultiWriteMemoryResponse& from);
  MultiWriteMemoryResponse(MultiWriteMemoryResponse&& from) noexcept
    : MultiWriteMemoryResponse() {
    *this = ::std::move(from);
  }

  inline MultiWriteMemoryResponse& operator=(const MultiWriteMemoryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MultiWriteMemoryResponse& operator=(MultiWriteMemoryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MultiWriteMemoryResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MultiWriteMemoryResponse* internal_default_instance() {
    return reinterpret_cast<const MultiWriteMemoryResponse*>(
               &_MultiWriteMemoryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(MultiWriteMemoryResponse& a, MultiWriteMemoryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MultiWriteMemoryResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MultiWriteMemoryResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MultiWriteMemoryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MultiWriteMemoryResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MultiWriteMemoryResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MultiWriteMemoryResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiWriteMemoryResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MultiWriteMemoryResponse";
  }
  protected:
  explicit MultiWriteMemoryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponsesFieldNumber = 2,
    kUriFieldNumber = 1,
  };
  // repeated .WriteMemoryResponse responses = 2;
  int responses_size() const;
  private:
  int _internal_responses_size() const;
  public:
  void clear_responses();
  ::WriteMemoryResponse* mutable_responses(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::WriteMemoryResponse >*
      mutable_responses();
  private:
  const ::WriteMemoryResponse& _internal_responses(int index) const;
  ::WriteMemoryResponse* _internal_add_responses();
  public:
  const ::WriteMemoryResponse& responses(int index) const;
  ::WriteMemoryResponse* add_responses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::WriteMemoryResponse >&
      responses() const;

  // string uri = 1;
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // @@protoc_insertion_point(class_scope:MultiWriteMemoryResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::WriteMemoryResponse > responses_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sni_2eproto;
};
// -------------------------------------------------------------------

class ReadDirectoryRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ReadDirectoryRequest) */ {
 public:
  inline ReadDirectoryRequest() : ReadDirectoryRequest(nullptr) {}
  ~ReadDirectoryRequest() override;
  explicit constexpr ReadDirectoryRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadDirectoryRequest(const ReadDirectoryRequest& from);
  ReadDirectoryRequest(ReadDirectoryRequest&& from) noexcept
    : ReadDirectoryRequest() {
    *this = ::std::move(from);
  }

  inline ReadDirectoryRequest& operator=(const ReadDirectoryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadDirectoryRequest& operator=(ReadDirectoryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadDirectoryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadDirectoryRequest* internal_default_instance() {
    return reinterpret_cast<const ReadDirectoryRequest*>(
               &_ReadDirectoryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(ReadDirectoryRequest& a, ReadDirectoryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadDirectoryRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadDirectoryRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadDirectoryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadDirectoryRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadDirectoryRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReadDirectoryRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadDirectoryRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ReadDirectoryRequest";
  }
  protected:
  explicit ReadDirectoryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUriFieldNumber = 1,
    kPathFieldNumber = 2,
  };
  // string uri = 1;
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // string path = 2;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // @@protoc_insertion_point(class_scope:ReadDirectoryRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sni_2eproto;
};
// -------------------------------------------------------------------

class DirEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DirEntry) */ {
 public:
  inline DirEntry() : DirEntry(nullptr) {}
  ~DirEntry() override;
  explicit constexpr DirEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DirEntry(const DirEntry& from);
  DirEntry(DirEntry&& from) noexcept
    : DirEntry() {
    *this = ::std::move(from);
  }

  inline DirEntry& operator=(const DirEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline DirEntry& operator=(DirEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DirEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const DirEntry* internal_default_instance() {
    return reinterpret_cast<const DirEntry*>(
               &_DirEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(DirEntry& a, DirEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(DirEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DirEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DirEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DirEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DirEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DirEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DirEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DirEntry";
  }
  protected:
  explicit DirEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .DirEntryType type = 2;
  void clear_type();
  ::DirEntryType type() const;
  void set_type(::DirEntryType value);
  private:
  ::DirEntryType _internal_type() const;
  void _internal_set_type(::DirEntryType value);
  public:

  // @@protoc_insertion_point(class_scope:DirEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sni_2eproto;
};
// -------------------------------------------------------------------

class ReadDirectoryResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ReadDirectoryResponse) */ {
 public:
  inline ReadDirectoryResponse() : ReadDirectoryResponse(nullptr) {}
  ~ReadDirectoryResponse() override;
  explicit constexpr ReadDirectoryResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadDirectoryResponse(const ReadDirectoryResponse& from);
  ReadDirectoryResponse(ReadDirectoryResponse&& from) noexcept
    : ReadDirectoryResponse() {
    *this = ::std::move(from);
  }

  inline ReadDirectoryResponse& operator=(const ReadDirectoryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadDirectoryResponse& operator=(ReadDirectoryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadDirectoryResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadDirectoryResponse* internal_default_instance() {
    return reinterpret_cast<const ReadDirectoryResponse*>(
               &_ReadDirectoryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(ReadDirectoryResponse& a, ReadDirectoryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadDirectoryResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadDirectoryResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadDirectoryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadDirectoryResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadDirectoryResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReadDirectoryResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadDirectoryResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ReadDirectoryResponse";
  }
  protected:
  explicit ReadDirectoryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 3,
    kUriFieldNumber = 1,
    kPathFieldNumber = 2,
  };
  // repeated .DirEntry entries = 3;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  ::DirEntry* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DirEntry >*
      mutable_entries();
  private:
  const ::DirEntry& _internal_entries(int index) const;
  ::DirEntry* _internal_add_entries();
  public:
  const ::DirEntry& entries(int index) const;
  ::DirEntry* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DirEntry >&
      entries() const;

  // string uri = 1;
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // string path = 2;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // @@protoc_insertion_point(class_scope:ReadDirectoryResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DirEntry > entries_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sni_2eproto;
};
// -------------------------------------------------------------------

class MakeDirectoryRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MakeDirectoryRequest) */ {
 public:
  inline MakeDirectoryRequest() : MakeDirectoryRequest(nullptr) {}
  ~MakeDirectoryRequest() override;
  explicit constexpr MakeDirectoryRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MakeDirectoryRequest(const MakeDirectoryRequest& from);
  MakeDirectoryRequest(MakeDirectoryRequest&& from) noexcept
    : MakeDirectoryRequest() {
    *this = ::std::move(from);
  }

  inline MakeDirectoryRequest& operator=(const MakeDirectoryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MakeDirectoryRequest& operator=(MakeDirectoryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MakeDirectoryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MakeDirectoryRequest* internal_default_instance() {
    return reinterpret_cast<const MakeDirectoryRequest*>(
               &_MakeDirectoryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(MakeDirectoryRequest& a, MakeDirectoryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MakeDirectoryRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MakeDirectoryRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MakeDirectoryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MakeDirectoryRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MakeDirectoryRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MakeDirectoryRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MakeDirectoryRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MakeDirectoryRequest";
  }
  protected:
  explicit MakeDirectoryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUriFieldNumber = 1,
    kPathFieldNumber = 2,
  };
  // string uri = 1;
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // string path = 2;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // @@protoc_insertion_point(class_scope:MakeDirectoryRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sni_2eproto;
};
// -------------------------------------------------------------------

class MakeDirectoryResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MakeDirectoryResponse) */ {
 public:
  inline MakeDirectoryResponse() : MakeDirectoryResponse(nullptr) {}
  ~MakeDirectoryResponse() override;
  explicit constexpr MakeDirectoryResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MakeDirectoryResponse(const MakeDirectoryResponse& from);
  MakeDirectoryResponse(MakeDirectoryResponse&& from) noexcept
    : MakeDirectoryResponse() {
    *this = ::std::move(from);
  }

  inline MakeDirectoryResponse& operator=(const MakeDirectoryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MakeDirectoryResponse& operator=(MakeDirectoryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MakeDirectoryResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MakeDirectoryResponse* internal_default_instance() {
    return reinterpret_cast<const MakeDirectoryResponse*>(
               &_MakeDirectoryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(MakeDirectoryResponse& a, MakeDirectoryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MakeDirectoryResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MakeDirectoryResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MakeDirectoryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MakeDirectoryResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MakeDirectoryResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MakeDirectoryResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MakeDirectoryResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MakeDirectoryResponse";
  }
  protected:
  explicit MakeDirectoryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUriFieldNumber = 1,
    kPathFieldNumber = 2,
  };
  // string uri = 1;
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // string path = 2;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // @@protoc_insertion_point(class_scope:MakeDirectoryResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sni_2eproto;
};
// -------------------------------------------------------------------

class RemoveFileRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RemoveFileRequest) */ {
 public:
  inline RemoveFileRequest() : RemoveFileRequest(nullptr) {}
  ~RemoveFileRequest() override;
  explicit constexpr RemoveFileRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoveFileRequest(const RemoveFileRequest& from);
  RemoveFileRequest(RemoveFileRequest&& from) noexcept
    : RemoveFileRequest() {
    *this = ::std::move(from);
  }

  inline RemoveFileRequest& operator=(const RemoveFileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveFileRequest& operator=(RemoveFileRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoveFileRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoveFileRequest* internal_default_instance() {
    return reinterpret_cast<const RemoveFileRequest*>(
               &_RemoveFileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(RemoveFileRequest& a, RemoveFileRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveFileRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveFileRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoveFileRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoveFileRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RemoveFileRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RemoveFileRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoveFileRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RemoveFileRequest";
  }
  protected:
  explicit RemoveFileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUriFieldNumber = 1,
    kPathFieldNumber = 2,
  };
  // string uri = 1;
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // string path = 2;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // @@protoc_insertion_point(class_scope:RemoveFileRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sni_2eproto;
};
// -------------------------------------------------------------------

class RemoveFileResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RemoveFileResponse) */ {
 public:
  inline RemoveFileResponse() : RemoveFileResponse(nullptr) {}
  ~RemoveFileResponse() override;
  explicit constexpr RemoveFileResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoveFileResponse(const RemoveFileResponse& from);
  RemoveFileResponse(RemoveFileResponse&& from) noexcept
    : RemoveFileResponse() {
    *this = ::std::move(from);
  }

  inline RemoveFileResponse& operator=(const RemoveFileResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveFileResponse& operator=(RemoveFileResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoveFileResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoveFileResponse* internal_default_instance() {
    return reinterpret_cast<const RemoveFileResponse*>(
               &_RemoveFileResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(RemoveFileResponse& a, RemoveFileResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveFileResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveFileResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoveFileResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoveFileResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RemoveFileResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RemoveFileResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoveFileResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RemoveFileResponse";
  }
  protected:
  explicit RemoveFileResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUriFieldNumber = 1,
    kPathFieldNumber = 2,
  };
  // string uri = 1;
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // string path = 2;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // @@protoc_insertion_point(class_scope:RemoveFileResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sni_2eproto;
};
// -------------------------------------------------------------------

class RenameFileRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RenameFileRequest) */ {
 public:
  inline RenameFileRequest() : RenameFileRequest(nullptr) {}
  ~RenameFileRequest() override;
  explicit constexpr RenameFileRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RenameFileRequest(const RenameFileRequest& from);
  RenameFileRequest(RenameFileRequest&& from) noexcept
    : RenameFileRequest() {
    *this = ::std::move(from);
  }

  inline RenameFileRequest& operator=(const RenameFileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RenameFileRequest& operator=(RenameFileRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RenameFileRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RenameFileRequest* internal_default_instance() {
    return reinterpret_cast<const RenameFileRequest*>(
               &_RenameFileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(RenameFileRequest& a, RenameFileRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RenameFileRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RenameFileRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RenameFileRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RenameFileRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RenameFileRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RenameFileRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RenameFileRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RenameFileRequest";
  }
  protected:
  explicit RenameFileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUriFieldNumber = 1,
    kPathFieldNumber = 2,
    kNewFilenameFieldNumber = 3,
  };
  // string uri = 1;
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // string path = 2;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // string newFilename = 3;
  void clear_newfilename();
  const std::string& newfilename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_newfilename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_newfilename();
  PROTOBUF_NODISCARD std::string* release_newfilename();
  void set_allocated_newfilename(std::string* newfilename);
  private:
  const std::string& _internal_newfilename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_newfilename(const std::string& value);
  std::string* _internal_mutable_newfilename();
  public:

  // @@protoc_insertion_point(class_scope:RenameFileRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr newfilename_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sni_2eproto;
};
// -------------------------------------------------------------------

class RenameFileResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RenameFileResponse) */ {
 public:
  inline RenameFileResponse() : RenameFileResponse(nullptr) {}
  ~RenameFileResponse() override;
  explicit constexpr RenameFileResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RenameFileResponse(const RenameFileResponse& from);
  RenameFileResponse(RenameFileResponse&& from) noexcept
    : RenameFileResponse() {
    *this = ::std::move(from);
  }

  inline RenameFileResponse& operator=(const RenameFileResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RenameFileResponse& operator=(RenameFileResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RenameFileResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RenameFileResponse* internal_default_instance() {
    return reinterpret_cast<const RenameFileResponse*>(
               &_RenameFileResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(RenameFileResponse& a, RenameFileResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RenameFileResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RenameFileResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RenameFileResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RenameFileResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RenameFileResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RenameFileResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RenameFileResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RenameFileResponse";
  }
  protected:
  explicit RenameFileResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUriFieldNumber = 1,
    kPathFieldNumber = 2,
    kNewFilenameFieldNumber = 3,
  };
  // string uri = 1;
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // string path = 2;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // string newFilename = 3;
  void clear_newfilename();
  const std::string& newfilename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_newfilename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_newfilename();
  PROTOBUF_NODISCARD std::string* release_newfilename();
  void set_allocated_newfilename(std::string* newfilename);
  private:
  const std::string& _internal_newfilename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_newfilename(const std::string& value);
  std::string* _internal_mutable_newfilename();
  public:

  // @@protoc_insertion_point(class_scope:RenameFileResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr newfilename_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sni_2eproto;
};
// -------------------------------------------------------------------

class PutFileRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PutFileRequest) */ {
 public:
  inline PutFileRequest() : PutFileRequest(nullptr) {}
  ~PutFileRequest() override;
  explicit constexpr PutFileRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PutFileRequest(const PutFileRequest& from);
  PutFileRequest(PutFileRequest&& from) noexcept
    : PutFileRequest() {
    *this = ::std::move(from);
  }

  inline PutFileRequest& operator=(const PutFileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PutFileRequest& operator=(PutFileRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PutFileRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PutFileRequest* internal_default_instance() {
    return reinterpret_cast<const PutFileRequest*>(
               &_PutFileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(PutFileRequest& a, PutFileRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PutFileRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PutFileRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PutFileRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PutFileRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PutFileRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PutFileRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PutFileRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PutFileRequest";
  }
  protected:
  explicit PutFileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUriFieldNumber = 1,
    kPathFieldNumber = 2,
    kDataFieldNumber = 3,
  };
  // string uri = 1;
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // string path = 2;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // bytes data = 3;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // @@protoc_insertion_point(class_scope:PutFileRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sni_2eproto;
};
// -------------------------------------------------------------------

class PutFileResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PutFileResponse) */ {
 public:
  inline PutFileResponse() : PutFileResponse(nullptr) {}
  ~PutFileResponse() override;
  explicit constexpr PutFileResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PutFileResponse(const PutFileResponse& from);
  PutFileResponse(PutFileResponse&& from) noexcept
    : PutFileResponse() {
    *this = ::std::move(from);
  }

  inline PutFileResponse& operator=(const PutFileResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PutFileResponse& operator=(PutFileResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PutFileResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PutFileResponse* internal_default_instance() {
    return reinterpret_cast<const PutFileResponse*>(
               &_PutFileResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(PutFileResponse& a, PutFileResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PutFileResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PutFileResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PutFileResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PutFileResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PutFileResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PutFileResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PutFileResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PutFileResponse";
  }
  protected:
  explicit PutFileResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUriFieldNumber = 1,
    kPathFieldNumber = 2,
    kSizeFieldNumber = 3,
  };
  // string uri = 1;
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // string path = 2;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // uint32 size = 3;
  void clear_size();
  uint32_t size() const;
  void set_size(uint32_t value);
  private:
  uint32_t _internal_size() const;
  void _internal_set_size(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PutFileResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  uint32_t size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sni_2eproto;
};
// -------------------------------------------------------------------

class GetFileRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GetFileRequest) */ {
 public:
  inline GetFileRequest() : GetFileRequest(nullptr) {}
  ~GetFileRequest() override;
  explicit constexpr GetFileRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFileRequest(const GetFileRequest& from);
  GetFileRequest(GetFileRequest&& from) noexcept
    : GetFileRequest() {
    *this = ::std::move(from);
  }

  inline GetFileRequest& operator=(const GetFileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFileRequest& operator=(GetFileRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFileRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFileRequest* internal_default_instance() {
    return reinterpret_cast<const GetFileRequest*>(
               &_GetFileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(GetFileRequest& a, GetFileRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFileRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFileRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFileRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFileRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetFileRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetFileRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFileRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GetFileRequest";
  }
  protected:
  explicit GetFileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUriFieldNumber = 1,
    kPathFieldNumber = 2,
  };
  // string uri = 1;
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // string path = 2;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // @@protoc_insertion_point(class_scope:GetFileRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sni_2eproto;
};
// -------------------------------------------------------------------

class GetFileResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GetFileResponse) */ {
 public:
  inline GetFileResponse() : GetFileResponse(nullptr) {}
  ~GetFileResponse() override;
  explicit constexpr GetFileResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFileResponse(const GetFileResponse& from);
  GetFileResponse(GetFileResponse&& from) noexcept
    : GetFileResponse() {
    *this = ::std::move(from);
  }

  inline GetFileResponse& operator=(const GetFileResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFileResponse& operator=(GetFileResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFileResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFileResponse* internal_default_instance() {
    return reinterpret_cast<const GetFileResponse*>(
               &_GetFileResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(GetFileResponse& a, GetFileResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFileResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFileResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFileResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFileResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetFileResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetFileResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFileResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GetFileResponse";
  }
  protected:
  explicit GetFileResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUriFieldNumber = 1,
    kPathFieldNumber = 2,
    kDataFieldNumber = 4,
    kSizeFieldNumber = 3,
  };
  // string uri = 1;
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // string path = 2;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // bytes data = 4;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // uint32 size = 3;
  void clear_size();
  uint32_t size() const;
  void set_size(uint32_t value);
  private:
  uint32_t _internal_size() const;
  void _internal_set_size(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:GetFileResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  uint32_t size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sni_2eproto;
};
// -------------------------------------------------------------------

class BootFileRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:BootFileRequest) */ {
 public:
  inline BootFileRequest() : BootFileRequest(nullptr) {}
  ~BootFileRequest() override;
  explicit constexpr BootFileRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BootFileRequest(const BootFileRequest& from);
  BootFileRequest(BootFileRequest&& from) noexcept
    : BootFileRequest() {
    *this = ::std::move(from);
  }

  inline BootFileRequest& operator=(const BootFileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BootFileRequest& operator=(BootFileRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BootFileRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BootFileRequest* internal_default_instance() {
    return reinterpret_cast<const BootFileRequest*>(
               &_BootFileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(BootFileRequest& a, BootFileRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BootFileRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BootFileRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BootFileRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BootFileRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BootFileRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BootFileRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BootFileRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "BootFileRequest";
  }
  protected:
  explicit BootFileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUriFieldNumber = 1,
    kPathFieldNumber = 2,
  };
  // string uri = 1;
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // string path = 2;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // @@protoc_insertion_point(class_scope:BootFileRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sni_2eproto;
};
// -------------------------------------------------------------------

class BootFileResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:BootFileResponse) */ {
 public:
  inline BootFileResponse() : BootFileResponse(nullptr) {}
  ~BootFileResponse() override;
  explicit constexpr BootFileResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BootFileResponse(const BootFileResponse& from);
  BootFileResponse(BootFileResponse&& from) noexcept
    : BootFileResponse() {
    *this = ::std::move(from);
  }

  inline BootFileResponse& operator=(const BootFileResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BootFileResponse& operator=(BootFileResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BootFileResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BootFileResponse* internal_default_instance() {
    return reinterpret_cast<const BootFileResponse*>(
               &_BootFileResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(BootFileResponse& a, BootFileResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BootFileResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BootFileResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BootFileResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BootFileResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BootFileResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BootFileResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BootFileResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "BootFileResponse";
  }
  protected:
  explicit BootFileResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUriFieldNumber = 1,
    kPathFieldNumber = 2,
  };
  // string uri = 1;
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // string path = 2;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // @@protoc_insertion_point(class_scope:BootFileResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sni_2eproto;
};
// -------------------------------------------------------------------

class FieldsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:FieldsRequest) */ {
 public:
  inline FieldsRequest() : FieldsRequest(nullptr) {}
  ~FieldsRequest() override;
  explicit constexpr FieldsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FieldsRequest(const FieldsRequest& from);
  FieldsRequest(FieldsRequest&& from) noexcept
    : FieldsRequest() {
    *this = ::std::move(from);
  }

  inline FieldsRequest& operator=(const FieldsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FieldsRequest& operator=(FieldsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FieldsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FieldsRequest* internal_default_instance() {
    return reinterpret_cast<const FieldsRequest*>(
               &_FieldsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(FieldsRequest& a, FieldsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FieldsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FieldsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FieldsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FieldsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FieldsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FieldsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FieldsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "FieldsRequest";
  }
  protected:
  explicit FieldsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldsFieldNumber = 2,
    kUriFieldNumber = 1,
  };
  // repeated .Field fields = 2;
  int fields_size() const;
  private:
  int _internal_fields_size() const;
  public:
  void clear_fields();
  private:
  ::Field _internal_fields(int index) const;
  void _internal_add_fields(::Field value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_fields();
  public:
  ::Field fields(int index) const;
  void set_fields(int index, ::Field value);
  void add_fields(::Field value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& fields() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_fields();

  // string uri = 1;
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // @@protoc_insertion_point(class_scope:FieldsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> fields_;
  mutable std::atomic<int> _fields_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sni_2eproto;
};
// -------------------------------------------------------------------

class FieldsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:FieldsResponse) */ {
 public:
  inline FieldsResponse() : FieldsResponse(nullptr) {}
  ~FieldsResponse() override;
  explicit constexpr FieldsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FieldsResponse(const FieldsResponse& from);
  FieldsResponse(FieldsResponse&& from) noexcept
    : FieldsResponse() {
    *this = ::std::move(from);
  }

  inline FieldsResponse& operator=(const FieldsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FieldsResponse& operator=(FieldsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FieldsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FieldsResponse* internal_default_instance() {
    return reinterpret_cast<const FieldsResponse*>(
               &_FieldsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(FieldsResponse& a, FieldsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FieldsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FieldsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FieldsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FieldsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FieldsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FieldsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FieldsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "FieldsResponse";
  }
  protected:
  explicit FieldsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldsFieldNumber = 2,
    kValuesFieldNumber = 3,
    kUriFieldNumber = 1,
  };
  // repeated .Field fields = 2;
  int fields_size() const;
  private:
  int _internal_fields_size() const;
  public:
  void clear_fields();
  private:
  ::Field _internal_fields(int index) const;
  void _internal_add_fields(::Field value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_fields();
  public:
  ::Field fields(int index) const;
  void set_fields(int index, ::Field value);
  void add_fields(::Field value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& fields() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_fields();

  // repeated string values = 3;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  const std::string& values(int index) const;
  std::string* mutable_values(int index);
  void set_values(int index, const std::string& value);
  void set_values(int index, std::string&& value);
  void set_values(int index, const char* value);
  void set_values(int index, const char* value, size_t size);
  std::string* add_values();
  void add_values(const std::string& value);
  void add_values(std::string&& value);
  void add_values(const char* value);
  void add_values(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_values();
  private:
  const std::string& _internal_values(int index) const;
  std::string* _internal_add_values();
  public:

  // string uri = 1;
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // @@protoc_insertion_point(class_scope:FieldsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> fields_;
  mutable std::atomic<int> _fields_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> values_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sni_2eproto;
};
// -------------------------------------------------------------------

class NWACommandRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:NWACommandRequest) */ {
 public:
  inline NWACommandRequest() : NWACommandRequest(nullptr) {}
  ~NWACommandRequest() override;
  explicit constexpr NWACommandRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NWACommandRequest(const NWACommandRequest& from);
  NWACommandRequest(NWACommandRequest&& from) noexcept
    : NWACommandRequest() {
    *this = ::std::move(from);
  }

  inline NWACommandRequest& operator=(const NWACommandRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NWACommandRequest& operator=(NWACommandRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NWACommandRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NWACommandRequest* internal_default_instance() {
    return reinterpret_cast<const NWACommandRequest*>(
               &_NWACommandRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(NWACommandRequest& a, NWACommandRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NWACommandRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NWACommandRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NWACommandRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NWACommandRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NWACommandRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NWACommandRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NWACommandRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "NWACommandRequest";
  }
  protected:
  explicit NWACommandRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUriFieldNumber = 1,
    kCommandFieldNumber = 2,
    kArgsFieldNumber = 3,
    kBinaryArgFieldNumber = 4,
  };
  // string uri = 1;
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // string command = 2;
  void clear_command();
  const std::string& command() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_command(ArgT0&& arg0, ArgT... args);
  std::string* mutable_command();
  PROTOBUF_NODISCARD std::string* release_command();
  void set_allocated_command(std::string* command);
  private:
  const std::string& _internal_command() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_command(const std::string& value);
  std::string* _internal_mutable_command();
  public:

  // string args = 3;
  void clear_args();
  const std::string& args() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_args(ArgT0&& arg0, ArgT... args);
  std::string* mutable_args();
  PROTOBUF_NODISCARD std::string* release_args();
  void set_allocated_args(std::string* args);
  private:
  const std::string& _internal_args() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_args(const std::string& value);
  std::string* _internal_mutable_args();
  public:

  // optional bytes binaryArg = 4;
  bool has_binaryarg() const;
  private:
  bool _internal_has_binaryarg() const;
  public:
  void clear_binaryarg();
  const std::string& binaryarg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_binaryarg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_binaryarg();
  PROTOBUF_NODISCARD std::string* release_binaryarg();
  void set_allocated_binaryarg(std::string* binaryarg);
  private:
  const std::string& _internal_binaryarg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_binaryarg(const std::string& value);
  std::string* _internal_mutable_binaryarg();
  public:

  // @@protoc_insertion_point(class_scope:NWACommandRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr command_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr args_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr binaryarg_;
  friend struct ::TableStruct_sni_2eproto;
};
// -------------------------------------------------------------------

class NWACommandResponse_NWAASCIIItem_ItemEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<NWACommandResponse_NWAASCIIItem_ItemEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<NWACommandResponse_NWAASCIIItem_ItemEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  NWACommandResponse_NWAASCIIItem_ItemEntry_DoNotUse();
  explicit constexpr NWACommandResponse_NWAASCIIItem_ItemEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit NWACommandResponse_NWAASCIIItem_ItemEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const NWACommandResponse_NWAASCIIItem_ItemEntry_DoNotUse& other);
  static const NWACommandResponse_NWAASCIIItem_ItemEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const NWACommandResponse_NWAASCIIItem_ItemEntry_DoNotUse*>(&_NWACommandResponse_NWAASCIIItem_ItemEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "NWACommandResponse.NWAASCIIItem.ItemEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "NWACommandResponse.NWAASCIIItem.ItemEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class NWACommandResponse_NWAASCIIItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:NWACommandResponse.NWAASCIIItem) */ {
 public:
  inline NWACommandResponse_NWAASCIIItem() : NWACommandResponse_NWAASCIIItem(nullptr) {}
  ~NWACommandResponse_NWAASCIIItem() override;
  explicit constexpr NWACommandResponse_NWAASCIIItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NWACommandResponse_NWAASCIIItem(const NWACommandResponse_NWAASCIIItem& from);
  NWACommandResponse_NWAASCIIItem(NWACommandResponse_NWAASCIIItem&& from) noexcept
    : NWACommandResponse_NWAASCIIItem() {
    *this = ::std::move(from);
  }

  inline NWACommandResponse_NWAASCIIItem& operator=(const NWACommandResponse_NWAASCIIItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline NWACommandResponse_NWAASCIIItem& operator=(NWACommandResponse_NWAASCIIItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NWACommandResponse_NWAASCIIItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const NWACommandResponse_NWAASCIIItem* internal_default_instance() {
    return reinterpret_cast<const NWACommandResponse_NWAASCIIItem*>(
               &_NWACommandResponse_NWAASCIIItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(NWACommandResponse_NWAASCIIItem& a, NWACommandResponse_NWAASCIIItem& b) {
    a.Swap(&b);
  }
  inline void Swap(NWACommandResponse_NWAASCIIItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NWACommandResponse_NWAASCIIItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NWACommandResponse_NWAASCIIItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NWACommandResponse_NWAASCIIItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NWACommandResponse_NWAASCIIItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NWACommandResponse_NWAASCIIItem& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NWACommandResponse_NWAASCIIItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "NWACommandResponse.NWAASCIIItem";
  }
  protected:
  explicit NWACommandResponse_NWAASCIIItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kItemFieldNumber = 1,
  };
  // map<string, string> item = 1;
  int item_size() const;
  private:
  int _internal_item_size() const;
  public:
  void clear_item();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_item() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_item();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      item() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_item();

  // @@protoc_insertion_point(class_scope:NWACommandResponse.NWAASCIIItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      NWACommandResponse_NWAASCIIItem_ItemEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> item_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sni_2eproto;
};
// -------------------------------------------------------------------

class NWACommandResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:NWACommandResponse) */ {
 public:
  inline NWACommandResponse() : NWACommandResponse(nullptr) {}
  ~NWACommandResponse() override;
  explicit constexpr NWACommandResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NWACommandResponse(const NWACommandResponse& from);
  NWACommandResponse(NWACommandResponse&& from) noexcept
    : NWACommandResponse() {
    *this = ::std::move(from);
  }

  inline NWACommandResponse& operator=(const NWACommandResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NWACommandResponse& operator=(NWACommandResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NWACommandResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NWACommandResponse* internal_default_instance() {
    return reinterpret_cast<const NWACommandResponse*>(
               &_NWACommandResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(NWACommandResponse& a, NWACommandResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NWACommandResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NWACommandResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NWACommandResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NWACommandResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NWACommandResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NWACommandResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NWACommandResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "NWACommandResponse";
  }
  protected:
  explicit NWACommandResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef NWACommandResponse_NWAASCIIItem NWAASCIIItem;

  // accessors -------------------------------------------------------

  enum : int {
    kAsciiReplyFieldNumber = 2,
    kUriFieldNumber = 1,
    kBinaryReplayFieldNumber = 3,
  };
  // repeated .NWACommandResponse.NWAASCIIItem asciiReply = 2;
  int asciireply_size() const;
  private:
  int _internal_asciireply_size() const;
  public:
  void clear_asciireply();
  ::NWACommandResponse_NWAASCIIItem* mutable_asciireply(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NWACommandResponse_NWAASCIIItem >*
      mutable_asciireply();
  private:
  const ::NWACommandResponse_NWAASCIIItem& _internal_asciireply(int index) const;
  ::NWACommandResponse_NWAASCIIItem* _internal_add_asciireply();
  public:
  const ::NWACommandResponse_NWAASCIIItem& asciireply(int index) const;
  ::NWACommandResponse_NWAASCIIItem* add_asciireply();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NWACommandResponse_NWAASCIIItem >&
      asciireply() const;

  // string uri = 1;
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // optional bytes binaryReplay = 3;
  bool has_binaryreplay() const;
  private:
  bool _internal_has_binaryreplay() const;
  public:
  void clear_binaryreplay();
  const std::string& binaryreplay() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_binaryreplay(ArgT0&& arg0, ArgT... args);
  std::string* mutable_binaryreplay();
  PROTOBUF_NODISCARD std::string* release_binaryreplay();
  void set_allocated_binaryreplay(std::string* binaryreplay);
  private:
  const std::string& _internal_binaryreplay() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_binaryreplay(const std::string& value);
  std::string* _internal_mutable_binaryreplay();
  public:

  // @@protoc_insertion_point(class_scope:NWACommandResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NWACommandResponse_NWAASCIIItem > asciireply_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr binaryreplay_;
  friend struct ::TableStruct_sni_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DevicesRequest

// repeated string kinds = 1;
inline int DevicesRequest::_internal_kinds_size() const {
  return kinds_.size();
}
inline int DevicesRequest::kinds_size() const {
  return _internal_kinds_size();
}
inline void DevicesRequest::clear_kinds() {
  kinds_.Clear();
}
inline std::string* DevicesRequest::add_kinds() {
  std::string* _s = _internal_add_kinds();
  // @@protoc_insertion_point(field_add_mutable:DevicesRequest.kinds)
  return _s;
}
inline const std::string& DevicesRequest::_internal_kinds(int index) const {
  return kinds_.Get(index);
}
inline const std::string& DevicesRequest::kinds(int index) const {
  // @@protoc_insertion_point(field_get:DevicesRequest.kinds)
  return _internal_kinds(index);
}
inline std::string* DevicesRequest::mutable_kinds(int index) {
  // @@protoc_insertion_point(field_mutable:DevicesRequest.kinds)
  return kinds_.Mutable(index);
}
inline void DevicesRequest::set_kinds(int index, const std::string& value) {
  kinds_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:DevicesRequest.kinds)
}
inline void DevicesRequest::set_kinds(int index, std::string&& value) {
  kinds_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:DevicesRequest.kinds)
}
inline void DevicesRequest::set_kinds(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  kinds_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:DevicesRequest.kinds)
}
inline void DevicesRequest::set_kinds(int index, const char* value, size_t size) {
  kinds_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DevicesRequest.kinds)
}
inline std::string* DevicesRequest::_internal_add_kinds() {
  return kinds_.Add();
}
inline void DevicesRequest::add_kinds(const std::string& value) {
  kinds_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:DevicesRequest.kinds)
}
inline void DevicesRequest::add_kinds(std::string&& value) {
  kinds_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:DevicesRequest.kinds)
}
inline void DevicesRequest::add_kinds(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  kinds_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:DevicesRequest.kinds)
}
inline void DevicesRequest::add_kinds(const char* value, size_t size) {
  kinds_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:DevicesRequest.kinds)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DevicesRequest::kinds() const {
  // @@protoc_insertion_point(field_list:DevicesRequest.kinds)
  return kinds_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DevicesRequest::mutable_kinds() {
  // @@protoc_insertion_point(field_mutable_list:DevicesRequest.kinds)
  return &kinds_;
}

// -------------------------------------------------------------------

// DevicesResponse_Device

// string uri = 1;
inline void DevicesResponse_Device::clear_uri() {
  uri_.ClearToEmpty();
}
inline const std::string& DevicesResponse_Device::uri() const {
  // @@protoc_insertion_point(field_get:DevicesResponse.Device.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DevicesResponse_Device::set_uri(ArgT0&& arg0, ArgT... args) {
 
 uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DevicesResponse.Device.uri)
}
inline std::string* DevicesResponse_Device::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:DevicesResponse.Device.uri)
  return _s;
}
inline const std::string& DevicesResponse_Device::_internal_uri() const {
  return uri_.Get();
}
inline void DevicesResponse_Device::_internal_set_uri(const std::string& value) {
  
  uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DevicesResponse_Device::_internal_mutable_uri() {
  
  return uri_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DevicesResponse_Device::release_uri() {
  // @@protoc_insertion_point(field_release:DevicesResponse.Device.uri)
  return uri_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DevicesResponse_Device::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  uri_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uri,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (uri_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    uri_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DevicesResponse.Device.uri)
}

// string displayName = 2;
inline void DevicesResponse_Device::clear_displayname() {
  displayname_.ClearToEmpty();
}
inline const std::string& DevicesResponse_Device::displayname() const {
  // @@protoc_insertion_point(field_get:DevicesResponse.Device.displayName)
  return _internal_displayname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DevicesResponse_Device::set_displayname(ArgT0&& arg0, ArgT... args) {
 
 displayname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DevicesResponse.Device.displayName)
}
inline std::string* DevicesResponse_Device::mutable_displayname() {
  std::string* _s = _internal_mutable_displayname();
  // @@protoc_insertion_point(field_mutable:DevicesResponse.Device.displayName)
  return _s;
}
inline const std::string& DevicesResponse_Device::_internal_displayname() const {
  return displayname_.Get();
}
inline void DevicesResponse_Device::_internal_set_displayname(const std::string& value) {
  
  displayname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DevicesResponse_Device::_internal_mutable_displayname() {
  
  return displayname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DevicesResponse_Device::release_displayname() {
  // @@protoc_insertion_point(field_release:DevicesResponse.Device.displayName)
  return displayname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DevicesResponse_Device::set_allocated_displayname(std::string* displayname) {
  if (displayname != nullptr) {
    
  } else {
    
  }
  displayname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), displayname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (displayname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    displayname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DevicesResponse.Device.displayName)
}

// string kind = 3;
inline void DevicesResponse_Device::clear_kind() {
  kind_.ClearToEmpty();
}
inline const std::string& DevicesResponse_Device::kind() const {
  // @@protoc_insertion_point(field_get:DevicesResponse.Device.kind)
  return _internal_kind();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DevicesResponse_Device::set_kind(ArgT0&& arg0, ArgT... args) {
 
 kind_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DevicesResponse.Device.kind)
}
inline std::string* DevicesResponse_Device::mutable_kind() {
  std::string* _s = _internal_mutable_kind();
  // @@protoc_insertion_point(field_mutable:DevicesResponse.Device.kind)
  return _s;
}
inline const std::string& DevicesResponse_Device::_internal_kind() const {
  return kind_.Get();
}
inline void DevicesResponse_Device::_internal_set_kind(const std::string& value) {
  
  kind_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DevicesResponse_Device::_internal_mutable_kind() {
  
  return kind_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DevicesResponse_Device::release_kind() {
  // @@protoc_insertion_point(field_release:DevicesResponse.Device.kind)
  return kind_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DevicesResponse_Device::set_allocated_kind(std::string* kind) {
  if (kind != nullptr) {
    
  } else {
    
  }
  kind_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), kind,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (kind_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    kind_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DevicesResponse.Device.kind)
}

// repeated .DeviceCapability capabilities = 4;
inline int DevicesResponse_Device::_internal_capabilities_size() const {
  return capabilities_.size();
}
inline int DevicesResponse_Device::capabilities_size() const {
  return _internal_capabilities_size();
}
inline void DevicesResponse_Device::clear_capabilities() {
  capabilities_.Clear();
}
inline ::DeviceCapability DevicesResponse_Device::_internal_capabilities(int index) const {
  return static_cast< ::DeviceCapability >(capabilities_.Get(index));
}
inline ::DeviceCapability DevicesResponse_Device::capabilities(int index) const {
  // @@protoc_insertion_point(field_get:DevicesResponse.Device.capabilities)
  return _internal_capabilities(index);
}
inline void DevicesResponse_Device::set_capabilities(int index, ::DeviceCapability value) {
  capabilities_.Set(index, value);
  // @@protoc_insertion_point(field_set:DevicesResponse.Device.capabilities)
}
inline void DevicesResponse_Device::_internal_add_capabilities(::DeviceCapability value) {
  capabilities_.Add(value);
}
inline void DevicesResponse_Device::add_capabilities(::DeviceCapability value) {
  _internal_add_capabilities(value);
  // @@protoc_insertion_point(field_add:DevicesResponse.Device.capabilities)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
DevicesResponse_Device::capabilities() const {
  // @@protoc_insertion_point(field_list:DevicesResponse.Device.capabilities)
  return capabilities_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
DevicesResponse_Device::_internal_mutable_capabilities() {
  return &capabilities_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
DevicesResponse_Device::mutable_capabilities() {
  // @@protoc_insertion_point(field_mutable_list:DevicesResponse.Device.capabilities)
  return _internal_mutable_capabilities();
}

// .AddressSpace defaultAddressSpace = 5;
inline void DevicesResponse_Device::clear_defaultaddressspace() {
  defaultaddressspace_ = 0;
}
inline ::AddressSpace DevicesResponse_Device::_internal_defaultaddressspace() const {
  return static_cast< ::AddressSpace >(defaultaddressspace_);
}
inline ::AddressSpace DevicesResponse_Device::defaultaddressspace() const {
  // @@protoc_insertion_point(field_get:DevicesResponse.Device.defaultAddressSpace)
  return _internal_defaultaddressspace();
}
inline void DevicesResponse_Device::_internal_set_defaultaddressspace(::AddressSpace value) {
  
  defaultaddressspace_ = value;
}
inline void DevicesResponse_Device::set_defaultaddressspace(::AddressSpace value) {
  _internal_set_defaultaddressspace(value);
  // @@protoc_insertion_point(field_set:DevicesResponse.Device.defaultAddressSpace)
}

// string system = 6 [deprecated = true];
inline void DevicesResponse_Device::clear_system() {
  system_.ClearToEmpty();
}
inline const std::string& DevicesResponse_Device::system() const {
  // @@protoc_insertion_point(field_get:DevicesResponse.Device.system)
  return _internal_system();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DevicesResponse_Device::set_system(ArgT0&& arg0, ArgT... args) {
 
 system_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DevicesResponse.Device.system)
}
inline std::string* DevicesResponse_Device::mutable_system() {
  std::string* _s = _internal_mutable_system();
  // @@protoc_insertion_point(field_mutable:DevicesResponse.Device.system)
  return _s;
}
inline const std::string& DevicesResponse_Device::_internal_system() const {
  return system_.Get();
}
inline void DevicesResponse_Device::_internal_set_system(const std::string& value) {
  
  system_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DevicesResponse_Device::_internal_mutable_system() {
  
  return system_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DevicesResponse_Device::release_system() {
  // @@protoc_insertion_point(field_release:DevicesResponse.Device.system)
  return system_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DevicesResponse_Device::set_allocated_system(std::string* system) {
  if (system != nullptr) {
    
  } else {
    
  }
  system_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), system,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (system_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    system_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DevicesResponse.Device.system)
}

// -------------------------------------------------------------------

// DevicesResponse

// repeated .DevicesResponse.Device devices = 1;
inline int DevicesResponse::_internal_devices_size() const {
  return devices_.size();
}
inline int DevicesResponse::devices_size() const {
  return _internal_devices_size();
}
inline void DevicesResponse::clear_devices() {
  devices_.Clear();
}
inline ::DevicesResponse_Device* DevicesResponse::mutable_devices(int index) {
  // @@protoc_insertion_point(field_mutable:DevicesResponse.devices)
  return devices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DevicesResponse_Device >*
DevicesResponse::mutable_devices() {
  // @@protoc_insertion_point(field_mutable_list:DevicesResponse.devices)
  return &devices_;
}
inline const ::DevicesResponse_Device& DevicesResponse::_internal_devices(int index) const {
  return devices_.Get(index);
}
inline const ::DevicesResponse_Device& DevicesResponse::devices(int index) const {
  // @@protoc_insertion_point(field_get:DevicesResponse.devices)
  return _internal_devices(index);
}
inline ::DevicesResponse_Device* DevicesResponse::_internal_add_devices() {
  return devices_.Add();
}
inline ::DevicesResponse_Device* DevicesResponse::add_devices() {
  ::DevicesResponse_Device* _add = _internal_add_devices();
  // @@protoc_insertion_point(field_add:DevicesResponse.devices)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DevicesResponse_Device >&
DevicesResponse::devices() const {
  // @@protoc_insertion_point(field_list:DevicesResponse.devices)
  return devices_;
}

// -------------------------------------------------------------------

// ResetSystemRequest

// string uri = 1;
inline void ResetSystemRequest::clear_uri() {
  uri_.ClearToEmpty();
}
inline const std::string& ResetSystemRequest::uri() const {
  // @@protoc_insertion_point(field_get:ResetSystemRequest.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResetSystemRequest::set_uri(ArgT0&& arg0, ArgT... args) {
 
 uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ResetSystemRequest.uri)
}
inline std::string* ResetSystemRequest::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:ResetSystemRequest.uri)
  return _s;
}
inline const std::string& ResetSystemRequest::_internal_uri() const {
  return uri_.Get();
}
inline void ResetSystemRequest::_internal_set_uri(const std::string& value) {
  
  uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResetSystemRequest::_internal_mutable_uri() {
  
  return uri_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResetSystemRequest::release_uri() {
  // @@protoc_insertion_point(field_release:ResetSystemRequest.uri)
  return uri_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResetSystemRequest::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  uri_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uri,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (uri_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    uri_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ResetSystemRequest.uri)
}

// -------------------------------------------------------------------

// ResetSystemResponse

// string uri = 1;
inline void ResetSystemResponse::clear_uri() {
  uri_.ClearToEmpty();
}
inline const std::string& ResetSystemResponse::uri() const {
  // @@protoc_insertion_point(field_get:ResetSystemResponse.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResetSystemResponse::set_uri(ArgT0&& arg0, ArgT... args) {
 
 uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ResetSystemResponse.uri)
}
inline std::string* ResetSystemResponse::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:ResetSystemResponse.uri)
  return _s;
}
inline const std::string& ResetSystemResponse::_internal_uri() const {
  return uri_.Get();
}
inline void ResetSystemResponse::_internal_set_uri(const std::string& value) {
  
  uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResetSystemResponse::_internal_mutable_uri() {
  
  return uri_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResetSystemResponse::release_uri() {
  // @@protoc_insertion_point(field_release:ResetSystemResponse.uri)
  return uri_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResetSystemResponse::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  uri_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uri,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (uri_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    uri_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ResetSystemResponse.uri)
}

// -------------------------------------------------------------------

// ResetToMenuRequest

// string uri = 1;
inline void ResetToMenuRequest::clear_uri() {
  uri_.ClearToEmpty();
}
inline const std::string& ResetToMenuRequest::uri() const {
  // @@protoc_insertion_point(field_get:ResetToMenuRequest.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResetToMenuRequest::set_uri(ArgT0&& arg0, ArgT... args) {
 
 uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ResetToMenuRequest.uri)
}
inline std::string* ResetToMenuRequest::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:ResetToMenuRequest.uri)
  return _s;
}
inline const std::string& ResetToMenuRequest::_internal_uri() const {
  return uri_.Get();
}
inline void ResetToMenuRequest::_internal_set_uri(const std::string& value) {
  
  uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResetToMenuRequest::_internal_mutable_uri() {
  
  return uri_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResetToMenuRequest::release_uri() {
  // @@protoc_insertion_point(field_release:ResetToMenuRequest.uri)
  return uri_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResetToMenuRequest::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  uri_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uri,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (uri_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    uri_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ResetToMenuRequest.uri)
}

// -------------------------------------------------------------------

// ResetToMenuResponse

// string uri = 1;
inline void ResetToMenuResponse::clear_uri() {
  uri_.ClearToEmpty();
}
inline const std::string& ResetToMenuResponse::uri() const {
  // @@protoc_insertion_point(field_get:ResetToMenuResponse.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResetToMenuResponse::set_uri(ArgT0&& arg0, ArgT... args) {
 
 uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ResetToMenuResponse.uri)
}
inline std::string* ResetToMenuResponse::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:ResetToMenuResponse.uri)
  return _s;
}
inline const std::string& ResetToMenuResponse::_internal_uri() const {
  return uri_.Get();
}
inline void ResetToMenuResponse::_internal_set_uri(const std::string& value) {
  
  uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResetToMenuResponse::_internal_mutable_uri() {
  
  return uri_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResetToMenuResponse::release_uri() {
  // @@protoc_insertion_point(field_release:ResetToMenuResponse.uri)
  return uri_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResetToMenuResponse::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  uri_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uri,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (uri_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    uri_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ResetToMenuResponse.uri)
}

// -------------------------------------------------------------------

// PauseEmulationRequest

// string uri = 1;
inline void PauseEmulationRequest::clear_uri() {
  uri_.ClearToEmpty();
}
inline const std::string& PauseEmulationRequest::uri() const {
  // @@protoc_insertion_point(field_get:PauseEmulationRequest.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PauseEmulationRequest::set_uri(ArgT0&& arg0, ArgT... args) {
 
 uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PauseEmulationRequest.uri)
}
inline std::string* PauseEmulationRequest::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:PauseEmulationRequest.uri)
  return _s;
}
inline const std::string& PauseEmulationRequest::_internal_uri() const {
  return uri_.Get();
}
inline void PauseEmulationRequest::_internal_set_uri(const std::string& value) {
  
  uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PauseEmulationRequest::_internal_mutable_uri() {
  
  return uri_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PauseEmulationRequest::release_uri() {
  // @@protoc_insertion_point(field_release:PauseEmulationRequest.uri)
  return uri_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PauseEmulationRequest::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  uri_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uri,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (uri_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    uri_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PauseEmulationRequest.uri)
}

// bool paused = 2;
inline void PauseEmulationRequest::clear_paused() {
  paused_ = false;
}
inline bool PauseEmulationRequest::_internal_paused() const {
  return paused_;
}
inline bool PauseEmulationRequest::paused() const {
  // @@protoc_insertion_point(field_get:PauseEmulationRequest.paused)
  return _internal_paused();
}
inline void PauseEmulationRequest::_internal_set_paused(bool value) {
  
  paused_ = value;
}
inline void PauseEmulationRequest::set_paused(bool value) {
  _internal_set_paused(value);
  // @@protoc_insertion_point(field_set:PauseEmulationRequest.paused)
}

// -------------------------------------------------------------------

// PauseEmulationResponse

// string uri = 1;
inline void PauseEmulationResponse::clear_uri() {
  uri_.ClearToEmpty();
}
inline const std::string& PauseEmulationResponse::uri() const {
  // @@protoc_insertion_point(field_get:PauseEmulationResponse.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PauseEmulationResponse::set_uri(ArgT0&& arg0, ArgT... args) {
 
 uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PauseEmulationResponse.uri)
}
inline std::string* PauseEmulationResponse::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:PauseEmulationResponse.uri)
  return _s;
}
inline const std::string& PauseEmulationResponse::_internal_uri() const {
  return uri_.Get();
}
inline void PauseEmulationResponse::_internal_set_uri(const std::string& value) {
  
  uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PauseEmulationResponse::_internal_mutable_uri() {
  
  return uri_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PauseEmulationResponse::release_uri() {
  // @@protoc_insertion_point(field_release:PauseEmulationResponse.uri)
  return uri_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PauseEmulationResponse::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  uri_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uri,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (uri_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    uri_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PauseEmulationResponse.uri)
}

// bool paused = 2;
inline void PauseEmulationResponse::clear_paused() {
  paused_ = false;
}
inline bool PauseEmulationResponse::_internal_paused() const {
  return paused_;
}
inline bool PauseEmulationResponse::paused() const {
  // @@protoc_insertion_point(field_get:PauseEmulationResponse.paused)
  return _internal_paused();
}
inline void PauseEmulationResponse::_internal_set_paused(bool value) {
  
  paused_ = value;
}
inline void PauseEmulationResponse::set_paused(bool value) {
  _internal_set_paused(value);
  // @@protoc_insertion_point(field_set:PauseEmulationResponse.paused)
}

// -------------------------------------------------------------------

// PauseToggleEmulationRequest

// string uri = 1;
inline void PauseToggleEmulationRequest::clear_uri() {
  uri_.ClearToEmpty();
}
inline const std::string& PauseToggleEmulationRequest::uri() const {
  // @@protoc_insertion_point(field_get:PauseToggleEmulationRequest.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PauseToggleEmulationRequest::set_uri(ArgT0&& arg0, ArgT... args) {
 
 uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PauseToggleEmulationRequest.uri)
}
inline std::string* PauseToggleEmulationRequest::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:PauseToggleEmulationRequest.uri)
  return _s;
}
inline const std::string& PauseToggleEmulationRequest::_internal_uri() const {
  return uri_.Get();
}
inline void PauseToggleEmulationRequest::_internal_set_uri(const std::string& value) {
  
  uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PauseToggleEmulationRequest::_internal_mutable_uri() {
  
  return uri_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PauseToggleEmulationRequest::release_uri() {
  // @@protoc_insertion_point(field_release:PauseToggleEmulationRequest.uri)
  return uri_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PauseToggleEmulationRequest::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  uri_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uri,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (uri_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    uri_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PauseToggleEmulationRequest.uri)
}

// -------------------------------------------------------------------

// PauseToggleEmulationResponse

// string uri = 1;
inline void PauseToggleEmulationResponse::clear_uri() {
  uri_.ClearToEmpty();
}
inline const std::string& PauseToggleEmulationResponse::uri() const {
  // @@protoc_insertion_point(field_get:PauseToggleEmulationResponse.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PauseToggleEmulationResponse::set_uri(ArgT0&& arg0, ArgT... args) {
 
 uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PauseToggleEmulationResponse.uri)
}
inline std::string* PauseToggleEmulationResponse::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:PauseToggleEmulationResponse.uri)
  return _s;
}
inline const std::string& PauseToggleEmulationResponse::_internal_uri() const {
  return uri_.Get();
}
inline void PauseToggleEmulationResponse::_internal_set_uri(const std::string& value) {
  
  uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PauseToggleEmulationResponse::_internal_mutable_uri() {
  
  return uri_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PauseToggleEmulationResponse::release_uri() {
  // @@protoc_insertion_point(field_release:PauseToggleEmulationResponse.uri)
  return uri_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PauseToggleEmulationResponse::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  uri_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uri,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (uri_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    uri_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PauseToggleEmulationResponse.uri)
}

// -------------------------------------------------------------------

// DetectMemoryMappingRequest

// string uri = 1;
inline void DetectMemoryMappingRequest::clear_uri() {
  uri_.ClearToEmpty();
}
inline const std::string& DetectMemoryMappingRequest::uri() const {
  // @@protoc_insertion_point(field_get:DetectMemoryMappingRequest.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DetectMemoryMappingRequest::set_uri(ArgT0&& arg0, ArgT... args) {
 
 uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DetectMemoryMappingRequest.uri)
}
inline std::string* DetectMemoryMappingRequest::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:DetectMemoryMappingRequest.uri)
  return _s;
}
inline const std::string& DetectMemoryMappingRequest::_internal_uri() const {
  return uri_.Get();
}
inline void DetectMemoryMappingRequest::_internal_set_uri(const std::string& value) {
  
  uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DetectMemoryMappingRequest::_internal_mutable_uri() {
  
  return uri_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DetectMemoryMappingRequest::release_uri() {
  // @@protoc_insertion_point(field_release:DetectMemoryMappingRequest.uri)
  return uri_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DetectMemoryMappingRequest::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  uri_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uri,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (uri_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    uri_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DetectMemoryMappingRequest.uri)
}

// optional .MemoryMapping fallbackMemoryMapping = 2;
inline bool DetectMemoryMappingRequest::_internal_has_fallbackmemorymapping() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DetectMemoryMappingRequest::has_fallbackmemorymapping() const {
  return _internal_has_fallbackmemorymapping();
}
inline void DetectMemoryMappingRequest::clear_fallbackmemorymapping() {
  fallbackmemorymapping_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::MemoryMapping DetectMemoryMappingRequest::_internal_fallbackmemorymapping() const {
  return static_cast< ::MemoryMapping >(fallbackmemorymapping_);
}
inline ::MemoryMapping DetectMemoryMappingRequest::fallbackmemorymapping() const {
  // @@protoc_insertion_point(field_get:DetectMemoryMappingRequest.fallbackMemoryMapping)
  return _internal_fallbackmemorymapping();
}
inline void DetectMemoryMappingRequest::_internal_set_fallbackmemorymapping(::MemoryMapping value) {
  _has_bits_[0] |= 0x00000002u;
  fallbackmemorymapping_ = value;
}
inline void DetectMemoryMappingRequest::set_fallbackmemorymapping(::MemoryMapping value) {
  _internal_set_fallbackmemorymapping(value);
  // @@protoc_insertion_point(field_set:DetectMemoryMappingRequest.fallbackMemoryMapping)
}

// optional bytes romHeader00FFB0 = 3;
inline bool DetectMemoryMappingRequest::_internal_has_romheader00ffb0() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DetectMemoryMappingRequest::has_romheader00ffb0() const {
  return _internal_has_romheader00ffb0();
}
inline void DetectMemoryMappingRequest::clear_romheader00ffb0() {
  romheader00ffb0_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DetectMemoryMappingRequest::romheader00ffb0() const {
  // @@protoc_insertion_point(field_get:DetectMemoryMappingRequest.romHeader00FFB0)
  return _internal_romheader00ffb0();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DetectMemoryMappingRequest::set_romheader00ffb0(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 romheader00ffb0_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DetectMemoryMappingRequest.romHeader00FFB0)
}
inline std::string* DetectMemoryMappingRequest::mutable_romheader00ffb0() {
  std::string* _s = _internal_mutable_romheader00ffb0();
  // @@protoc_insertion_point(field_mutable:DetectMemoryMappingRequest.romHeader00FFB0)
  return _s;
}
inline const std::string& DetectMemoryMappingRequest::_internal_romheader00ffb0() const {
  return romheader00ffb0_.Get();
}
inline void DetectMemoryMappingRequest::_internal_set_romheader00ffb0(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  romheader00ffb0_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DetectMemoryMappingRequest::_internal_mutable_romheader00ffb0() {
  _has_bits_[0] |= 0x00000001u;
  return romheader00ffb0_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DetectMemoryMappingRequest::release_romheader00ffb0() {
  // @@protoc_insertion_point(field_release:DetectMemoryMappingRequest.romHeader00FFB0)
  if (!_internal_has_romheader00ffb0()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = romheader00ffb0_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (romheader00ffb0_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    romheader00ffb0_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DetectMemoryMappingRequest::set_allocated_romheader00ffb0(std::string* romheader00ffb0) {
  if (romheader00ffb0 != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  romheader00ffb0_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), romheader00ffb0,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (romheader00ffb0_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    romheader00ffb0_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DetectMemoryMappingRequest.romHeader00FFB0)
}

// -------------------------------------------------------------------

// DetectMemoryMappingResponse

// string uri = 1;
inline void DetectMemoryMappingResponse::clear_uri() {
  uri_.ClearToEmpty();
}
inline const std::string& DetectMemoryMappingResponse::uri() const {
  // @@protoc_insertion_point(field_get:DetectMemoryMappingResponse.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DetectMemoryMappingResponse::set_uri(ArgT0&& arg0, ArgT... args) {
 
 uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DetectMemoryMappingResponse.uri)
}
inline std::string* DetectMemoryMappingResponse::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:DetectMemoryMappingResponse.uri)
  return _s;
}
inline const std::string& DetectMemoryMappingResponse::_internal_uri() const {
  return uri_.Get();
}
inline void DetectMemoryMappingResponse::_internal_set_uri(const std::string& value) {
  
  uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DetectMemoryMappingResponse::_internal_mutable_uri() {
  
  return uri_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DetectMemoryMappingResponse::release_uri() {
  // @@protoc_insertion_point(field_release:DetectMemoryMappingResponse.uri)
  return uri_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DetectMemoryMappingResponse::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  uri_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uri,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (uri_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    uri_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DetectMemoryMappingResponse.uri)
}

// .MemoryMapping memoryMapping = 2;
inline void DetectMemoryMappingResponse::clear_memorymapping() {
  memorymapping_ = 0;
}
inline ::MemoryMapping DetectMemoryMappingResponse::_internal_memorymapping() const {
  return static_cast< ::MemoryMapping >(memorymapping_);
}
inline ::MemoryMapping DetectMemoryMappingResponse::memorymapping() const {
  // @@protoc_insertion_point(field_get:DetectMemoryMappingResponse.memoryMapping)
  return _internal_memorymapping();
}
inline void DetectMemoryMappingResponse::_internal_set_memorymapping(::MemoryMapping value) {
  
  memorymapping_ = value;
}
inline void DetectMemoryMappingResponse::set_memorymapping(::MemoryMapping value) {
  _internal_set_memorymapping(value);
  // @@protoc_insertion_point(field_set:DetectMemoryMappingResponse.memoryMapping)
}

// bool confidence = 3;
inline void DetectMemoryMappingResponse::clear_confidence() {
  confidence_ = false;
}
inline bool DetectMemoryMappingResponse::_internal_confidence() const {
  return confidence_;
}
inline bool DetectMemoryMappingResponse::confidence() const {
  // @@protoc_insertion_point(field_get:DetectMemoryMappingResponse.confidence)
  return _internal_confidence();
}
inline void DetectMemoryMappingResponse::_internal_set_confidence(bool value) {
  
  confidence_ = value;
}
inline void DetectMemoryMappingResponse::set_confidence(bool value) {
  _internal_set_confidence(value);
  // @@protoc_insertion_point(field_set:DetectMemoryMappingResponse.confidence)
}

// bytes romHeader00FFB0 = 4;
inline void DetectMemoryMappingResponse::clear_romheader00ffb0() {
  romheader00ffb0_.ClearToEmpty();
}
inline const std::string& DetectMemoryMappingResponse::romheader00ffb0() const {
  // @@protoc_insertion_point(field_get:DetectMemoryMappingResponse.romHeader00FFB0)
  return _internal_romheader00ffb0();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DetectMemoryMappingResponse::set_romheader00ffb0(ArgT0&& arg0, ArgT... args) {
 
 romheader00ffb0_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DetectMemoryMappingResponse.romHeader00FFB0)
}
inline std::string* DetectMemoryMappingResponse::mutable_romheader00ffb0() {
  std::string* _s = _internal_mutable_romheader00ffb0();
  // @@protoc_insertion_point(field_mutable:DetectMemoryMappingResponse.romHeader00FFB0)
  return _s;
}
inline const std::string& DetectMemoryMappingResponse::_internal_romheader00ffb0() const {
  return romheader00ffb0_.Get();
}
inline void DetectMemoryMappingResponse::_internal_set_romheader00ffb0(const std::string& value) {
  
  romheader00ffb0_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DetectMemoryMappingResponse::_internal_mutable_romheader00ffb0() {
  
  return romheader00ffb0_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DetectMemoryMappingResponse::release_romheader00ffb0() {
  // @@protoc_insertion_point(field_release:DetectMemoryMappingResponse.romHeader00FFB0)
  return romheader00ffb0_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DetectMemoryMappingResponse::set_allocated_romheader00ffb0(std::string* romheader00ffb0) {
  if (romheader00ffb0 != nullptr) {
    
  } else {
    
  }
  romheader00ffb0_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), romheader00ffb0,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (romheader00ffb0_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    romheader00ffb0_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DetectMemoryMappingResponse.romHeader00FFB0)
}

// -------------------------------------------------------------------

// ReadMemoryRequest

// uint32 requestAddress = 1;
inline void ReadMemoryRequest::clear_requestaddress() {
  requestaddress_ = 0u;
}
inline uint32_t ReadMemoryRequest::_internal_requestaddress() const {
  return requestaddress_;
}
inline uint32_t ReadMemoryRequest::requestaddress() const {
  // @@protoc_insertion_point(field_get:ReadMemoryRequest.requestAddress)
  return _internal_requestaddress();
}
inline void ReadMemoryRequest::_internal_set_requestaddress(uint32_t value) {
  
  requestaddress_ = value;
}
inline void ReadMemoryRequest::set_requestaddress(uint32_t value) {
  _internal_set_requestaddress(value);
  // @@protoc_insertion_point(field_set:ReadMemoryRequest.requestAddress)
}

// .AddressSpace requestAddressSpace = 2;
inline void ReadMemoryRequest::clear_requestaddressspace() {
  requestaddressspace_ = 0;
}
inline ::AddressSpace ReadMemoryRequest::_internal_requestaddressspace() const {
  return static_cast< ::AddressSpace >(requestaddressspace_);
}
inline ::AddressSpace ReadMemoryRequest::requestaddressspace() const {
  // @@protoc_insertion_point(field_get:ReadMemoryRequest.requestAddressSpace)
  return _internal_requestaddressspace();
}
inline void ReadMemoryRequest::_internal_set_requestaddressspace(::AddressSpace value) {
  
  requestaddressspace_ = value;
}
inline void ReadMemoryRequest::set_requestaddressspace(::AddressSpace value) {
  _internal_set_requestaddressspace(value);
  // @@protoc_insertion_point(field_set:ReadMemoryRequest.requestAddressSpace)
}

// .MemoryMapping requestMemoryMapping = 4;
inline void ReadMemoryRequest::clear_requestmemorymapping() {
  requestmemorymapping_ = 0;
}
inline ::MemoryMapping ReadMemoryRequest::_internal_requestmemorymapping() const {
  return static_cast< ::MemoryMapping >(requestmemorymapping_);
}
inline ::MemoryMapping ReadMemoryRequest::requestmemorymapping() const {
  // @@protoc_insertion_point(field_get:ReadMemoryRequest.requestMemoryMapping)
  return _internal_requestmemorymapping();
}
inline void ReadMemoryRequest::_internal_set_requestmemorymapping(::MemoryMapping value) {
  
  requestmemorymapping_ = value;
}
inline void ReadMemoryRequest::set_requestmemorymapping(::MemoryMapping value) {
  _internal_set_requestmemorymapping(value);
  // @@protoc_insertion_point(field_set:ReadMemoryRequest.requestMemoryMapping)
}

// uint32 size = 3;
inline void ReadMemoryRequest::clear_size() {
  size_ = 0u;
}
inline uint32_t ReadMemoryRequest::_internal_size() const {
  return size_;
}
inline uint32_t ReadMemoryRequest::size() const {
  // @@protoc_insertion_point(field_get:ReadMemoryRequest.size)
  return _internal_size();
}
inline void ReadMemoryRequest::_internal_set_size(uint32_t value) {
  
  size_ = value;
}
inline void ReadMemoryRequest::set_size(uint32_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:ReadMemoryRequest.size)
}

// -------------------------------------------------------------------

// ReadMemoryResponse

// uint32 requestAddress = 1;
inline void ReadMemoryResponse::clear_requestaddress() {
  requestaddress_ = 0u;
}
inline uint32_t ReadMemoryResponse::_internal_requestaddress() const {
  return requestaddress_;
}
inline uint32_t ReadMemoryResponse::requestaddress() const {
  // @@protoc_insertion_point(field_get:ReadMemoryResponse.requestAddress)
  return _internal_requestaddress();
}
inline void ReadMemoryResponse::_internal_set_requestaddress(uint32_t value) {
  
  requestaddress_ = value;
}
inline void ReadMemoryResponse::set_requestaddress(uint32_t value) {
  _internal_set_requestaddress(value);
  // @@protoc_insertion_point(field_set:ReadMemoryResponse.requestAddress)
}

// .AddressSpace requestAddressSpace = 2;
inline void ReadMemoryResponse::clear_requestaddressspace() {
  requestaddressspace_ = 0;
}
inline ::AddressSpace ReadMemoryResponse::_internal_requestaddressspace() const {
  return static_cast< ::AddressSpace >(requestaddressspace_);
}
inline ::AddressSpace ReadMemoryResponse::requestaddressspace() const {
  // @@protoc_insertion_point(field_get:ReadMemoryResponse.requestAddressSpace)
  return _internal_requestaddressspace();
}
inline void ReadMemoryResponse::_internal_set_requestaddressspace(::AddressSpace value) {
  
  requestaddressspace_ = value;
}
inline void ReadMemoryResponse::set_requestaddressspace(::AddressSpace value) {
  _internal_set_requestaddressspace(value);
  // @@protoc_insertion_point(field_set:ReadMemoryResponse.requestAddressSpace)
}

// .MemoryMapping requestMemoryMapping = 6;
inline void ReadMemoryResponse::clear_requestmemorymapping() {
  requestmemorymapping_ = 0;
}
inline ::MemoryMapping ReadMemoryResponse::_internal_requestmemorymapping() const {
  return static_cast< ::MemoryMapping >(requestmemorymapping_);
}
inline ::MemoryMapping ReadMemoryResponse::requestmemorymapping() const {
  // @@protoc_insertion_point(field_get:ReadMemoryResponse.requestMemoryMapping)
  return _internal_requestmemorymapping();
}
inline void ReadMemoryResponse::_internal_set_requestmemorymapping(::MemoryMapping value) {
  
  requestmemorymapping_ = value;
}
inline void ReadMemoryResponse::set_requestmemorymapping(::MemoryMapping value) {
  _internal_set_requestmemorymapping(value);
  // @@protoc_insertion_point(field_set:ReadMemoryResponse.requestMemoryMapping)
}

// uint32 deviceAddress = 3;
inline void ReadMemoryResponse::clear_deviceaddress() {
  deviceaddress_ = 0u;
}
inline uint32_t ReadMemoryResponse::_internal_deviceaddress() const {
  return deviceaddress_;
}
inline uint32_t ReadMemoryResponse::deviceaddress() const {
  // @@protoc_insertion_point(field_get:ReadMemoryResponse.deviceAddress)
  return _internal_deviceaddress();
}
inline void ReadMemoryResponse::_internal_set_deviceaddress(uint32_t value) {
  
  deviceaddress_ = value;
}
inline void ReadMemoryResponse::set_deviceaddress(uint32_t value) {
  _internal_set_deviceaddress(value);
  // @@protoc_insertion_point(field_set:ReadMemoryResponse.deviceAddress)
}

// .AddressSpace deviceAddressSpace = 4;
inline void ReadMemoryResponse::clear_deviceaddressspace() {
  deviceaddressspace_ = 0;
}
inline ::AddressSpace ReadMemoryResponse::_internal_deviceaddressspace() const {
  return static_cast< ::AddressSpace >(deviceaddressspace_);
}
inline ::AddressSpace ReadMemoryResponse::deviceaddressspace() const {
  // @@protoc_insertion_point(field_get:ReadMemoryResponse.deviceAddressSpace)
  return _internal_deviceaddressspace();
}
inline void ReadMemoryResponse::_internal_set_deviceaddressspace(::AddressSpace value) {
  
  deviceaddressspace_ = value;
}
inline void ReadMemoryResponse::set_deviceaddressspace(::AddressSpace value) {
  _internal_set_deviceaddressspace(value);
  // @@protoc_insertion_point(field_set:ReadMemoryResponse.deviceAddressSpace)
}

// bytes data = 5;
inline void ReadMemoryResponse::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& ReadMemoryResponse::data() const {
  // @@protoc_insertion_point(field_get:ReadMemoryResponse.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadMemoryResponse::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ReadMemoryResponse.data)
}
inline std::string* ReadMemoryResponse::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:ReadMemoryResponse.data)
  return _s;
}
inline const std::string& ReadMemoryResponse::_internal_data() const {
  return data_.Get();
}
inline void ReadMemoryResponse::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ReadMemoryResponse::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ReadMemoryResponse::release_data() {
  // @@protoc_insertion_point(field_release:ReadMemoryResponse.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ReadMemoryResponse::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ReadMemoryResponse.data)
}

// -------------------------------------------------------------------

// WriteMemoryRequest

// uint32 requestAddress = 1;
inline void WriteMemoryRequest::clear_requestaddress() {
  requestaddress_ = 0u;
}
inline uint32_t WriteMemoryRequest::_internal_requestaddress() const {
  return requestaddress_;
}
inline uint32_t WriteMemoryRequest::requestaddress() const {
  // @@protoc_insertion_point(field_get:WriteMemoryRequest.requestAddress)
  return _internal_requestaddress();
}
inline void WriteMemoryRequest::_internal_set_requestaddress(uint32_t value) {
  
  requestaddress_ = value;
}
inline void WriteMemoryRequest::set_requestaddress(uint32_t value) {
  _internal_set_requestaddress(value);
  // @@protoc_insertion_point(field_set:WriteMemoryRequest.requestAddress)
}

// .AddressSpace requestAddressSpace = 2;
inline void WriteMemoryRequest::clear_requestaddressspace() {
  requestaddressspace_ = 0;
}
inline ::AddressSpace WriteMemoryRequest::_internal_requestaddressspace() const {
  return static_cast< ::AddressSpace >(requestaddressspace_);
}
inline ::AddressSpace WriteMemoryRequest::requestaddressspace() const {
  // @@protoc_insertion_point(field_get:WriteMemoryRequest.requestAddressSpace)
  return _internal_requestaddressspace();
}
inline void WriteMemoryRequest::_internal_set_requestaddressspace(::AddressSpace value) {
  
  requestaddressspace_ = value;
}
inline void WriteMemoryRequest::set_requestaddressspace(::AddressSpace value) {
  _internal_set_requestaddressspace(value);
  // @@protoc_insertion_point(field_set:WriteMemoryRequest.requestAddressSpace)
}

// .MemoryMapping requestMemoryMapping = 4;
inline void WriteMemoryRequest::clear_requestmemorymapping() {
  requestmemorymapping_ = 0;
}
inline ::MemoryMapping WriteMemoryRequest::_internal_requestmemorymapping() const {
  return static_cast< ::MemoryMapping >(requestmemorymapping_);
}
inline ::MemoryMapping WriteMemoryRequest::requestmemorymapping() const {
  // @@protoc_insertion_point(field_get:WriteMemoryRequest.requestMemoryMapping)
  return _internal_requestmemorymapping();
}
inline void WriteMemoryRequest::_internal_set_requestmemorymapping(::MemoryMapping value) {
  
  requestmemorymapping_ = value;
}
inline void WriteMemoryRequest::set_requestmemorymapping(::MemoryMapping value) {
  _internal_set_requestmemorymapping(value);
  // @@protoc_insertion_point(field_set:WriteMemoryRequest.requestMemoryMapping)
}

// bytes data = 3;
inline void WriteMemoryRequest::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& WriteMemoryRequest::data() const {
  // @@protoc_insertion_point(field_get:WriteMemoryRequest.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WriteMemoryRequest::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:WriteMemoryRequest.data)
}
inline std::string* WriteMemoryRequest::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:WriteMemoryRequest.data)
  return _s;
}
inline const std::string& WriteMemoryRequest::_internal_data() const {
  return data_.Get();
}
inline void WriteMemoryRequest::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WriteMemoryRequest::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WriteMemoryRequest::release_data() {
  // @@protoc_insertion_point(field_release:WriteMemoryRequest.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WriteMemoryRequest::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:WriteMemoryRequest.data)
}

// -------------------------------------------------------------------

// WriteMemoryResponse

// uint32 requestAddress = 1;
inline void WriteMemoryResponse::clear_requestaddress() {
  requestaddress_ = 0u;
}
inline uint32_t WriteMemoryResponse::_internal_requestaddress() const {
  return requestaddress_;
}
inline uint32_t WriteMemoryResponse::requestaddress() const {
  // @@protoc_insertion_point(field_get:WriteMemoryResponse.requestAddress)
  return _internal_requestaddress();
}
inline void WriteMemoryResponse::_internal_set_requestaddress(uint32_t value) {
  
  requestaddress_ = value;
}
inline void WriteMemoryResponse::set_requestaddress(uint32_t value) {
  _internal_set_requestaddress(value);
  // @@protoc_insertion_point(field_set:WriteMemoryResponse.requestAddress)
}

// .AddressSpace requestAddressSpace = 2;
inline void WriteMemoryResponse::clear_requestaddressspace() {
  requestaddressspace_ = 0;
}
inline ::AddressSpace WriteMemoryResponse::_internal_requestaddressspace() const {
  return static_cast< ::AddressSpace >(requestaddressspace_);
}
inline ::AddressSpace WriteMemoryResponse::requestaddressspace() const {
  // @@protoc_insertion_point(field_get:WriteMemoryResponse.requestAddressSpace)
  return _internal_requestaddressspace();
}
inline void WriteMemoryResponse::_internal_set_requestaddressspace(::AddressSpace value) {
  
  requestaddressspace_ = value;
}
inline void WriteMemoryResponse::set_requestaddressspace(::AddressSpace value) {
  _internal_set_requestaddressspace(value);
  // @@protoc_insertion_point(field_set:WriteMemoryResponse.requestAddressSpace)
}

// .MemoryMapping requestMemoryMapping = 6;
inline void WriteMemoryResponse::clear_requestmemorymapping() {
  requestmemorymapping_ = 0;
}
inline ::MemoryMapping WriteMemoryResponse::_internal_requestmemorymapping() const {
  return static_cast< ::MemoryMapping >(requestmemorymapping_);
}
inline ::MemoryMapping WriteMemoryResponse::requestmemorymapping() const {
  // @@protoc_insertion_point(field_get:WriteMemoryResponse.requestMemoryMapping)
  return _internal_requestmemorymapping();
}
inline void WriteMemoryResponse::_internal_set_requestmemorymapping(::MemoryMapping value) {
  
  requestmemorymapping_ = value;
}
inline void WriteMemoryResponse::set_requestmemorymapping(::MemoryMapping value) {
  _internal_set_requestmemorymapping(value);
  // @@protoc_insertion_point(field_set:WriteMemoryResponse.requestMemoryMapping)
}

// uint32 deviceAddress = 3;
inline void WriteMemoryResponse::clear_deviceaddress() {
  deviceaddress_ = 0u;
}
inline uint32_t WriteMemoryResponse::_internal_deviceaddress() const {
  return deviceaddress_;
}
inline uint32_t WriteMemoryResponse::deviceaddress() const {
  // @@protoc_insertion_point(field_get:WriteMemoryResponse.deviceAddress)
  return _internal_deviceaddress();
}
inline void WriteMemoryResponse::_internal_set_deviceaddress(uint32_t value) {
  
  deviceaddress_ = value;
}
inline void WriteMemoryResponse::set_deviceaddress(uint32_t value) {
  _internal_set_deviceaddress(value);
  // @@protoc_insertion_point(field_set:WriteMemoryResponse.deviceAddress)
}

// .AddressSpace deviceAddressSpace = 4;
inline void WriteMemoryResponse::clear_deviceaddressspace() {
  deviceaddressspace_ = 0;
}
inline ::AddressSpace WriteMemoryResponse::_internal_deviceaddressspace() const {
  return static_cast< ::AddressSpace >(deviceaddressspace_);
}
inline ::AddressSpace WriteMemoryResponse::deviceaddressspace() const {
  // @@protoc_insertion_point(field_get:WriteMemoryResponse.deviceAddressSpace)
  return _internal_deviceaddressspace();
}
inline void WriteMemoryResponse::_internal_set_deviceaddressspace(::AddressSpace value) {
  
  deviceaddressspace_ = value;
}
inline void WriteMemoryResponse::set_deviceaddressspace(::AddressSpace value) {
  _internal_set_deviceaddressspace(value);
  // @@protoc_insertion_point(field_set:WriteMemoryResponse.deviceAddressSpace)
}

// uint32 size = 5;
inline void WriteMemoryResponse::clear_size() {
  size_ = 0u;
}
inline uint32_t WriteMemoryResponse::_internal_size() const {
  return size_;
}
inline uint32_t WriteMemoryResponse::size() const {
  // @@protoc_insertion_point(field_get:WriteMemoryResponse.size)
  return _internal_size();
}
inline void WriteMemoryResponse::_internal_set_size(uint32_t value) {
  
  size_ = value;
}
inline void WriteMemoryResponse::set_size(uint32_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:WriteMemoryResponse.size)
}

// -------------------------------------------------------------------

// SingleReadMemoryRequest

// string uri = 1;
inline void SingleReadMemoryRequest::clear_uri() {
  uri_.ClearToEmpty();
}
inline const std::string& SingleReadMemoryRequest::uri() const {
  // @@protoc_insertion_point(field_get:SingleReadMemoryRequest.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SingleReadMemoryRequest::set_uri(ArgT0&& arg0, ArgT... args) {
 
 uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SingleReadMemoryRequest.uri)
}
inline std::string* SingleReadMemoryRequest::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:SingleReadMemoryRequest.uri)
  return _s;
}
inline const std::string& SingleReadMemoryRequest::_internal_uri() const {
  return uri_.Get();
}
inline void SingleReadMemoryRequest::_internal_set_uri(const std::string& value) {
  
  uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SingleReadMemoryRequest::_internal_mutable_uri() {
  
  return uri_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SingleReadMemoryRequest::release_uri() {
  // @@protoc_insertion_point(field_release:SingleReadMemoryRequest.uri)
  return uri_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SingleReadMemoryRequest::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  uri_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uri,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (uri_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    uri_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SingleReadMemoryRequest.uri)
}

// .ReadMemoryRequest request = 2;
inline bool SingleReadMemoryRequest::_internal_has_request() const {
  return this != internal_default_instance() && request_ != nullptr;
}
inline bool SingleReadMemoryRequest::has_request() const {
  return _internal_has_request();
}
inline void SingleReadMemoryRequest::clear_request() {
  if (GetArenaForAllocation() == nullptr && request_ != nullptr) {
    delete request_;
  }
  request_ = nullptr;
}
inline const ::ReadMemoryRequest& SingleReadMemoryRequest::_internal_request() const {
  const ::ReadMemoryRequest* p = request_;
  return p != nullptr ? *p : reinterpret_cast<const ::ReadMemoryRequest&>(
      ::_ReadMemoryRequest_default_instance_);
}
inline const ::ReadMemoryRequest& SingleReadMemoryRequest::request() const {
  // @@protoc_insertion_point(field_get:SingleReadMemoryRequest.request)
  return _internal_request();
}
inline void SingleReadMemoryRequest::unsafe_arena_set_allocated_request(
    ::ReadMemoryRequest* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request_);
  }
  request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SingleReadMemoryRequest.request)
}
inline ::ReadMemoryRequest* SingleReadMemoryRequest::release_request() {
  
  ::ReadMemoryRequest* temp = request_;
  request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ReadMemoryRequest* SingleReadMemoryRequest::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:SingleReadMemoryRequest.request)
  
  ::ReadMemoryRequest* temp = request_;
  request_ = nullptr;
  return temp;
}
inline ::ReadMemoryRequest* SingleReadMemoryRequest::_internal_mutable_request() {
  
  if (request_ == nullptr) {
    auto* p = CreateMaybeMessage<::ReadMemoryRequest>(GetArenaForAllocation());
    request_ = p;
  }
  return request_;
}
inline ::ReadMemoryRequest* SingleReadMemoryRequest::mutable_request() {
  ::ReadMemoryRequest* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:SingleReadMemoryRequest.request)
  return _msg;
}
inline void SingleReadMemoryRequest::set_allocated_request(::ReadMemoryRequest* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete request_;
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ReadMemoryRequest>::GetOwningArena(request);
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  request_ = request;
  // @@protoc_insertion_point(field_set_allocated:SingleReadMemoryRequest.request)
}

// -------------------------------------------------------------------

// SingleReadMemoryResponse

// string uri = 1;
inline void SingleReadMemoryResponse::clear_uri() {
  uri_.ClearToEmpty();
}
inline const std::string& SingleReadMemoryResponse::uri() const {
  // @@protoc_insertion_point(field_get:SingleReadMemoryResponse.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SingleReadMemoryResponse::set_uri(ArgT0&& arg0, ArgT... args) {
 
 uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SingleReadMemoryResponse.uri)
}
inline std::string* SingleReadMemoryResponse::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:SingleReadMemoryResponse.uri)
  return _s;
}
inline const std::string& SingleReadMemoryResponse::_internal_uri() const {
  return uri_.Get();
}
inline void SingleReadMemoryResponse::_internal_set_uri(const std::string& value) {
  
  uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SingleReadMemoryResponse::_internal_mutable_uri() {
  
  return uri_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SingleReadMemoryResponse::release_uri() {
  // @@protoc_insertion_point(field_release:SingleReadMemoryResponse.uri)
  return uri_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SingleReadMemoryResponse::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  uri_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uri,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (uri_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    uri_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SingleReadMemoryResponse.uri)
}

// .ReadMemoryResponse response = 2;
inline bool SingleReadMemoryResponse::_internal_has_response() const {
  return this != internal_default_instance() && response_ != nullptr;
}
inline bool SingleReadMemoryResponse::has_response() const {
  return _internal_has_response();
}
inline void SingleReadMemoryResponse::clear_response() {
  if (GetArenaForAllocation() == nullptr && response_ != nullptr) {
    delete response_;
  }
  response_ = nullptr;
}
inline const ::ReadMemoryResponse& SingleReadMemoryResponse::_internal_response() const {
  const ::ReadMemoryResponse* p = response_;
  return p != nullptr ? *p : reinterpret_cast<const ::ReadMemoryResponse&>(
      ::_ReadMemoryResponse_default_instance_);
}
inline const ::ReadMemoryResponse& SingleReadMemoryResponse::response() const {
  // @@protoc_insertion_point(field_get:SingleReadMemoryResponse.response)
  return _internal_response();
}
inline void SingleReadMemoryResponse::unsafe_arena_set_allocated_response(
    ::ReadMemoryResponse* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response_);
  }
  response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SingleReadMemoryResponse.response)
}
inline ::ReadMemoryResponse* SingleReadMemoryResponse::release_response() {
  
  ::ReadMemoryResponse* temp = response_;
  response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ReadMemoryResponse* SingleReadMemoryResponse::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:SingleReadMemoryResponse.response)
  
  ::ReadMemoryResponse* temp = response_;
  response_ = nullptr;
  return temp;
}
inline ::ReadMemoryResponse* SingleReadMemoryResponse::_internal_mutable_response() {
  
  if (response_ == nullptr) {
    auto* p = CreateMaybeMessage<::ReadMemoryResponse>(GetArenaForAllocation());
    response_ = p;
  }
  return response_;
}
inline ::ReadMemoryResponse* SingleReadMemoryResponse::mutable_response() {
  ::ReadMemoryResponse* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:SingleReadMemoryResponse.response)
  return _msg;
}
inline void SingleReadMemoryResponse::set_allocated_response(::ReadMemoryResponse* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete response_;
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ReadMemoryResponse>::GetOwningArena(response);
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  response_ = response;
  // @@protoc_insertion_point(field_set_allocated:SingleReadMemoryResponse.response)
}

// -------------------------------------------------------------------

// SingleWriteMemoryRequest

// string uri = 1;
inline void SingleWriteMemoryRequest::clear_uri() {
  uri_.ClearToEmpty();
}
inline const std::string& SingleWriteMemoryRequest::uri() const {
  // @@protoc_insertion_point(field_get:SingleWriteMemoryRequest.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SingleWriteMemoryRequest::set_uri(ArgT0&& arg0, ArgT... args) {
 
 uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SingleWriteMemoryRequest.uri)
}
inline std::string* SingleWriteMemoryRequest::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:SingleWriteMemoryRequest.uri)
  return _s;
}
inline const std::string& SingleWriteMemoryRequest::_internal_uri() const {
  return uri_.Get();
}
inline void SingleWriteMemoryRequest::_internal_set_uri(const std::string& value) {
  
  uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SingleWriteMemoryRequest::_internal_mutable_uri() {
  
  return uri_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SingleWriteMemoryRequest::release_uri() {
  // @@protoc_insertion_point(field_release:SingleWriteMemoryRequest.uri)
  return uri_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SingleWriteMemoryRequest::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  uri_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uri,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (uri_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    uri_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SingleWriteMemoryRequest.uri)
}

// .WriteMemoryRequest request = 2;
inline bool SingleWriteMemoryRequest::_internal_has_request() const {
  return this != internal_default_instance() && request_ != nullptr;
}
inline bool SingleWriteMemoryRequest::has_request() const {
  return _internal_has_request();
}
inline void SingleWriteMemoryRequest::clear_request() {
  if (GetArenaForAllocation() == nullptr && request_ != nullptr) {
    delete request_;
  }
  request_ = nullptr;
}
inline const ::WriteMemoryRequest& SingleWriteMemoryRequest::_internal_request() const {
  const ::WriteMemoryRequest* p = request_;
  return p != nullptr ? *p : reinterpret_cast<const ::WriteMemoryRequest&>(
      ::_WriteMemoryRequest_default_instance_);
}
inline const ::WriteMemoryRequest& SingleWriteMemoryRequest::request() const {
  // @@protoc_insertion_point(field_get:SingleWriteMemoryRequest.request)
  return _internal_request();
}
inline void SingleWriteMemoryRequest::unsafe_arena_set_allocated_request(
    ::WriteMemoryRequest* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request_);
  }
  request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SingleWriteMemoryRequest.request)
}
inline ::WriteMemoryRequest* SingleWriteMemoryRequest::release_request() {
  
  ::WriteMemoryRequest* temp = request_;
  request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::WriteMemoryRequest* SingleWriteMemoryRequest::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:SingleWriteMemoryRequest.request)
  
  ::WriteMemoryRequest* temp = request_;
  request_ = nullptr;
  return temp;
}
inline ::WriteMemoryRequest* SingleWriteMemoryRequest::_internal_mutable_request() {
  
  if (request_ == nullptr) {
    auto* p = CreateMaybeMessage<::WriteMemoryRequest>(GetArenaForAllocation());
    request_ = p;
  }
  return request_;
}
inline ::WriteMemoryRequest* SingleWriteMemoryRequest::mutable_request() {
  ::WriteMemoryRequest* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:SingleWriteMemoryRequest.request)
  return _msg;
}
inline void SingleWriteMemoryRequest::set_allocated_request(::WriteMemoryRequest* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete request_;
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::WriteMemoryRequest>::GetOwningArena(request);
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  request_ = request;
  // @@protoc_insertion_point(field_set_allocated:SingleWriteMemoryRequest.request)
}

// -------------------------------------------------------------------

// SingleWriteMemoryResponse

// string uri = 1;
inline void SingleWriteMemoryResponse::clear_uri() {
  uri_.ClearToEmpty();
}
inline const std::string& SingleWriteMemoryResponse::uri() const {
  // @@protoc_insertion_point(field_get:SingleWriteMemoryResponse.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SingleWriteMemoryResponse::set_uri(ArgT0&& arg0, ArgT... args) {
 
 uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SingleWriteMemoryResponse.uri)
}
inline std::string* SingleWriteMemoryResponse::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:SingleWriteMemoryResponse.uri)
  return _s;
}
inline const std::string& SingleWriteMemoryResponse::_internal_uri() const {
  return uri_.Get();
}
inline void SingleWriteMemoryResponse::_internal_set_uri(const std::string& value) {
  
  uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SingleWriteMemoryResponse::_internal_mutable_uri() {
  
  return uri_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SingleWriteMemoryResponse::release_uri() {
  // @@protoc_insertion_point(field_release:SingleWriteMemoryResponse.uri)
  return uri_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SingleWriteMemoryResponse::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  uri_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uri,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (uri_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    uri_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SingleWriteMemoryResponse.uri)
}

// .WriteMemoryResponse response = 2;
inline bool SingleWriteMemoryResponse::_internal_has_response() const {
  return this != internal_default_instance() && response_ != nullptr;
}
inline bool SingleWriteMemoryResponse::has_response() const {
  return _internal_has_response();
}
inline void SingleWriteMemoryResponse::clear_response() {
  if (GetArenaForAllocation() == nullptr && response_ != nullptr) {
    delete response_;
  }
  response_ = nullptr;
}
inline const ::WriteMemoryResponse& SingleWriteMemoryResponse::_internal_response() const {
  const ::WriteMemoryResponse* p = response_;
  return p != nullptr ? *p : reinterpret_cast<const ::WriteMemoryResponse&>(
      ::_WriteMemoryResponse_default_instance_);
}
inline const ::WriteMemoryResponse& SingleWriteMemoryResponse::response() const {
  // @@protoc_insertion_point(field_get:SingleWriteMemoryResponse.response)
  return _internal_response();
}
inline void SingleWriteMemoryResponse::unsafe_arena_set_allocated_response(
    ::WriteMemoryResponse* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response_);
  }
  response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SingleWriteMemoryResponse.response)
}
inline ::WriteMemoryResponse* SingleWriteMemoryResponse::release_response() {
  
  ::WriteMemoryResponse* temp = response_;
  response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::WriteMemoryResponse* SingleWriteMemoryResponse::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:SingleWriteMemoryResponse.response)
  
  ::WriteMemoryResponse* temp = response_;
  response_ = nullptr;
  return temp;
}
inline ::WriteMemoryResponse* SingleWriteMemoryResponse::_internal_mutable_response() {
  
  if (response_ == nullptr) {
    auto* p = CreateMaybeMessage<::WriteMemoryResponse>(GetArenaForAllocation());
    response_ = p;
  }
  return response_;
}
inline ::WriteMemoryResponse* SingleWriteMemoryResponse::mutable_response() {
  ::WriteMemoryResponse* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:SingleWriteMemoryResponse.response)
  return _msg;
}
inline void SingleWriteMemoryResponse::set_allocated_response(::WriteMemoryResponse* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete response_;
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::WriteMemoryResponse>::GetOwningArena(response);
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  response_ = response;
  // @@protoc_insertion_point(field_set_allocated:SingleWriteMemoryResponse.response)
}

// -------------------------------------------------------------------

// MultiReadMemoryRequest

// string uri = 1;
inline void MultiReadMemoryRequest::clear_uri() {
  uri_.ClearToEmpty();
}
inline const std::string& MultiReadMemoryRequest::uri() const {
  // @@protoc_insertion_point(field_get:MultiReadMemoryRequest.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MultiReadMemoryRequest::set_uri(ArgT0&& arg0, ArgT... args) {
 
 uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MultiReadMemoryRequest.uri)
}
inline std::string* MultiReadMemoryRequest::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:MultiReadMemoryRequest.uri)
  return _s;
}
inline const std::string& MultiReadMemoryRequest::_internal_uri() const {
  return uri_.Get();
}
inline void MultiReadMemoryRequest::_internal_set_uri(const std::string& value) {
  
  uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MultiReadMemoryRequest::_internal_mutable_uri() {
  
  return uri_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MultiReadMemoryRequest::release_uri() {
  // @@protoc_insertion_point(field_release:MultiReadMemoryRequest.uri)
  return uri_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MultiReadMemoryRequest::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  uri_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uri,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (uri_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    uri_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MultiReadMemoryRequest.uri)
}

// repeated .ReadMemoryRequest requests = 2;
inline int MultiReadMemoryRequest::_internal_requests_size() const {
  return requests_.size();
}
inline int MultiReadMemoryRequest::requests_size() const {
  return _internal_requests_size();
}
inline void MultiReadMemoryRequest::clear_requests() {
  requests_.Clear();
}
inline ::ReadMemoryRequest* MultiReadMemoryRequest::mutable_requests(int index) {
  // @@protoc_insertion_point(field_mutable:MultiReadMemoryRequest.requests)
  return requests_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ReadMemoryRequest >*
MultiReadMemoryRequest::mutable_requests() {
  // @@protoc_insertion_point(field_mutable_list:MultiReadMemoryRequest.requests)
  return &requests_;
}
inline const ::ReadMemoryRequest& MultiReadMemoryRequest::_internal_requests(int index) const {
  return requests_.Get(index);
}
inline const ::ReadMemoryRequest& MultiReadMemoryRequest::requests(int index) const {
  // @@protoc_insertion_point(field_get:MultiReadMemoryRequest.requests)
  return _internal_requests(index);
}
inline ::ReadMemoryRequest* MultiReadMemoryRequest::_internal_add_requests() {
  return requests_.Add();
}
inline ::ReadMemoryRequest* MultiReadMemoryRequest::add_requests() {
  ::ReadMemoryRequest* _add = _internal_add_requests();
  // @@protoc_insertion_point(field_add:MultiReadMemoryRequest.requests)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ReadMemoryRequest >&
MultiReadMemoryRequest::requests() const {
  // @@protoc_insertion_point(field_list:MultiReadMemoryRequest.requests)
  return requests_;
}

// -------------------------------------------------------------------

// MultiReadMemoryResponse

// string uri = 1;
inline void MultiReadMemoryResponse::clear_uri() {
  uri_.ClearToEmpty();
}
inline const std::string& MultiReadMemoryResponse::uri() const {
  // @@protoc_insertion_point(field_get:MultiReadMemoryResponse.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MultiReadMemoryResponse::set_uri(ArgT0&& arg0, ArgT... args) {
 
 uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MultiReadMemoryResponse.uri)
}
inline std::string* MultiReadMemoryResponse::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:MultiReadMemoryResponse.uri)
  return _s;
}
inline const std::string& MultiReadMemoryResponse::_internal_uri() const {
  return uri_.Get();
}
inline void MultiReadMemoryResponse::_internal_set_uri(const std::string& value) {
  
  uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MultiReadMemoryResponse::_internal_mutable_uri() {
  
  return uri_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MultiReadMemoryResponse::release_uri() {
  // @@protoc_insertion_point(field_release:MultiReadMemoryResponse.uri)
  return uri_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MultiReadMemoryResponse::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  uri_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uri,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (uri_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    uri_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MultiReadMemoryResponse.uri)
}

// repeated .ReadMemoryResponse responses = 2;
inline int MultiReadMemoryResponse::_internal_responses_size() const {
  return responses_.size();
}
inline int MultiReadMemoryResponse::responses_size() const {
  return _internal_responses_size();
}
inline void MultiReadMemoryResponse::clear_responses() {
  responses_.Clear();
}
inline ::ReadMemoryResponse* MultiReadMemoryResponse::mutable_responses(int index) {
  // @@protoc_insertion_point(field_mutable:MultiReadMemoryResponse.responses)
  return responses_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ReadMemoryResponse >*
MultiReadMemoryResponse::mutable_responses() {
  // @@protoc_insertion_point(field_mutable_list:MultiReadMemoryResponse.responses)
  return &responses_;
}
inline const ::ReadMemoryResponse& MultiReadMemoryResponse::_internal_responses(int index) const {
  return responses_.Get(index);
}
inline const ::ReadMemoryResponse& MultiReadMemoryResponse::responses(int index) const {
  // @@protoc_insertion_point(field_get:MultiReadMemoryResponse.responses)
  return _internal_responses(index);
}
inline ::ReadMemoryResponse* MultiReadMemoryResponse::_internal_add_responses() {
  return responses_.Add();
}
inline ::ReadMemoryResponse* MultiReadMemoryResponse::add_responses() {
  ::ReadMemoryResponse* _add = _internal_add_responses();
  // @@protoc_insertion_point(field_add:MultiReadMemoryResponse.responses)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ReadMemoryResponse >&
MultiReadMemoryResponse::responses() const {
  // @@protoc_insertion_point(field_list:MultiReadMemoryResponse.responses)
  return responses_;
}

// -------------------------------------------------------------------

// MultiWriteMemoryRequest

// string uri = 1;
inline void MultiWriteMemoryRequest::clear_uri() {
  uri_.ClearToEmpty();
}
inline const std::string& MultiWriteMemoryRequest::uri() const {
  // @@protoc_insertion_point(field_get:MultiWriteMemoryRequest.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MultiWriteMemoryRequest::set_uri(ArgT0&& arg0, ArgT... args) {
 
 uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MultiWriteMemoryRequest.uri)
}
inline std::string* MultiWriteMemoryRequest::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:MultiWriteMemoryRequest.uri)
  return _s;
}
inline const std::string& MultiWriteMemoryRequest::_internal_uri() const {
  return uri_.Get();
}
inline void MultiWriteMemoryRequest::_internal_set_uri(const std::string& value) {
  
  uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MultiWriteMemoryRequest::_internal_mutable_uri() {
  
  return uri_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MultiWriteMemoryRequest::release_uri() {
  // @@protoc_insertion_point(field_release:MultiWriteMemoryRequest.uri)
  return uri_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MultiWriteMemoryRequest::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  uri_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uri,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (uri_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    uri_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MultiWriteMemoryRequest.uri)
}

// repeated .WriteMemoryRequest requests = 2;
inline int MultiWriteMemoryRequest::_internal_requests_size() const {
  return requests_.size();
}
inline int MultiWriteMemoryRequest::requests_size() const {
  return _internal_requests_size();
}
inline void MultiWriteMemoryRequest::clear_requests() {
  requests_.Clear();
}
inline ::WriteMemoryRequest* MultiWriteMemoryRequest::mutable_requests(int index) {
  // @@protoc_insertion_point(field_mutable:MultiWriteMemoryRequest.requests)
  return requests_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::WriteMemoryRequest >*
MultiWriteMemoryRequest::mutable_requests() {
  // @@protoc_insertion_point(field_mutable_list:MultiWriteMemoryRequest.requests)
  return &requests_;
}
inline const ::WriteMemoryRequest& MultiWriteMemoryRequest::_internal_requests(int index) const {
  return requests_.Get(index);
}
inline const ::WriteMemoryRequest& MultiWriteMemoryRequest::requests(int index) const {
  // @@protoc_insertion_point(field_get:MultiWriteMemoryRequest.requests)
  return _internal_requests(index);
}
inline ::WriteMemoryRequest* MultiWriteMemoryRequest::_internal_add_requests() {
  return requests_.Add();
}
inline ::WriteMemoryRequest* MultiWriteMemoryRequest::add_requests() {
  ::WriteMemoryRequest* _add = _internal_add_requests();
  // @@protoc_insertion_point(field_add:MultiWriteMemoryRequest.requests)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::WriteMemoryRequest >&
MultiWriteMemoryRequest::requests() const {
  // @@protoc_insertion_point(field_list:MultiWriteMemoryRequest.requests)
  return requests_;
}

// -------------------------------------------------------------------

// MultiWriteMemoryResponse

// string uri = 1;
inline void MultiWriteMemoryResponse::clear_uri() {
  uri_.ClearToEmpty();
}
inline const std::string& MultiWriteMemoryResponse::uri() const {
  // @@protoc_insertion_point(field_get:MultiWriteMemoryResponse.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MultiWriteMemoryResponse::set_uri(ArgT0&& arg0, ArgT... args) {
 
 uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MultiWriteMemoryResponse.uri)
}
inline std::string* MultiWriteMemoryResponse::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:MultiWriteMemoryResponse.uri)
  return _s;
}
inline const std::string& MultiWriteMemoryResponse::_internal_uri() const {
  return uri_.Get();
}
inline void MultiWriteMemoryResponse::_internal_set_uri(const std::string& value) {
  
  uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MultiWriteMemoryResponse::_internal_mutable_uri() {
  
  return uri_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MultiWriteMemoryResponse::release_uri() {
  // @@protoc_insertion_point(field_release:MultiWriteMemoryResponse.uri)
  return uri_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MultiWriteMemoryResponse::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  uri_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uri,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (uri_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    uri_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MultiWriteMemoryResponse.uri)
}

// repeated .WriteMemoryResponse responses = 2;
inline int MultiWriteMemoryResponse::_internal_responses_size() const {
  return responses_.size();
}
inline int MultiWriteMemoryResponse::responses_size() const {
  return _internal_responses_size();
}
inline void MultiWriteMemoryResponse::clear_responses() {
  responses_.Clear();
}
inline ::WriteMemoryResponse* MultiWriteMemoryResponse::mutable_responses(int index) {
  // @@protoc_insertion_point(field_mutable:MultiWriteMemoryResponse.responses)
  return responses_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::WriteMemoryResponse >*
MultiWriteMemoryResponse::mutable_responses() {
  // @@protoc_insertion_point(field_mutable_list:MultiWriteMemoryResponse.responses)
  return &responses_;
}
inline const ::WriteMemoryResponse& MultiWriteMemoryResponse::_internal_responses(int index) const {
  return responses_.Get(index);
}
inline const ::WriteMemoryResponse& MultiWriteMemoryResponse::responses(int index) const {
  // @@protoc_insertion_point(field_get:MultiWriteMemoryResponse.responses)
  return _internal_responses(index);
}
inline ::WriteMemoryResponse* MultiWriteMemoryResponse::_internal_add_responses() {
  return responses_.Add();
}
inline ::WriteMemoryResponse* MultiWriteMemoryResponse::add_responses() {
  ::WriteMemoryResponse* _add = _internal_add_responses();
  // @@protoc_insertion_point(field_add:MultiWriteMemoryResponse.responses)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::WriteMemoryResponse >&
MultiWriteMemoryResponse::responses() const {
  // @@protoc_insertion_point(field_list:MultiWriteMemoryResponse.responses)
  return responses_;
}

// -------------------------------------------------------------------

// ReadDirectoryRequest

// string uri = 1;
inline void ReadDirectoryRequest::clear_uri() {
  uri_.ClearToEmpty();
}
inline const std::string& ReadDirectoryRequest::uri() const {
  // @@protoc_insertion_point(field_get:ReadDirectoryRequest.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadDirectoryRequest::set_uri(ArgT0&& arg0, ArgT... args) {
 
 uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ReadDirectoryRequest.uri)
}
inline std::string* ReadDirectoryRequest::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:ReadDirectoryRequest.uri)
  return _s;
}
inline const std::string& ReadDirectoryRequest::_internal_uri() const {
  return uri_.Get();
}
inline void ReadDirectoryRequest::_internal_set_uri(const std::string& value) {
  
  uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ReadDirectoryRequest::_internal_mutable_uri() {
  
  return uri_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ReadDirectoryRequest::release_uri() {
  // @@protoc_insertion_point(field_release:ReadDirectoryRequest.uri)
  return uri_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ReadDirectoryRequest::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  uri_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uri,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (uri_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    uri_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ReadDirectoryRequest.uri)
}

// string path = 2;
inline void ReadDirectoryRequest::clear_path() {
  path_.ClearToEmpty();
}
inline const std::string& ReadDirectoryRequest::path() const {
  // @@protoc_insertion_point(field_get:ReadDirectoryRequest.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadDirectoryRequest::set_path(ArgT0&& arg0, ArgT... args) {
 
 path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ReadDirectoryRequest.path)
}
inline std::string* ReadDirectoryRequest::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:ReadDirectoryRequest.path)
  return _s;
}
inline const std::string& ReadDirectoryRequest::_internal_path() const {
  return path_.Get();
}
inline void ReadDirectoryRequest::_internal_set_path(const std::string& value) {
  
  path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ReadDirectoryRequest::_internal_mutable_path() {
  
  return path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ReadDirectoryRequest::release_path() {
  // @@protoc_insertion_point(field_release:ReadDirectoryRequest.path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ReadDirectoryRequest::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (path_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ReadDirectoryRequest.path)
}

// -------------------------------------------------------------------

// DirEntry

// string name = 1;
inline void DirEntry::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& DirEntry::name() const {
  // @@protoc_insertion_point(field_get:DirEntry.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DirEntry::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DirEntry.name)
}
inline std::string* DirEntry::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:DirEntry.name)
  return _s;
}
inline const std::string& DirEntry::_internal_name() const {
  return name_.Get();
}
inline void DirEntry::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DirEntry::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DirEntry::release_name() {
  // @@protoc_insertion_point(field_release:DirEntry.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DirEntry::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DirEntry.name)
}

// .DirEntryType type = 2;
inline void DirEntry::clear_type() {
  type_ = 0;
}
inline ::DirEntryType DirEntry::_internal_type() const {
  return static_cast< ::DirEntryType >(type_);
}
inline ::DirEntryType DirEntry::type() const {
  // @@protoc_insertion_point(field_get:DirEntry.type)
  return _internal_type();
}
inline void DirEntry::_internal_set_type(::DirEntryType value) {
  
  type_ = value;
}
inline void DirEntry::set_type(::DirEntryType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:DirEntry.type)
}

// -------------------------------------------------------------------

// ReadDirectoryResponse

// string uri = 1;
inline void ReadDirectoryResponse::clear_uri() {
  uri_.ClearToEmpty();
}
inline const std::string& ReadDirectoryResponse::uri() const {
  // @@protoc_insertion_point(field_get:ReadDirectoryResponse.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadDirectoryResponse::set_uri(ArgT0&& arg0, ArgT... args) {
 
 uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ReadDirectoryResponse.uri)
}
inline std::string* ReadDirectoryResponse::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:ReadDirectoryResponse.uri)
  return _s;
}
inline const std::string& ReadDirectoryResponse::_internal_uri() const {
  return uri_.Get();
}
inline void ReadDirectoryResponse::_internal_set_uri(const std::string& value) {
  
  uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ReadDirectoryResponse::_internal_mutable_uri() {
  
  return uri_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ReadDirectoryResponse::release_uri() {
  // @@protoc_insertion_point(field_release:ReadDirectoryResponse.uri)
  return uri_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ReadDirectoryResponse::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  uri_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uri,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (uri_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    uri_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ReadDirectoryResponse.uri)
}

// string path = 2;
inline void ReadDirectoryResponse::clear_path() {
  path_.ClearToEmpty();
}
inline const std::string& ReadDirectoryResponse::path() const {
  // @@protoc_insertion_point(field_get:ReadDirectoryResponse.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadDirectoryResponse::set_path(ArgT0&& arg0, ArgT... args) {
 
 path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ReadDirectoryResponse.path)
}
inline std::string* ReadDirectoryResponse::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:ReadDirectoryResponse.path)
  return _s;
}
inline const std::string& ReadDirectoryResponse::_internal_path() const {
  return path_.Get();
}
inline void ReadDirectoryResponse::_internal_set_path(const std::string& value) {
  
  path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ReadDirectoryResponse::_internal_mutable_path() {
  
  return path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ReadDirectoryResponse::release_path() {
  // @@protoc_insertion_point(field_release:ReadDirectoryResponse.path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ReadDirectoryResponse::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (path_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ReadDirectoryResponse.path)
}

// repeated .DirEntry entries = 3;
inline int ReadDirectoryResponse::_internal_entries_size() const {
  return entries_.size();
}
inline int ReadDirectoryResponse::entries_size() const {
  return _internal_entries_size();
}
inline void ReadDirectoryResponse::clear_entries() {
  entries_.Clear();
}
inline ::DirEntry* ReadDirectoryResponse::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:ReadDirectoryResponse.entries)
  return entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DirEntry >*
ReadDirectoryResponse::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:ReadDirectoryResponse.entries)
  return &entries_;
}
inline const ::DirEntry& ReadDirectoryResponse::_internal_entries(int index) const {
  return entries_.Get(index);
}
inline const ::DirEntry& ReadDirectoryResponse::entries(int index) const {
  // @@protoc_insertion_point(field_get:ReadDirectoryResponse.entries)
  return _internal_entries(index);
}
inline ::DirEntry* ReadDirectoryResponse::_internal_add_entries() {
  return entries_.Add();
}
inline ::DirEntry* ReadDirectoryResponse::add_entries() {
  ::DirEntry* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:ReadDirectoryResponse.entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DirEntry >&
ReadDirectoryResponse::entries() const {
  // @@protoc_insertion_point(field_list:ReadDirectoryResponse.entries)
  return entries_;
}

// -------------------------------------------------------------------

// MakeDirectoryRequest

// string uri = 1;
inline void MakeDirectoryRequest::clear_uri() {
  uri_.ClearToEmpty();
}
inline const std::string& MakeDirectoryRequest::uri() const {
  // @@protoc_insertion_point(field_get:MakeDirectoryRequest.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MakeDirectoryRequest::set_uri(ArgT0&& arg0, ArgT... args) {
 
 uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MakeDirectoryRequest.uri)
}
inline std::string* MakeDirectoryRequest::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:MakeDirectoryRequest.uri)
  return _s;
}
inline const std::string& MakeDirectoryRequest::_internal_uri() const {
  return uri_.Get();
}
inline void MakeDirectoryRequest::_internal_set_uri(const std::string& value) {
  
  uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MakeDirectoryRequest::_internal_mutable_uri() {
  
  return uri_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MakeDirectoryRequest::release_uri() {
  // @@protoc_insertion_point(field_release:MakeDirectoryRequest.uri)
  return uri_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MakeDirectoryRequest::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  uri_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uri,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (uri_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    uri_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MakeDirectoryRequest.uri)
}

// string path = 2;
inline void MakeDirectoryRequest::clear_path() {
  path_.ClearToEmpty();
}
inline const std::string& MakeDirectoryRequest::path() const {
  // @@protoc_insertion_point(field_get:MakeDirectoryRequest.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MakeDirectoryRequest::set_path(ArgT0&& arg0, ArgT... args) {
 
 path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MakeDirectoryRequest.path)
}
inline std::string* MakeDirectoryRequest::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:MakeDirectoryRequest.path)
  return _s;
}
inline const std::string& MakeDirectoryRequest::_internal_path() const {
  return path_.Get();
}
inline void MakeDirectoryRequest::_internal_set_path(const std::string& value) {
  
  path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MakeDirectoryRequest::_internal_mutable_path() {
  
  return path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MakeDirectoryRequest::release_path() {
  // @@protoc_insertion_point(field_release:MakeDirectoryRequest.path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MakeDirectoryRequest::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (path_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MakeDirectoryRequest.path)
}

// -------------------------------------------------------------------

// MakeDirectoryResponse

// string uri = 1;
inline void MakeDirectoryResponse::clear_uri() {
  uri_.ClearToEmpty();
}
inline const std::string& MakeDirectoryResponse::uri() const {
  // @@protoc_insertion_point(field_get:MakeDirectoryResponse.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MakeDirectoryResponse::set_uri(ArgT0&& arg0, ArgT... args) {
 
 uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MakeDirectoryResponse.uri)
}
inline std::string* MakeDirectoryResponse::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:MakeDirectoryResponse.uri)
  return _s;
}
inline const std::string& MakeDirectoryResponse::_internal_uri() const {
  return uri_.Get();
}
inline void MakeDirectoryResponse::_internal_set_uri(const std::string& value) {
  
  uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MakeDirectoryResponse::_internal_mutable_uri() {
  
  return uri_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MakeDirectoryResponse::release_uri() {
  // @@protoc_insertion_point(field_release:MakeDirectoryResponse.uri)
  return uri_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MakeDirectoryResponse::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  uri_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uri,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (uri_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    uri_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MakeDirectoryResponse.uri)
}

// string path = 2;
inline void MakeDirectoryResponse::clear_path() {
  path_.ClearToEmpty();
}
inline const std::string& MakeDirectoryResponse::path() const {
  // @@protoc_insertion_point(field_get:MakeDirectoryResponse.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MakeDirectoryResponse::set_path(ArgT0&& arg0, ArgT... args) {
 
 path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MakeDirectoryResponse.path)
}
inline std::string* MakeDirectoryResponse::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:MakeDirectoryResponse.path)
  return _s;
}
inline const std::string& MakeDirectoryResponse::_internal_path() const {
  return path_.Get();
}
inline void MakeDirectoryResponse::_internal_set_path(const std::string& value) {
  
  path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MakeDirectoryResponse::_internal_mutable_path() {
  
  return path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MakeDirectoryResponse::release_path() {
  // @@protoc_insertion_point(field_release:MakeDirectoryResponse.path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MakeDirectoryResponse::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (path_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MakeDirectoryResponse.path)
}

// -------------------------------------------------------------------

// RemoveFileRequest

// string uri = 1;
inline void RemoveFileRequest::clear_uri() {
  uri_.ClearToEmpty();
}
inline const std::string& RemoveFileRequest::uri() const {
  // @@protoc_insertion_point(field_get:RemoveFileRequest.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RemoveFileRequest::set_uri(ArgT0&& arg0, ArgT... args) {
 
 uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RemoveFileRequest.uri)
}
inline std::string* RemoveFileRequest::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:RemoveFileRequest.uri)
  return _s;
}
inline const std::string& RemoveFileRequest::_internal_uri() const {
  return uri_.Get();
}
inline void RemoveFileRequest::_internal_set_uri(const std::string& value) {
  
  uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RemoveFileRequest::_internal_mutable_uri() {
  
  return uri_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RemoveFileRequest::release_uri() {
  // @@protoc_insertion_point(field_release:RemoveFileRequest.uri)
  return uri_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RemoveFileRequest::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  uri_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uri,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (uri_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    uri_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RemoveFileRequest.uri)
}

// string path = 2;
inline void RemoveFileRequest::clear_path() {
  path_.ClearToEmpty();
}
inline const std::string& RemoveFileRequest::path() const {
  // @@protoc_insertion_point(field_get:RemoveFileRequest.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RemoveFileRequest::set_path(ArgT0&& arg0, ArgT... args) {
 
 path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RemoveFileRequest.path)
}
inline std::string* RemoveFileRequest::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:RemoveFileRequest.path)
  return _s;
}
inline const std::string& RemoveFileRequest::_internal_path() const {
  return path_.Get();
}
inline void RemoveFileRequest::_internal_set_path(const std::string& value) {
  
  path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RemoveFileRequest::_internal_mutable_path() {
  
  return path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RemoveFileRequest::release_path() {
  // @@protoc_insertion_point(field_release:RemoveFileRequest.path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RemoveFileRequest::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (path_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RemoveFileRequest.path)
}

// -------------------------------------------------------------------

// RemoveFileResponse

// string uri = 1;
inline void RemoveFileResponse::clear_uri() {
  uri_.ClearToEmpty();
}
inline const std::string& RemoveFileResponse::uri() const {
  // @@protoc_insertion_point(field_get:RemoveFileResponse.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RemoveFileResponse::set_uri(ArgT0&& arg0, ArgT... args) {
 
 uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RemoveFileResponse.uri)
}
inline std::string* RemoveFileResponse::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:RemoveFileResponse.uri)
  return _s;
}
inline const std::string& RemoveFileResponse::_internal_uri() const {
  return uri_.Get();
}
inline void RemoveFileResponse::_internal_set_uri(const std::string& value) {
  
  uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RemoveFileResponse::_internal_mutable_uri() {
  
  return uri_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RemoveFileResponse::release_uri() {
  // @@protoc_insertion_point(field_release:RemoveFileResponse.uri)
  return uri_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RemoveFileResponse::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  uri_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uri,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (uri_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    uri_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RemoveFileResponse.uri)
}

// string path = 2;
inline void RemoveFileResponse::clear_path() {
  path_.ClearToEmpty();
}
inline const std::string& RemoveFileResponse::path() const {
  // @@protoc_insertion_point(field_get:RemoveFileResponse.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RemoveFileResponse::set_path(ArgT0&& arg0, ArgT... args) {
 
 path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RemoveFileResponse.path)
}
inline std::string* RemoveFileResponse::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:RemoveFileResponse.path)
  return _s;
}
inline const std::string& RemoveFileResponse::_internal_path() const {
  return path_.Get();
}
inline void RemoveFileResponse::_internal_set_path(const std::string& value) {
  
  path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RemoveFileResponse::_internal_mutable_path() {
  
  return path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RemoveFileResponse::release_path() {
  // @@protoc_insertion_point(field_release:RemoveFileResponse.path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RemoveFileResponse::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (path_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RemoveFileResponse.path)
}

// -------------------------------------------------------------------

// RenameFileRequest

// string uri = 1;
inline void RenameFileRequest::clear_uri() {
  uri_.ClearToEmpty();
}
inline const std::string& RenameFileRequest::uri() const {
  // @@protoc_insertion_point(field_get:RenameFileRequest.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RenameFileRequest::set_uri(ArgT0&& arg0, ArgT... args) {
 
 uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RenameFileRequest.uri)
}
inline std::string* RenameFileRequest::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:RenameFileRequest.uri)
  return _s;
}
inline const std::string& RenameFileRequest::_internal_uri() const {
  return uri_.Get();
}
inline void RenameFileRequest::_internal_set_uri(const std::string& value) {
  
  uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RenameFileRequest::_internal_mutable_uri() {
  
  return uri_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RenameFileRequest::release_uri() {
  // @@protoc_insertion_point(field_release:RenameFileRequest.uri)
  return uri_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RenameFileRequest::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  uri_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uri,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (uri_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    uri_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RenameFileRequest.uri)
}

// string path = 2;
inline void RenameFileRequest::clear_path() {
  path_.ClearToEmpty();
}
inline const std::string& RenameFileRequest::path() const {
  // @@protoc_insertion_point(field_get:RenameFileRequest.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RenameFileRequest::set_path(ArgT0&& arg0, ArgT... args) {
 
 path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RenameFileRequest.path)
}
inline std::string* RenameFileRequest::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:RenameFileRequest.path)
  return _s;
}
inline const std::string& RenameFileRequest::_internal_path() const {
  return path_.Get();
}
inline void RenameFileRequest::_internal_set_path(const std::string& value) {
  
  path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RenameFileRequest::_internal_mutable_path() {
  
  return path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RenameFileRequest::release_path() {
  // @@protoc_insertion_point(field_release:RenameFileRequest.path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RenameFileRequest::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (path_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RenameFileRequest.path)
}

// string newFilename = 3;
inline void RenameFileRequest::clear_newfilename() {
  newfilename_.ClearToEmpty();
}
inline const std::string& RenameFileRequest::newfilename() const {
  // @@protoc_insertion_point(field_get:RenameFileRequest.newFilename)
  return _internal_newfilename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RenameFileRequest::set_newfilename(ArgT0&& arg0, ArgT... args) {
 
 newfilename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RenameFileRequest.newFilename)
}
inline std::string* RenameFileRequest::mutable_newfilename() {
  std::string* _s = _internal_mutable_newfilename();
  // @@protoc_insertion_point(field_mutable:RenameFileRequest.newFilename)
  return _s;
}
inline const std::string& RenameFileRequest::_internal_newfilename() const {
  return newfilename_.Get();
}
inline void RenameFileRequest::_internal_set_newfilename(const std::string& value) {
  
  newfilename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RenameFileRequest::_internal_mutable_newfilename() {
  
  return newfilename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RenameFileRequest::release_newfilename() {
  // @@protoc_insertion_point(field_release:RenameFileRequest.newFilename)
  return newfilename_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RenameFileRequest::set_allocated_newfilename(std::string* newfilename) {
  if (newfilename != nullptr) {
    
  } else {
    
  }
  newfilename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), newfilename,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (newfilename_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    newfilename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RenameFileRequest.newFilename)
}

// -------------------------------------------------------------------

// RenameFileResponse

// string uri = 1;
inline void RenameFileResponse::clear_uri() {
  uri_.ClearToEmpty();
}
inline const std::string& RenameFileResponse::uri() const {
  // @@protoc_insertion_point(field_get:RenameFileResponse.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RenameFileResponse::set_uri(ArgT0&& arg0, ArgT... args) {
 
 uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RenameFileResponse.uri)
}
inline std::string* RenameFileResponse::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:RenameFileResponse.uri)
  return _s;
}
inline const std::string& RenameFileResponse::_internal_uri() const {
  return uri_.Get();
}
inline void RenameFileResponse::_internal_set_uri(const std::string& value) {
  
  uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RenameFileResponse::_internal_mutable_uri() {
  
  return uri_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RenameFileResponse::release_uri() {
  // @@protoc_insertion_point(field_release:RenameFileResponse.uri)
  return uri_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RenameFileResponse::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  uri_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uri,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (uri_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    uri_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RenameFileResponse.uri)
}

// string path = 2;
inline void RenameFileResponse::clear_path() {
  path_.ClearToEmpty();
}
inline const std::string& RenameFileResponse::path() const {
  // @@protoc_insertion_point(field_get:RenameFileResponse.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RenameFileResponse::set_path(ArgT0&& arg0, ArgT... args) {
 
 path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RenameFileResponse.path)
}
inline std::string* RenameFileResponse::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:RenameFileResponse.path)
  return _s;
}
inline const std::string& RenameFileResponse::_internal_path() const {
  return path_.Get();
}
inline void RenameFileResponse::_internal_set_path(const std::string& value) {
  
  path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RenameFileResponse::_internal_mutable_path() {
  
  return path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RenameFileResponse::release_path() {
  // @@protoc_insertion_point(field_release:RenameFileResponse.path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RenameFileResponse::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (path_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RenameFileResponse.path)
}

// string newFilename = 3;
inline void RenameFileResponse::clear_newfilename() {
  newfilename_.ClearToEmpty();
}
inline const std::string& RenameFileResponse::newfilename() const {
  // @@protoc_insertion_point(field_get:RenameFileResponse.newFilename)
  return _internal_newfilename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RenameFileResponse::set_newfilename(ArgT0&& arg0, ArgT... args) {
 
 newfilename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RenameFileResponse.newFilename)
}
inline std::string* RenameFileResponse::mutable_newfilename() {
  std::string* _s = _internal_mutable_newfilename();
  // @@protoc_insertion_point(field_mutable:RenameFileResponse.newFilename)
  return _s;
}
inline const std::string& RenameFileResponse::_internal_newfilename() const {
  return newfilename_.Get();
}
inline void RenameFileResponse::_internal_set_newfilename(const std::string& value) {
  
  newfilename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RenameFileResponse::_internal_mutable_newfilename() {
  
  return newfilename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RenameFileResponse::release_newfilename() {
  // @@protoc_insertion_point(field_release:RenameFileResponse.newFilename)
  return newfilename_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RenameFileResponse::set_allocated_newfilename(std::string* newfilename) {
  if (newfilename != nullptr) {
    
  } else {
    
  }
  newfilename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), newfilename,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (newfilename_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    newfilename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RenameFileResponse.newFilename)
}

// -------------------------------------------------------------------

// PutFileRequest

// string uri = 1;
inline void PutFileRequest::clear_uri() {
  uri_.ClearToEmpty();
}
inline const std::string& PutFileRequest::uri() const {
  // @@protoc_insertion_point(field_get:PutFileRequest.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PutFileRequest::set_uri(ArgT0&& arg0, ArgT... args) {
 
 uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PutFileRequest.uri)
}
inline std::string* PutFileRequest::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:PutFileRequest.uri)
  return _s;
}
inline const std::string& PutFileRequest::_internal_uri() const {
  return uri_.Get();
}
inline void PutFileRequest::_internal_set_uri(const std::string& value) {
  
  uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PutFileRequest::_internal_mutable_uri() {
  
  return uri_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PutFileRequest::release_uri() {
  // @@protoc_insertion_point(field_release:PutFileRequest.uri)
  return uri_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PutFileRequest::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  uri_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uri,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (uri_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    uri_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PutFileRequest.uri)
}

// string path = 2;
inline void PutFileRequest::clear_path() {
  path_.ClearToEmpty();
}
inline const std::string& PutFileRequest::path() const {
  // @@protoc_insertion_point(field_get:PutFileRequest.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PutFileRequest::set_path(ArgT0&& arg0, ArgT... args) {
 
 path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PutFileRequest.path)
}
inline std::string* PutFileRequest::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:PutFileRequest.path)
  return _s;
}
inline const std::string& PutFileRequest::_internal_path() const {
  return path_.Get();
}
inline void PutFileRequest::_internal_set_path(const std::string& value) {
  
  path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PutFileRequest::_internal_mutable_path() {
  
  return path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PutFileRequest::release_path() {
  // @@protoc_insertion_point(field_release:PutFileRequest.path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PutFileRequest::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (path_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PutFileRequest.path)
}

// bytes data = 3;
inline void PutFileRequest::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& PutFileRequest::data() const {
  // @@protoc_insertion_point(field_get:PutFileRequest.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PutFileRequest::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PutFileRequest.data)
}
inline std::string* PutFileRequest::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:PutFileRequest.data)
  return _s;
}
inline const std::string& PutFileRequest::_internal_data() const {
  return data_.Get();
}
inline void PutFileRequest::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PutFileRequest::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PutFileRequest::release_data() {
  // @@protoc_insertion_point(field_release:PutFileRequest.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PutFileRequest::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PutFileRequest.data)
}

// -------------------------------------------------------------------

// PutFileResponse

// string uri = 1;
inline void PutFileResponse::clear_uri() {
  uri_.ClearToEmpty();
}
inline const std::string& PutFileResponse::uri() const {
  // @@protoc_insertion_point(field_get:PutFileResponse.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PutFileResponse::set_uri(ArgT0&& arg0, ArgT... args) {
 
 uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PutFileResponse.uri)
}
inline std::string* PutFileResponse::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:PutFileResponse.uri)
  return _s;
}
inline const std::string& PutFileResponse::_internal_uri() const {
  return uri_.Get();
}
inline void PutFileResponse::_internal_set_uri(const std::string& value) {
  
  uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PutFileResponse::_internal_mutable_uri() {
  
  return uri_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PutFileResponse::release_uri() {
  // @@protoc_insertion_point(field_release:PutFileResponse.uri)
  return uri_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PutFileResponse::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  uri_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uri,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (uri_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    uri_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PutFileResponse.uri)
}

// string path = 2;
inline void PutFileResponse::clear_path() {
  path_.ClearToEmpty();
}
inline const std::string& PutFileResponse::path() const {
  // @@protoc_insertion_point(field_get:PutFileResponse.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PutFileResponse::set_path(ArgT0&& arg0, ArgT... args) {
 
 path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PutFileResponse.path)
}
inline std::string* PutFileResponse::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:PutFileResponse.path)
  return _s;
}
inline const std::string& PutFileResponse::_internal_path() const {
  return path_.Get();
}
inline void PutFileResponse::_internal_set_path(const std::string& value) {
  
  path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PutFileResponse::_internal_mutable_path() {
  
  return path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PutFileResponse::release_path() {
  // @@protoc_insertion_point(field_release:PutFileResponse.path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PutFileResponse::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (path_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PutFileResponse.path)
}

// uint32 size = 3;
inline void PutFileResponse::clear_size() {
  size_ = 0u;
}
inline uint32_t PutFileResponse::_internal_size() const {
  return size_;
}
inline uint32_t PutFileResponse::size() const {
  // @@protoc_insertion_point(field_get:PutFileResponse.size)
  return _internal_size();
}
inline void PutFileResponse::_internal_set_size(uint32_t value) {
  
  size_ = value;
}
inline void PutFileResponse::set_size(uint32_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:PutFileResponse.size)
}

// -------------------------------------------------------------------

// GetFileRequest

// string uri = 1;
inline void GetFileRequest::clear_uri() {
  uri_.ClearToEmpty();
}
inline const std::string& GetFileRequest::uri() const {
  // @@protoc_insertion_point(field_get:GetFileRequest.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetFileRequest::set_uri(ArgT0&& arg0, ArgT... args) {
 
 uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetFileRequest.uri)
}
inline std::string* GetFileRequest::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:GetFileRequest.uri)
  return _s;
}
inline const std::string& GetFileRequest::_internal_uri() const {
  return uri_.Get();
}
inline void GetFileRequest::_internal_set_uri(const std::string& value) {
  
  uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetFileRequest::_internal_mutable_uri() {
  
  return uri_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetFileRequest::release_uri() {
  // @@protoc_insertion_point(field_release:GetFileRequest.uri)
  return uri_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetFileRequest::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  uri_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uri,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (uri_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    uri_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetFileRequest.uri)
}

// string path = 2;
inline void GetFileRequest::clear_path() {
  path_.ClearToEmpty();
}
inline const std::string& GetFileRequest::path() const {
  // @@protoc_insertion_point(field_get:GetFileRequest.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetFileRequest::set_path(ArgT0&& arg0, ArgT... args) {
 
 path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetFileRequest.path)
}
inline std::string* GetFileRequest::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:GetFileRequest.path)
  return _s;
}
inline const std::string& GetFileRequest::_internal_path() const {
  return path_.Get();
}
inline void GetFileRequest::_internal_set_path(const std::string& value) {
  
  path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetFileRequest::_internal_mutable_path() {
  
  return path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetFileRequest::release_path() {
  // @@protoc_insertion_point(field_release:GetFileRequest.path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetFileRequest::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (path_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetFileRequest.path)
}

// -------------------------------------------------------------------

// GetFileResponse

// string uri = 1;
inline void GetFileResponse::clear_uri() {
  uri_.ClearToEmpty();
}
inline const std::string& GetFileResponse::uri() const {
  // @@protoc_insertion_point(field_get:GetFileResponse.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetFileResponse::set_uri(ArgT0&& arg0, ArgT... args) {
 
 uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetFileResponse.uri)
}
inline std::string* GetFileResponse::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:GetFileResponse.uri)
  return _s;
}
inline const std::string& GetFileResponse::_internal_uri() const {
  return uri_.Get();
}
inline void GetFileResponse::_internal_set_uri(const std::string& value) {
  
  uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetFileResponse::_internal_mutable_uri() {
  
  return uri_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetFileResponse::release_uri() {
  // @@protoc_insertion_point(field_release:GetFileResponse.uri)
  return uri_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetFileResponse::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  uri_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uri,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (uri_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    uri_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetFileResponse.uri)
}

// string path = 2;
inline void GetFileResponse::clear_path() {
  path_.ClearToEmpty();
}
inline const std::string& GetFileResponse::path() const {
  // @@protoc_insertion_point(field_get:GetFileResponse.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetFileResponse::set_path(ArgT0&& arg0, ArgT... args) {
 
 path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetFileResponse.path)
}
inline std::string* GetFileResponse::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:GetFileResponse.path)
  return _s;
}
inline const std::string& GetFileResponse::_internal_path() const {
  return path_.Get();
}
inline void GetFileResponse::_internal_set_path(const std::string& value) {
  
  path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetFileResponse::_internal_mutable_path() {
  
  return path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetFileResponse::release_path() {
  // @@protoc_insertion_point(field_release:GetFileResponse.path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetFileResponse::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (path_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetFileResponse.path)
}

// uint32 size = 3;
inline void GetFileResponse::clear_size() {
  size_ = 0u;
}
inline uint32_t GetFileResponse::_internal_size() const {
  return size_;
}
inline uint32_t GetFileResponse::size() const {
  // @@protoc_insertion_point(field_get:GetFileResponse.size)
  return _internal_size();
}
inline void GetFileResponse::_internal_set_size(uint32_t value) {
  
  size_ = value;
}
inline void GetFileResponse::set_size(uint32_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:GetFileResponse.size)
}

// bytes data = 4;
inline void GetFileResponse::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& GetFileResponse::data() const {
  // @@protoc_insertion_point(field_get:GetFileResponse.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetFileResponse::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetFileResponse.data)
}
inline std::string* GetFileResponse::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:GetFileResponse.data)
  return _s;
}
inline const std::string& GetFileResponse::_internal_data() const {
  return data_.Get();
}
inline void GetFileResponse::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetFileResponse::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetFileResponse::release_data() {
  // @@protoc_insertion_point(field_release:GetFileResponse.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetFileResponse::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetFileResponse.data)
}

// -------------------------------------------------------------------

// BootFileRequest

// string uri = 1;
inline void BootFileRequest::clear_uri() {
  uri_.ClearToEmpty();
}
inline const std::string& BootFileRequest::uri() const {
  // @@protoc_insertion_point(field_get:BootFileRequest.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BootFileRequest::set_uri(ArgT0&& arg0, ArgT... args) {
 
 uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:BootFileRequest.uri)
}
inline std::string* BootFileRequest::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:BootFileRequest.uri)
  return _s;
}
inline const std::string& BootFileRequest::_internal_uri() const {
  return uri_.Get();
}
inline void BootFileRequest::_internal_set_uri(const std::string& value) {
  
  uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BootFileRequest::_internal_mutable_uri() {
  
  return uri_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BootFileRequest::release_uri() {
  // @@protoc_insertion_point(field_release:BootFileRequest.uri)
  return uri_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BootFileRequest::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  uri_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uri,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (uri_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    uri_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:BootFileRequest.uri)
}

// string path = 2;
inline void BootFileRequest::clear_path() {
  path_.ClearToEmpty();
}
inline const std::string& BootFileRequest::path() const {
  // @@protoc_insertion_point(field_get:BootFileRequest.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BootFileRequest::set_path(ArgT0&& arg0, ArgT... args) {
 
 path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:BootFileRequest.path)
}
inline std::string* BootFileRequest::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:BootFileRequest.path)
  return _s;
}
inline const std::string& BootFileRequest::_internal_path() const {
  return path_.Get();
}
inline void BootFileRequest::_internal_set_path(const std::string& value) {
  
  path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BootFileRequest::_internal_mutable_path() {
  
  return path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BootFileRequest::release_path() {
  // @@protoc_insertion_point(field_release:BootFileRequest.path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BootFileRequest::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (path_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:BootFileRequest.path)
}

// -------------------------------------------------------------------

// BootFileResponse

// string uri = 1;
inline void BootFileResponse::clear_uri() {
  uri_.ClearToEmpty();
}
inline const std::string& BootFileResponse::uri() const {
  // @@protoc_insertion_point(field_get:BootFileResponse.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BootFileResponse::set_uri(ArgT0&& arg0, ArgT... args) {
 
 uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:BootFileResponse.uri)
}
inline std::string* BootFileResponse::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:BootFileResponse.uri)
  return _s;
}
inline const std::string& BootFileResponse::_internal_uri() const {
  return uri_.Get();
}
inline void BootFileResponse::_internal_set_uri(const std::string& value) {
  
  uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BootFileResponse::_internal_mutable_uri() {
  
  return uri_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BootFileResponse::release_uri() {
  // @@protoc_insertion_point(field_release:BootFileResponse.uri)
  return uri_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BootFileResponse::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  uri_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uri,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (uri_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    uri_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:BootFileResponse.uri)
}

// string path = 2;
inline void BootFileResponse::clear_path() {
  path_.ClearToEmpty();
}
inline const std::string& BootFileResponse::path() const {
  // @@protoc_insertion_point(field_get:BootFileResponse.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BootFileResponse::set_path(ArgT0&& arg0, ArgT... args) {
 
 path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:BootFileResponse.path)
}
inline std::string* BootFileResponse::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:BootFileResponse.path)
  return _s;
}
inline const std::string& BootFileResponse::_internal_path() const {
  return path_.Get();
}
inline void BootFileResponse::_internal_set_path(const std::string& value) {
  
  path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BootFileResponse::_internal_mutable_path() {
  
  return path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BootFileResponse::release_path() {
  // @@protoc_insertion_point(field_release:BootFileResponse.path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BootFileResponse::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (path_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:BootFileResponse.path)
}

// -------------------------------------------------------------------

// FieldsRequest

// string uri = 1;
inline void FieldsRequest::clear_uri() {
  uri_.ClearToEmpty();
}
inline const std::string& FieldsRequest::uri() const {
  // @@protoc_insertion_point(field_get:FieldsRequest.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FieldsRequest::set_uri(ArgT0&& arg0, ArgT... args) {
 
 uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FieldsRequest.uri)
}
inline std::string* FieldsRequest::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:FieldsRequest.uri)
  return _s;
}
inline const std::string& FieldsRequest::_internal_uri() const {
  return uri_.Get();
}
inline void FieldsRequest::_internal_set_uri(const std::string& value) {
  
  uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FieldsRequest::_internal_mutable_uri() {
  
  return uri_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FieldsRequest::release_uri() {
  // @@protoc_insertion_point(field_release:FieldsRequest.uri)
  return uri_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FieldsRequest::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  uri_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uri,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (uri_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    uri_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:FieldsRequest.uri)
}

// repeated .Field fields = 2;
inline int FieldsRequest::_internal_fields_size() const {
  return fields_.size();
}
inline int FieldsRequest::fields_size() const {
  return _internal_fields_size();
}
inline void FieldsRequest::clear_fields() {
  fields_.Clear();
}
inline ::Field FieldsRequest::_internal_fields(int index) const {
  return static_cast< ::Field >(fields_.Get(index));
}
inline ::Field FieldsRequest::fields(int index) const {
  // @@protoc_insertion_point(field_get:FieldsRequest.fields)
  return _internal_fields(index);
}
inline void FieldsRequest::set_fields(int index, ::Field value) {
  fields_.Set(index, value);
  // @@protoc_insertion_point(field_set:FieldsRequest.fields)
}
inline void FieldsRequest::_internal_add_fields(::Field value) {
  fields_.Add(value);
}
inline void FieldsRequest::add_fields(::Field value) {
  _internal_add_fields(value);
  // @@protoc_insertion_point(field_add:FieldsRequest.fields)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
FieldsRequest::fields() const {
  // @@protoc_insertion_point(field_list:FieldsRequest.fields)
  return fields_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
FieldsRequest::_internal_mutable_fields() {
  return &fields_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
FieldsRequest::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:FieldsRequest.fields)
  return _internal_mutable_fields();
}

// -------------------------------------------------------------------

// FieldsResponse

// string uri = 1;
inline void FieldsResponse::clear_uri() {
  uri_.ClearToEmpty();
}
inline const std::string& FieldsResponse::uri() const {
  // @@protoc_insertion_point(field_get:FieldsResponse.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FieldsResponse::set_uri(ArgT0&& arg0, ArgT... args) {
 
 uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FieldsResponse.uri)
}
inline std::string* FieldsResponse::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:FieldsResponse.uri)
  return _s;
}
inline const std::string& FieldsResponse::_internal_uri() const {
  return uri_.Get();
}
inline void FieldsResponse::_internal_set_uri(const std::string& value) {
  
  uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FieldsResponse::_internal_mutable_uri() {
  
  return uri_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FieldsResponse::release_uri() {
  // @@protoc_insertion_point(field_release:FieldsResponse.uri)
  return uri_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FieldsResponse::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  uri_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uri,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (uri_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    uri_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:FieldsResponse.uri)
}

// repeated .Field fields = 2;
inline int FieldsResponse::_internal_fields_size() const {
  return fields_.size();
}
inline int FieldsResponse::fields_size() const {
  return _internal_fields_size();
}
inline void FieldsResponse::clear_fields() {
  fields_.Clear();
}
inline ::Field FieldsResponse::_internal_fields(int index) const {
  return static_cast< ::Field >(fields_.Get(index));
}
inline ::Field FieldsResponse::fields(int index) const {
  // @@protoc_insertion_point(field_get:FieldsResponse.fields)
  return _internal_fields(index);
}
inline void FieldsResponse::set_fields(int index, ::Field value) {
  fields_.Set(index, value);
  // @@protoc_insertion_point(field_set:FieldsResponse.fields)
}
inline void FieldsResponse::_internal_add_fields(::Field value) {
  fields_.Add(value);
}
inline void FieldsResponse::add_fields(::Field value) {
  _internal_add_fields(value);
  // @@protoc_insertion_point(field_add:FieldsResponse.fields)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
FieldsResponse::fields() const {
  // @@protoc_insertion_point(field_list:FieldsResponse.fields)
  return fields_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
FieldsResponse::_internal_mutable_fields() {
  return &fields_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
FieldsResponse::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:FieldsResponse.fields)
  return _internal_mutable_fields();
}

// repeated string values = 3;
inline int FieldsResponse::_internal_values_size() const {
  return values_.size();
}
inline int FieldsResponse::values_size() const {
  return _internal_values_size();
}
inline void FieldsResponse::clear_values() {
  values_.Clear();
}
inline std::string* FieldsResponse::add_values() {
  std::string* _s = _internal_add_values();
  // @@protoc_insertion_point(field_add_mutable:FieldsResponse.values)
  return _s;
}
inline const std::string& FieldsResponse::_internal_values(int index) const {
  return values_.Get(index);
}
inline const std::string& FieldsResponse::values(int index) const {
  // @@protoc_insertion_point(field_get:FieldsResponse.values)
  return _internal_values(index);
}
inline std::string* FieldsResponse::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:FieldsResponse.values)
  return values_.Mutable(index);
}
inline void FieldsResponse::set_values(int index, const std::string& value) {
  values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:FieldsResponse.values)
}
inline void FieldsResponse::set_values(int index, std::string&& value) {
  values_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:FieldsResponse.values)
}
inline void FieldsResponse::set_values(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:FieldsResponse.values)
}
inline void FieldsResponse::set_values(int index, const char* value, size_t size) {
  values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:FieldsResponse.values)
}
inline std::string* FieldsResponse::_internal_add_values() {
  return values_.Add();
}
inline void FieldsResponse::add_values(const std::string& value) {
  values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:FieldsResponse.values)
}
inline void FieldsResponse::add_values(std::string&& value) {
  values_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:FieldsResponse.values)
}
inline void FieldsResponse::add_values(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:FieldsResponse.values)
}
inline void FieldsResponse::add_values(const char* value, size_t size) {
  values_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:FieldsResponse.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FieldsResponse::values() const {
  // @@protoc_insertion_point(field_list:FieldsResponse.values)
  return values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
FieldsResponse::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:FieldsResponse.values)
  return &values_;
}

// -------------------------------------------------------------------

// NWACommandRequest

// string uri = 1;
inline void NWACommandRequest::clear_uri() {
  uri_.ClearToEmpty();
}
inline const std::string& NWACommandRequest::uri() const {
  // @@protoc_insertion_point(field_get:NWACommandRequest.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NWACommandRequest::set_uri(ArgT0&& arg0, ArgT... args) {
 
 uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NWACommandRequest.uri)
}
inline std::string* NWACommandRequest::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:NWACommandRequest.uri)
  return _s;
}
inline const std::string& NWACommandRequest::_internal_uri() const {
  return uri_.Get();
}
inline void NWACommandRequest::_internal_set_uri(const std::string& value) {
  
  uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NWACommandRequest::_internal_mutable_uri() {
  
  return uri_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NWACommandRequest::release_uri() {
  // @@protoc_insertion_point(field_release:NWACommandRequest.uri)
  return uri_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NWACommandRequest::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  uri_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uri,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (uri_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    uri_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NWACommandRequest.uri)
}

// string command = 2;
inline void NWACommandRequest::clear_command() {
  command_.ClearToEmpty();
}
inline const std::string& NWACommandRequest::command() const {
  // @@protoc_insertion_point(field_get:NWACommandRequest.command)
  return _internal_command();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NWACommandRequest::set_command(ArgT0&& arg0, ArgT... args) {
 
 command_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NWACommandRequest.command)
}
inline std::string* NWACommandRequest::mutable_command() {
  std::string* _s = _internal_mutable_command();
  // @@protoc_insertion_point(field_mutable:NWACommandRequest.command)
  return _s;
}
inline const std::string& NWACommandRequest::_internal_command() const {
  return command_.Get();
}
inline void NWACommandRequest::_internal_set_command(const std::string& value) {
  
  command_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NWACommandRequest::_internal_mutable_command() {
  
  return command_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NWACommandRequest::release_command() {
  // @@protoc_insertion_point(field_release:NWACommandRequest.command)
  return command_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NWACommandRequest::set_allocated_command(std::string* command) {
  if (command != nullptr) {
    
  } else {
    
  }
  command_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), command,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (command_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    command_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NWACommandRequest.command)
}

// string args = 3;
inline void NWACommandRequest::clear_args() {
  args_.ClearToEmpty();
}
inline const std::string& NWACommandRequest::args() const {
  // @@protoc_insertion_point(field_get:NWACommandRequest.args)
  return _internal_args();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NWACommandRequest::set_args(ArgT0&& arg0, ArgT... args) {
 
 args_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NWACommandRequest.args)
}
inline std::string* NWACommandRequest::mutable_args() {
  std::string* _s = _internal_mutable_args();
  // @@protoc_insertion_point(field_mutable:NWACommandRequest.args)
  return _s;
}
inline const std::string& NWACommandRequest::_internal_args() const {
  return args_.Get();
}
inline void NWACommandRequest::_internal_set_args(const std::string& value) {
  
  args_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NWACommandRequest::_internal_mutable_args() {
  
  return args_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NWACommandRequest::release_args() {
  // @@protoc_insertion_point(field_release:NWACommandRequest.args)
  return args_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NWACommandRequest::set_allocated_args(std::string* args) {
  if (args != nullptr) {
    
  } else {
    
  }
  args_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), args,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (args_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    args_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NWACommandRequest.args)
}

// optional bytes binaryArg = 4;
inline bool NWACommandRequest::_internal_has_binaryarg() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NWACommandRequest::has_binaryarg() const {
  return _internal_has_binaryarg();
}
inline void NWACommandRequest::clear_binaryarg() {
  binaryarg_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NWACommandRequest::binaryarg() const {
  // @@protoc_insertion_point(field_get:NWACommandRequest.binaryArg)
  return _internal_binaryarg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NWACommandRequest::set_binaryarg(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 binaryarg_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NWACommandRequest.binaryArg)
}
inline std::string* NWACommandRequest::mutable_binaryarg() {
  std::string* _s = _internal_mutable_binaryarg();
  // @@protoc_insertion_point(field_mutable:NWACommandRequest.binaryArg)
  return _s;
}
inline const std::string& NWACommandRequest::_internal_binaryarg() const {
  return binaryarg_.Get();
}
inline void NWACommandRequest::_internal_set_binaryarg(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  binaryarg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NWACommandRequest::_internal_mutable_binaryarg() {
  _has_bits_[0] |= 0x00000001u;
  return binaryarg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NWACommandRequest::release_binaryarg() {
  // @@protoc_insertion_point(field_release:NWACommandRequest.binaryArg)
  if (!_internal_has_binaryarg()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = binaryarg_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (binaryarg_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    binaryarg_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NWACommandRequest::set_allocated_binaryarg(std::string* binaryarg) {
  if (binaryarg != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  binaryarg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), binaryarg,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (binaryarg_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    binaryarg_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NWACommandRequest.binaryArg)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// NWACommandResponse_NWAASCIIItem

// map<string, string> item = 1;
inline int NWACommandResponse_NWAASCIIItem::_internal_item_size() const {
  return item_.size();
}
inline int NWACommandResponse_NWAASCIIItem::item_size() const {
  return _internal_item_size();
}
inline void NWACommandResponse_NWAASCIIItem::clear_item() {
  item_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
NWACommandResponse_NWAASCIIItem::_internal_item() const {
  return item_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
NWACommandResponse_NWAASCIIItem::item() const {
  // @@protoc_insertion_point(field_map:NWACommandResponse.NWAASCIIItem.item)
  return _internal_item();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
NWACommandResponse_NWAASCIIItem::_internal_mutable_item() {
  return item_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
NWACommandResponse_NWAASCIIItem::mutable_item() {
  // @@protoc_insertion_point(field_mutable_map:NWACommandResponse.NWAASCIIItem.item)
  return _internal_mutable_item();
}

// -------------------------------------------------------------------

// NWACommandResponse

// string uri = 1;
inline void NWACommandResponse::clear_uri() {
  uri_.ClearToEmpty();
}
inline const std::string& NWACommandResponse::uri() const {
  // @@protoc_insertion_point(field_get:NWACommandResponse.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NWACommandResponse::set_uri(ArgT0&& arg0, ArgT... args) {
 
 uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NWACommandResponse.uri)
}
inline std::string* NWACommandResponse::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:NWACommandResponse.uri)
  return _s;
}
inline const std::string& NWACommandResponse::_internal_uri() const {
  return uri_.Get();
}
inline void NWACommandResponse::_internal_set_uri(const std::string& value) {
  
  uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NWACommandResponse::_internal_mutable_uri() {
  
  return uri_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NWACommandResponse::release_uri() {
  // @@protoc_insertion_point(field_release:NWACommandResponse.uri)
  return uri_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NWACommandResponse::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  uri_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uri,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (uri_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    uri_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NWACommandResponse.uri)
}

// repeated .NWACommandResponse.NWAASCIIItem asciiReply = 2;
inline int NWACommandResponse::_internal_asciireply_size() const {
  return asciireply_.size();
}
inline int NWACommandResponse::asciireply_size() const {
  return _internal_asciireply_size();
}
inline void NWACommandResponse::clear_asciireply() {
  asciireply_.Clear();
}
inline ::NWACommandResponse_NWAASCIIItem* NWACommandResponse::mutable_asciireply(int index) {
  // @@protoc_insertion_point(field_mutable:NWACommandResponse.asciiReply)
  return asciireply_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NWACommandResponse_NWAASCIIItem >*
NWACommandResponse::mutable_asciireply() {
  // @@protoc_insertion_point(field_mutable_list:NWACommandResponse.asciiReply)
  return &asciireply_;
}
inline const ::NWACommandResponse_NWAASCIIItem& NWACommandResponse::_internal_asciireply(int index) const {
  return asciireply_.Get(index);
}
inline const ::NWACommandResponse_NWAASCIIItem& NWACommandResponse::asciireply(int index) const {
  // @@protoc_insertion_point(field_get:NWACommandResponse.asciiReply)
  return _internal_asciireply(index);
}
inline ::NWACommandResponse_NWAASCIIItem* NWACommandResponse::_internal_add_asciireply() {
  return asciireply_.Add();
}
inline ::NWACommandResponse_NWAASCIIItem* NWACommandResponse::add_asciireply() {
  ::NWACommandResponse_NWAASCIIItem* _add = _internal_add_asciireply();
  // @@protoc_insertion_point(field_add:NWACommandResponse.asciiReply)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NWACommandResponse_NWAASCIIItem >&
NWACommandResponse::asciireply() const {
  // @@protoc_insertion_point(field_list:NWACommandResponse.asciiReply)
  return asciireply_;
}

// optional bytes binaryReplay = 3;
inline bool NWACommandResponse::_internal_has_binaryreplay() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NWACommandResponse::has_binaryreplay() const {
  return _internal_has_binaryreplay();
}
inline void NWACommandResponse::clear_binaryreplay() {
  binaryreplay_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NWACommandResponse::binaryreplay() const {
  // @@protoc_insertion_point(field_get:NWACommandResponse.binaryReplay)
  return _internal_binaryreplay();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NWACommandResponse::set_binaryreplay(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 binaryreplay_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NWACommandResponse.binaryReplay)
}
inline std::string* NWACommandResponse::mutable_binaryreplay() {
  std::string* _s = _internal_mutable_binaryreplay();
  // @@protoc_insertion_point(field_mutable:NWACommandResponse.binaryReplay)
  return _s;
}
inline const std::string& NWACommandResponse::_internal_binaryreplay() const {
  return binaryreplay_.Get();
}
inline void NWACommandResponse::_internal_set_binaryreplay(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  binaryreplay_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NWACommandResponse::_internal_mutable_binaryreplay() {
  _has_bits_[0] |= 0x00000001u;
  return binaryreplay_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NWACommandResponse::release_binaryreplay() {
  // @@protoc_insertion_point(field_release:NWACommandResponse.binaryReplay)
  if (!_internal_has_binaryreplay()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = binaryreplay_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (binaryreplay_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    binaryreplay_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NWACommandResponse::set_allocated_binaryreplay(std::string* binaryreplay) {
  if (binaryreplay != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  binaryreplay_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), binaryreplay,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (binaryreplay_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    binaryreplay_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NWACommandResponse.binaryReplay)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::AddressSpace> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::AddressSpace>() {
  return ::AddressSpace_descriptor();
}
template <> struct is_proto_enum< ::MemoryMapping> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MemoryMapping>() {
  return ::MemoryMapping_descriptor();
}
template <> struct is_proto_enum< ::DeviceCapability> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DeviceCapability>() {
  return ::DeviceCapability_descriptor();
}
template <> struct is_proto_enum< ::Field> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Field>() {
  return ::Field_descriptor();
}
template <> struct is_proto_enum< ::DirEntryType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DirEntryType>() {
  return ::DirEntryType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_sni_2eproto
