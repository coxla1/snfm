// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: sni.proto
#ifndef GRPC_sni_2eproto__INCLUDED
#define GRPC_sni_2eproto__INCLUDED

#include "sni.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

// ////////////////////////////////////////////////////////////////////////////////////////////////
// services
// ////////////////////////////////////////////////////////////////////////////////////////////////
//
class Devices final {
 public:
  static constexpr char const* service_full_name() {
    return "Devices";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // detect and list devices currently connected to the system:
    virtual ::grpc::Status ListDevices(::grpc::ClientContext* context, const ::DevicesRequest& request, ::DevicesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::DevicesResponse>> AsyncListDevices(::grpc::ClientContext* context, const ::DevicesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::DevicesResponse>>(AsyncListDevicesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::DevicesResponse>> PrepareAsyncListDevices(::grpc::ClientContext* context, const ::DevicesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::DevicesResponse>>(PrepareAsyncListDevicesRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // detect and list devices currently connected to the system:
      virtual void ListDevices(::grpc::ClientContext* context, const ::DevicesRequest* request, ::DevicesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListDevices(::grpc::ClientContext* context, const ::DevicesRequest* request, ::DevicesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::DevicesResponse>* AsyncListDevicesRaw(::grpc::ClientContext* context, const ::DevicesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::DevicesResponse>* PrepareAsyncListDevicesRaw(::grpc::ClientContext* context, const ::DevicesRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status ListDevices(::grpc::ClientContext* context, const ::DevicesRequest& request, ::DevicesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::DevicesResponse>> AsyncListDevices(::grpc::ClientContext* context, const ::DevicesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::DevicesResponse>>(AsyncListDevicesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::DevicesResponse>> PrepareAsyncListDevices(::grpc::ClientContext* context, const ::DevicesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::DevicesResponse>>(PrepareAsyncListDevicesRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void ListDevices(::grpc::ClientContext* context, const ::DevicesRequest* request, ::DevicesResponse* response, std::function<void(::grpc::Status)>) override;
      void ListDevices(::grpc::ClientContext* context, const ::DevicesRequest* request, ::DevicesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::DevicesResponse>* AsyncListDevicesRaw(::grpc::ClientContext* context, const ::DevicesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::DevicesResponse>* PrepareAsyncListDevicesRaw(::grpc::ClientContext* context, const ::DevicesRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_ListDevices_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // detect and list devices currently connected to the system:
    virtual ::grpc::Status ListDevices(::grpc::ServerContext* context, const ::DevicesRequest* request, ::DevicesResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_ListDevices : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListDevices() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_ListDevices() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDevices(::grpc::ServerContext* /*context*/, const ::DevicesRequest* /*request*/, ::DevicesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListDevices(::grpc::ServerContext* context, ::DevicesRequest* request, ::grpc::ServerAsyncResponseWriter< ::DevicesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_ListDevices<Service > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_ListDevices : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ListDevices() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::DevicesRequest, ::DevicesResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::DevicesRequest* request, ::DevicesResponse* response) { return this->ListDevices(context, request, response); }));}
    void SetMessageAllocatorFor_ListDevices(
        ::grpc::MessageAllocator< ::DevicesRequest, ::DevicesResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::DevicesRequest, ::DevicesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ListDevices() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDevices(::grpc::ServerContext* /*context*/, const ::DevicesRequest* /*request*/, ::DevicesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListDevices(
      ::grpc::CallbackServerContext* /*context*/, const ::DevicesRequest* /*request*/, ::DevicesResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_ListDevices<Service > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_ListDevices : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListDevices() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_ListDevices() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDevices(::grpc::ServerContext* /*context*/, const ::DevicesRequest* /*request*/, ::DevicesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListDevices : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListDevices() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_ListDevices() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDevices(::grpc::ServerContext* /*context*/, const ::DevicesRequest* /*request*/, ::DevicesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListDevices(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ListDevices : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ListDevices() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListDevices(context, request, response); }));
    }
    ~WithRawCallbackMethod_ListDevices() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDevices(::grpc::ServerContext* /*context*/, const ::DevicesRequest* /*request*/, ::DevicesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListDevices(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListDevices : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListDevices() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::DevicesRequest, ::DevicesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::DevicesRequest, ::DevicesResponse>* streamer) {
                       return this->StreamedListDevices(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListDevices() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListDevices(::grpc::ServerContext* /*context*/, const ::DevicesRequest* /*request*/, ::DevicesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListDevices(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::DevicesRequest,::DevicesResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_ListDevices<Service > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_ListDevices<Service > StreamedService;
};

class DeviceControl final {
 public:
  static constexpr char const* service_full_name() {
    return "DeviceControl";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // only available if DeviceCapability ResetSystem is present
    virtual ::grpc::Status ResetSystem(::grpc::ClientContext* context, const ::ResetSystemRequest& request, ::ResetSystemResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ResetSystemResponse>> AsyncResetSystem(::grpc::ClientContext* context, const ::ResetSystemRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ResetSystemResponse>>(AsyncResetSystemRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ResetSystemResponse>> PrepareAsyncResetSystem(::grpc::ClientContext* context, const ::ResetSystemRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ResetSystemResponse>>(PrepareAsyncResetSystemRaw(context, request, cq));
    }
    // only available if DeviceCapability ResetToMenu is present
    virtual ::grpc::Status ResetToMenu(::grpc::ClientContext* context, const ::ResetToMenuRequest& request, ::ResetToMenuResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ResetToMenuResponse>> AsyncResetToMenu(::grpc::ClientContext* context, const ::ResetToMenuRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ResetToMenuResponse>>(AsyncResetToMenuRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ResetToMenuResponse>> PrepareAsyncResetToMenu(::grpc::ClientContext* context, const ::ResetToMenuRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ResetToMenuResponse>>(PrepareAsyncResetToMenuRaw(context, request, cq));
    }
    // only available if DeviceCapability PauseUnpauseEmulation is present
    virtual ::grpc::Status PauseUnpauseEmulation(::grpc::ClientContext* context, const ::PauseEmulationRequest& request, ::PauseEmulationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::PauseEmulationResponse>> AsyncPauseUnpauseEmulation(::grpc::ClientContext* context, const ::PauseEmulationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::PauseEmulationResponse>>(AsyncPauseUnpauseEmulationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::PauseEmulationResponse>> PrepareAsyncPauseUnpauseEmulation(::grpc::ClientContext* context, const ::PauseEmulationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::PauseEmulationResponse>>(PrepareAsyncPauseUnpauseEmulationRaw(context, request, cq));
    }
    // only available if DeviceCapability PauseToggleEmulation is present
    virtual ::grpc::Status PauseToggleEmulation(::grpc::ClientContext* context, const ::PauseToggleEmulationRequest& request, ::PauseToggleEmulationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::PauseToggleEmulationResponse>> AsyncPauseToggleEmulation(::grpc::ClientContext* context, const ::PauseToggleEmulationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::PauseToggleEmulationResponse>>(AsyncPauseToggleEmulationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::PauseToggleEmulationResponse>> PrepareAsyncPauseToggleEmulation(::grpc::ClientContext* context, const ::PauseToggleEmulationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::PauseToggleEmulationResponse>>(PrepareAsyncPauseToggleEmulationRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // only available if DeviceCapability ResetSystem is present
      virtual void ResetSystem(::grpc::ClientContext* context, const ::ResetSystemRequest* request, ::ResetSystemResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ResetSystem(::grpc::ClientContext* context, const ::ResetSystemRequest* request, ::ResetSystemResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // only available if DeviceCapability ResetToMenu is present
      virtual void ResetToMenu(::grpc::ClientContext* context, const ::ResetToMenuRequest* request, ::ResetToMenuResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ResetToMenu(::grpc::ClientContext* context, const ::ResetToMenuRequest* request, ::ResetToMenuResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // only available if DeviceCapability PauseUnpauseEmulation is present
      virtual void PauseUnpauseEmulation(::grpc::ClientContext* context, const ::PauseEmulationRequest* request, ::PauseEmulationResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PauseUnpauseEmulation(::grpc::ClientContext* context, const ::PauseEmulationRequest* request, ::PauseEmulationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // only available if DeviceCapability PauseToggleEmulation is present
      virtual void PauseToggleEmulation(::grpc::ClientContext* context, const ::PauseToggleEmulationRequest* request, ::PauseToggleEmulationResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PauseToggleEmulation(::grpc::ClientContext* context, const ::PauseToggleEmulationRequest* request, ::PauseToggleEmulationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ResetSystemResponse>* AsyncResetSystemRaw(::grpc::ClientContext* context, const ::ResetSystemRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ResetSystemResponse>* PrepareAsyncResetSystemRaw(::grpc::ClientContext* context, const ::ResetSystemRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ResetToMenuResponse>* AsyncResetToMenuRaw(::grpc::ClientContext* context, const ::ResetToMenuRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ResetToMenuResponse>* PrepareAsyncResetToMenuRaw(::grpc::ClientContext* context, const ::ResetToMenuRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::PauseEmulationResponse>* AsyncPauseUnpauseEmulationRaw(::grpc::ClientContext* context, const ::PauseEmulationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::PauseEmulationResponse>* PrepareAsyncPauseUnpauseEmulationRaw(::grpc::ClientContext* context, const ::PauseEmulationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::PauseToggleEmulationResponse>* AsyncPauseToggleEmulationRaw(::grpc::ClientContext* context, const ::PauseToggleEmulationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::PauseToggleEmulationResponse>* PrepareAsyncPauseToggleEmulationRaw(::grpc::ClientContext* context, const ::PauseToggleEmulationRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status ResetSystem(::grpc::ClientContext* context, const ::ResetSystemRequest& request, ::ResetSystemResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ResetSystemResponse>> AsyncResetSystem(::grpc::ClientContext* context, const ::ResetSystemRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ResetSystemResponse>>(AsyncResetSystemRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ResetSystemResponse>> PrepareAsyncResetSystem(::grpc::ClientContext* context, const ::ResetSystemRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ResetSystemResponse>>(PrepareAsyncResetSystemRaw(context, request, cq));
    }
    ::grpc::Status ResetToMenu(::grpc::ClientContext* context, const ::ResetToMenuRequest& request, ::ResetToMenuResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ResetToMenuResponse>> AsyncResetToMenu(::grpc::ClientContext* context, const ::ResetToMenuRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ResetToMenuResponse>>(AsyncResetToMenuRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ResetToMenuResponse>> PrepareAsyncResetToMenu(::grpc::ClientContext* context, const ::ResetToMenuRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ResetToMenuResponse>>(PrepareAsyncResetToMenuRaw(context, request, cq));
    }
    ::grpc::Status PauseUnpauseEmulation(::grpc::ClientContext* context, const ::PauseEmulationRequest& request, ::PauseEmulationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::PauseEmulationResponse>> AsyncPauseUnpauseEmulation(::grpc::ClientContext* context, const ::PauseEmulationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::PauseEmulationResponse>>(AsyncPauseUnpauseEmulationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::PauseEmulationResponse>> PrepareAsyncPauseUnpauseEmulation(::grpc::ClientContext* context, const ::PauseEmulationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::PauseEmulationResponse>>(PrepareAsyncPauseUnpauseEmulationRaw(context, request, cq));
    }
    ::grpc::Status PauseToggleEmulation(::grpc::ClientContext* context, const ::PauseToggleEmulationRequest& request, ::PauseToggleEmulationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::PauseToggleEmulationResponse>> AsyncPauseToggleEmulation(::grpc::ClientContext* context, const ::PauseToggleEmulationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::PauseToggleEmulationResponse>>(AsyncPauseToggleEmulationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::PauseToggleEmulationResponse>> PrepareAsyncPauseToggleEmulation(::grpc::ClientContext* context, const ::PauseToggleEmulationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::PauseToggleEmulationResponse>>(PrepareAsyncPauseToggleEmulationRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void ResetSystem(::grpc::ClientContext* context, const ::ResetSystemRequest* request, ::ResetSystemResponse* response, std::function<void(::grpc::Status)>) override;
      void ResetSystem(::grpc::ClientContext* context, const ::ResetSystemRequest* request, ::ResetSystemResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ResetToMenu(::grpc::ClientContext* context, const ::ResetToMenuRequest* request, ::ResetToMenuResponse* response, std::function<void(::grpc::Status)>) override;
      void ResetToMenu(::grpc::ClientContext* context, const ::ResetToMenuRequest* request, ::ResetToMenuResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PauseUnpauseEmulation(::grpc::ClientContext* context, const ::PauseEmulationRequest* request, ::PauseEmulationResponse* response, std::function<void(::grpc::Status)>) override;
      void PauseUnpauseEmulation(::grpc::ClientContext* context, const ::PauseEmulationRequest* request, ::PauseEmulationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PauseToggleEmulation(::grpc::ClientContext* context, const ::PauseToggleEmulationRequest* request, ::PauseToggleEmulationResponse* response, std::function<void(::grpc::Status)>) override;
      void PauseToggleEmulation(::grpc::ClientContext* context, const ::PauseToggleEmulationRequest* request, ::PauseToggleEmulationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::ResetSystemResponse>* AsyncResetSystemRaw(::grpc::ClientContext* context, const ::ResetSystemRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ResetSystemResponse>* PrepareAsyncResetSystemRaw(::grpc::ClientContext* context, const ::ResetSystemRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ResetToMenuResponse>* AsyncResetToMenuRaw(::grpc::ClientContext* context, const ::ResetToMenuRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ResetToMenuResponse>* PrepareAsyncResetToMenuRaw(::grpc::ClientContext* context, const ::ResetToMenuRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::PauseEmulationResponse>* AsyncPauseUnpauseEmulationRaw(::grpc::ClientContext* context, const ::PauseEmulationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::PauseEmulationResponse>* PrepareAsyncPauseUnpauseEmulationRaw(::grpc::ClientContext* context, const ::PauseEmulationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::PauseToggleEmulationResponse>* AsyncPauseToggleEmulationRaw(::grpc::ClientContext* context, const ::PauseToggleEmulationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::PauseToggleEmulationResponse>* PrepareAsyncPauseToggleEmulationRaw(::grpc::ClientContext* context, const ::PauseToggleEmulationRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_ResetSystem_;
    const ::grpc::internal::RpcMethod rpcmethod_ResetToMenu_;
    const ::grpc::internal::RpcMethod rpcmethod_PauseUnpauseEmulation_;
    const ::grpc::internal::RpcMethod rpcmethod_PauseToggleEmulation_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // only available if DeviceCapability ResetSystem is present
    virtual ::grpc::Status ResetSystem(::grpc::ServerContext* context, const ::ResetSystemRequest* request, ::ResetSystemResponse* response);
    // only available if DeviceCapability ResetToMenu is present
    virtual ::grpc::Status ResetToMenu(::grpc::ServerContext* context, const ::ResetToMenuRequest* request, ::ResetToMenuResponse* response);
    // only available if DeviceCapability PauseUnpauseEmulation is present
    virtual ::grpc::Status PauseUnpauseEmulation(::grpc::ServerContext* context, const ::PauseEmulationRequest* request, ::PauseEmulationResponse* response);
    // only available if DeviceCapability PauseToggleEmulation is present
    virtual ::grpc::Status PauseToggleEmulation(::grpc::ServerContext* context, const ::PauseToggleEmulationRequest* request, ::PauseToggleEmulationResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_ResetSystem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ResetSystem() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_ResetSystem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetSystem(::grpc::ServerContext* /*context*/, const ::ResetSystemRequest* /*request*/, ::ResetSystemResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResetSystem(::grpc::ServerContext* context, ::ResetSystemRequest* request, ::grpc::ServerAsyncResponseWriter< ::ResetSystemResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ResetToMenu : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ResetToMenu() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_ResetToMenu() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetToMenu(::grpc::ServerContext* /*context*/, const ::ResetToMenuRequest* /*request*/, ::ResetToMenuResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResetToMenu(::grpc::ServerContext* context, ::ResetToMenuRequest* request, ::grpc::ServerAsyncResponseWriter< ::ResetToMenuResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PauseUnpauseEmulation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PauseUnpauseEmulation() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_PauseUnpauseEmulation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PauseUnpauseEmulation(::grpc::ServerContext* /*context*/, const ::PauseEmulationRequest* /*request*/, ::PauseEmulationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPauseUnpauseEmulation(::grpc::ServerContext* context, ::PauseEmulationRequest* request, ::grpc::ServerAsyncResponseWriter< ::PauseEmulationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PauseToggleEmulation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PauseToggleEmulation() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_PauseToggleEmulation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PauseToggleEmulation(::grpc::ServerContext* /*context*/, const ::PauseToggleEmulationRequest* /*request*/, ::PauseToggleEmulationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPauseToggleEmulation(::grpc::ServerContext* context, ::PauseToggleEmulationRequest* request, ::grpc::ServerAsyncResponseWriter< ::PauseToggleEmulationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_ResetSystem<WithAsyncMethod_ResetToMenu<WithAsyncMethod_PauseUnpauseEmulation<WithAsyncMethod_PauseToggleEmulation<Service > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_ResetSystem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ResetSystem() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::ResetSystemRequest, ::ResetSystemResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::ResetSystemRequest* request, ::ResetSystemResponse* response) { return this->ResetSystem(context, request, response); }));}
    void SetMessageAllocatorFor_ResetSystem(
        ::grpc::MessageAllocator< ::ResetSystemRequest, ::ResetSystemResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::ResetSystemRequest, ::ResetSystemResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ResetSystem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetSystem(::grpc::ServerContext* /*context*/, const ::ResetSystemRequest* /*request*/, ::ResetSystemResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ResetSystem(
      ::grpc::CallbackServerContext* /*context*/, const ::ResetSystemRequest* /*request*/, ::ResetSystemResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ResetToMenu : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ResetToMenu() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::ResetToMenuRequest, ::ResetToMenuResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::ResetToMenuRequest* request, ::ResetToMenuResponse* response) { return this->ResetToMenu(context, request, response); }));}
    void SetMessageAllocatorFor_ResetToMenu(
        ::grpc::MessageAllocator< ::ResetToMenuRequest, ::ResetToMenuResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::ResetToMenuRequest, ::ResetToMenuResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ResetToMenu() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetToMenu(::grpc::ServerContext* /*context*/, const ::ResetToMenuRequest* /*request*/, ::ResetToMenuResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ResetToMenu(
      ::grpc::CallbackServerContext* /*context*/, const ::ResetToMenuRequest* /*request*/, ::ResetToMenuResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PauseUnpauseEmulation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PauseUnpauseEmulation() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::PauseEmulationRequest, ::PauseEmulationResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::PauseEmulationRequest* request, ::PauseEmulationResponse* response) { return this->PauseUnpauseEmulation(context, request, response); }));}
    void SetMessageAllocatorFor_PauseUnpauseEmulation(
        ::grpc::MessageAllocator< ::PauseEmulationRequest, ::PauseEmulationResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::PauseEmulationRequest, ::PauseEmulationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PauseUnpauseEmulation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PauseUnpauseEmulation(::grpc::ServerContext* /*context*/, const ::PauseEmulationRequest* /*request*/, ::PauseEmulationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PauseUnpauseEmulation(
      ::grpc::CallbackServerContext* /*context*/, const ::PauseEmulationRequest* /*request*/, ::PauseEmulationResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PauseToggleEmulation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PauseToggleEmulation() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::PauseToggleEmulationRequest, ::PauseToggleEmulationResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::PauseToggleEmulationRequest* request, ::PauseToggleEmulationResponse* response) { return this->PauseToggleEmulation(context, request, response); }));}
    void SetMessageAllocatorFor_PauseToggleEmulation(
        ::grpc::MessageAllocator< ::PauseToggleEmulationRequest, ::PauseToggleEmulationResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::PauseToggleEmulationRequest, ::PauseToggleEmulationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PauseToggleEmulation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PauseToggleEmulation(::grpc::ServerContext* /*context*/, const ::PauseToggleEmulationRequest* /*request*/, ::PauseToggleEmulationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PauseToggleEmulation(
      ::grpc::CallbackServerContext* /*context*/, const ::PauseToggleEmulationRequest* /*request*/, ::PauseToggleEmulationResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_ResetSystem<WithCallbackMethod_ResetToMenu<WithCallbackMethod_PauseUnpauseEmulation<WithCallbackMethod_PauseToggleEmulation<Service > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_ResetSystem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ResetSystem() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_ResetSystem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetSystem(::grpc::ServerContext* /*context*/, const ::ResetSystemRequest* /*request*/, ::ResetSystemResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ResetToMenu : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ResetToMenu() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_ResetToMenu() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetToMenu(::grpc::ServerContext* /*context*/, const ::ResetToMenuRequest* /*request*/, ::ResetToMenuResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PauseUnpauseEmulation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PauseUnpauseEmulation() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_PauseUnpauseEmulation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PauseUnpauseEmulation(::grpc::ServerContext* /*context*/, const ::PauseEmulationRequest* /*request*/, ::PauseEmulationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PauseToggleEmulation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PauseToggleEmulation() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_PauseToggleEmulation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PauseToggleEmulation(::grpc::ServerContext* /*context*/, const ::PauseToggleEmulationRequest* /*request*/, ::PauseToggleEmulationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_ResetSystem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ResetSystem() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_ResetSystem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetSystem(::grpc::ServerContext* /*context*/, const ::ResetSystemRequest* /*request*/, ::ResetSystemResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResetSystem(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ResetToMenu : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ResetToMenu() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_ResetToMenu() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetToMenu(::grpc::ServerContext* /*context*/, const ::ResetToMenuRequest* /*request*/, ::ResetToMenuResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResetToMenu(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PauseUnpauseEmulation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PauseUnpauseEmulation() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_PauseUnpauseEmulation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PauseUnpauseEmulation(::grpc::ServerContext* /*context*/, const ::PauseEmulationRequest* /*request*/, ::PauseEmulationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPauseUnpauseEmulation(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PauseToggleEmulation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PauseToggleEmulation() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_PauseToggleEmulation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PauseToggleEmulation(::grpc::ServerContext* /*context*/, const ::PauseToggleEmulationRequest* /*request*/, ::PauseToggleEmulationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPauseToggleEmulation(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ResetSystem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ResetSystem() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ResetSystem(context, request, response); }));
    }
    ~WithRawCallbackMethod_ResetSystem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetSystem(::grpc::ServerContext* /*context*/, const ::ResetSystemRequest* /*request*/, ::ResetSystemResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ResetSystem(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ResetToMenu : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ResetToMenu() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ResetToMenu(context, request, response); }));
    }
    ~WithRawCallbackMethod_ResetToMenu() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetToMenu(::grpc::ServerContext* /*context*/, const ::ResetToMenuRequest* /*request*/, ::ResetToMenuResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ResetToMenu(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PauseUnpauseEmulation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PauseUnpauseEmulation() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PauseUnpauseEmulation(context, request, response); }));
    }
    ~WithRawCallbackMethod_PauseUnpauseEmulation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PauseUnpauseEmulation(::grpc::ServerContext* /*context*/, const ::PauseEmulationRequest* /*request*/, ::PauseEmulationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PauseUnpauseEmulation(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PauseToggleEmulation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PauseToggleEmulation() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PauseToggleEmulation(context, request, response); }));
    }
    ~WithRawCallbackMethod_PauseToggleEmulation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PauseToggleEmulation(::grpc::ServerContext* /*context*/, const ::PauseToggleEmulationRequest* /*request*/, ::PauseToggleEmulationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PauseToggleEmulation(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ResetSystem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ResetSystem() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::ResetSystemRequest, ::ResetSystemResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::ResetSystemRequest, ::ResetSystemResponse>* streamer) {
                       return this->StreamedResetSystem(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ResetSystem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ResetSystem(::grpc::ServerContext* /*context*/, const ::ResetSystemRequest* /*request*/, ::ResetSystemResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedResetSystem(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ResetSystemRequest,::ResetSystemResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ResetToMenu : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ResetToMenu() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::ResetToMenuRequest, ::ResetToMenuResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::ResetToMenuRequest, ::ResetToMenuResponse>* streamer) {
                       return this->StreamedResetToMenu(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ResetToMenu() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ResetToMenu(::grpc::ServerContext* /*context*/, const ::ResetToMenuRequest* /*request*/, ::ResetToMenuResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedResetToMenu(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ResetToMenuRequest,::ResetToMenuResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PauseUnpauseEmulation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PauseUnpauseEmulation() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::PauseEmulationRequest, ::PauseEmulationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::PauseEmulationRequest, ::PauseEmulationResponse>* streamer) {
                       return this->StreamedPauseUnpauseEmulation(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PauseUnpauseEmulation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PauseUnpauseEmulation(::grpc::ServerContext* /*context*/, const ::PauseEmulationRequest* /*request*/, ::PauseEmulationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPauseUnpauseEmulation(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::PauseEmulationRequest,::PauseEmulationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PauseToggleEmulation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PauseToggleEmulation() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::PauseToggleEmulationRequest, ::PauseToggleEmulationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::PauseToggleEmulationRequest, ::PauseToggleEmulationResponse>* streamer) {
                       return this->StreamedPauseToggleEmulation(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PauseToggleEmulation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PauseToggleEmulation(::grpc::ServerContext* /*context*/, const ::PauseToggleEmulationRequest* /*request*/, ::PauseToggleEmulationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPauseToggleEmulation(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::PauseToggleEmulationRequest,::PauseToggleEmulationResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_ResetSystem<WithStreamedUnaryMethod_ResetToMenu<WithStreamedUnaryMethod_PauseUnpauseEmulation<WithStreamedUnaryMethod_PauseToggleEmulation<Service > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_ResetSystem<WithStreamedUnaryMethod_ResetToMenu<WithStreamedUnaryMethod_PauseUnpauseEmulation<WithStreamedUnaryMethod_PauseToggleEmulation<Service > > > > StreamedService;
};

class DeviceMemory final {
 public:
  static constexpr char const* service_full_name() {
    return "DeviceMemory";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // detect the current memory mapping for the given device by reading header:
    virtual ::grpc::Status MappingDetect(::grpc::ClientContext* context, const ::DetectMemoryMappingRequest& request, ::DetectMemoryMappingResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::DetectMemoryMappingResponse>> AsyncMappingDetect(::grpc::ClientContext* context, const ::DetectMemoryMappingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::DetectMemoryMappingResponse>>(AsyncMappingDetectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::DetectMemoryMappingResponse>> PrepareAsyncMappingDetect(::grpc::ClientContext* context, const ::DetectMemoryMappingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::DetectMemoryMappingResponse>>(PrepareAsyncMappingDetectRaw(context, request, cq));
    }
    // read a single memory segment with a given size from the given device:
    virtual ::grpc::Status SingleRead(::grpc::ClientContext* context, const ::SingleReadMemoryRequest& request, ::SingleReadMemoryResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SingleReadMemoryResponse>> AsyncSingleRead(::grpc::ClientContext* context, const ::SingleReadMemoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SingleReadMemoryResponse>>(AsyncSingleReadRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SingleReadMemoryResponse>> PrepareAsyncSingleRead(::grpc::ClientContext* context, const ::SingleReadMemoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SingleReadMemoryResponse>>(PrepareAsyncSingleReadRaw(context, request, cq));
    }
    // write a single memory segment with given data to the given device:
    virtual ::grpc::Status SingleWrite(::grpc::ClientContext* context, const ::SingleWriteMemoryRequest& request, ::SingleWriteMemoryResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SingleWriteMemoryResponse>> AsyncSingleWrite(::grpc::ClientContext* context, const ::SingleWriteMemoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SingleWriteMemoryResponse>>(AsyncSingleWriteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SingleWriteMemoryResponse>> PrepareAsyncSingleWrite(::grpc::ClientContext* context, const ::SingleWriteMemoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SingleWriteMemoryResponse>>(PrepareAsyncSingleWriteRaw(context, request, cq));
    }
    // read multiple memory segments with given sizes from the given device:
    virtual ::grpc::Status MultiRead(::grpc::ClientContext* context, const ::MultiReadMemoryRequest& request, ::MultiReadMemoryResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MultiReadMemoryResponse>> AsyncMultiRead(::grpc::ClientContext* context, const ::MultiReadMemoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MultiReadMemoryResponse>>(AsyncMultiReadRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MultiReadMemoryResponse>> PrepareAsyncMultiRead(::grpc::ClientContext* context, const ::MultiReadMemoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MultiReadMemoryResponse>>(PrepareAsyncMultiReadRaw(context, request, cq));
    }
    // write multiple memory segments with given data to the given device:
    virtual ::grpc::Status MultiWrite(::grpc::ClientContext* context, const ::MultiWriteMemoryRequest& request, ::MultiWriteMemoryResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MultiWriteMemoryResponse>> AsyncMultiWrite(::grpc::ClientContext* context, const ::MultiWriteMemoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MultiWriteMemoryResponse>>(AsyncMultiWriteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MultiWriteMemoryResponse>> PrepareAsyncMultiWrite(::grpc::ClientContext* context, const ::MultiWriteMemoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MultiWriteMemoryResponse>>(PrepareAsyncMultiWriteRaw(context, request, cq));
    }
    // stream read multiple memory segments with given sizes from the given device:
    std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::MultiReadMemoryRequest, ::MultiReadMemoryResponse>> StreamRead(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::MultiReadMemoryRequest, ::MultiReadMemoryResponse>>(StreamReadRaw(context));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::MultiReadMemoryRequest, ::MultiReadMemoryResponse>> AsyncStreamRead(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::MultiReadMemoryRequest, ::MultiReadMemoryResponse>>(AsyncStreamReadRaw(context, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::MultiReadMemoryRequest, ::MultiReadMemoryResponse>> PrepareAsyncStreamRead(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::MultiReadMemoryRequest, ::MultiReadMemoryResponse>>(PrepareAsyncStreamReadRaw(context, cq));
    }
    // stream write multiple memory segments with given data to the given device:
    std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::MultiWriteMemoryRequest, ::MultiWriteMemoryResponse>> StreamWrite(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::MultiWriteMemoryRequest, ::MultiWriteMemoryResponse>>(StreamWriteRaw(context));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::MultiWriteMemoryRequest, ::MultiWriteMemoryResponse>> AsyncStreamWrite(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::MultiWriteMemoryRequest, ::MultiWriteMemoryResponse>>(AsyncStreamWriteRaw(context, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::MultiWriteMemoryRequest, ::MultiWriteMemoryResponse>> PrepareAsyncStreamWrite(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::MultiWriteMemoryRequest, ::MultiWriteMemoryResponse>>(PrepareAsyncStreamWriteRaw(context, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // detect the current memory mapping for the given device by reading header:
      virtual void MappingDetect(::grpc::ClientContext* context, const ::DetectMemoryMappingRequest* request, ::DetectMemoryMappingResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void MappingDetect(::grpc::ClientContext* context, const ::DetectMemoryMappingRequest* request, ::DetectMemoryMappingResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // read a single memory segment with a given size from the given device:
      virtual void SingleRead(::grpc::ClientContext* context, const ::SingleReadMemoryRequest* request, ::SingleReadMemoryResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SingleRead(::grpc::ClientContext* context, const ::SingleReadMemoryRequest* request, ::SingleReadMemoryResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // write a single memory segment with given data to the given device:
      virtual void SingleWrite(::grpc::ClientContext* context, const ::SingleWriteMemoryRequest* request, ::SingleWriteMemoryResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SingleWrite(::grpc::ClientContext* context, const ::SingleWriteMemoryRequest* request, ::SingleWriteMemoryResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // read multiple memory segments with given sizes from the given device:
      virtual void MultiRead(::grpc::ClientContext* context, const ::MultiReadMemoryRequest* request, ::MultiReadMemoryResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void MultiRead(::grpc::ClientContext* context, const ::MultiReadMemoryRequest* request, ::MultiReadMemoryResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // write multiple memory segments with given data to the given device:
      virtual void MultiWrite(::grpc::ClientContext* context, const ::MultiWriteMemoryRequest* request, ::MultiWriteMemoryResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void MultiWrite(::grpc::ClientContext* context, const ::MultiWriteMemoryRequest* request, ::MultiWriteMemoryResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // stream read multiple memory segments with given sizes from the given device:
      virtual void StreamRead(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::MultiReadMemoryRequest,::MultiReadMemoryResponse>* reactor) = 0;
      // stream write multiple memory segments with given data to the given device:
      virtual void StreamWrite(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::MultiWriteMemoryRequest,::MultiWriteMemoryResponse>* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::DetectMemoryMappingResponse>* AsyncMappingDetectRaw(::grpc::ClientContext* context, const ::DetectMemoryMappingRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::DetectMemoryMappingResponse>* PrepareAsyncMappingDetectRaw(::grpc::ClientContext* context, const ::DetectMemoryMappingRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::SingleReadMemoryResponse>* AsyncSingleReadRaw(::grpc::ClientContext* context, const ::SingleReadMemoryRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::SingleReadMemoryResponse>* PrepareAsyncSingleReadRaw(::grpc::ClientContext* context, const ::SingleReadMemoryRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::SingleWriteMemoryResponse>* AsyncSingleWriteRaw(::grpc::ClientContext* context, const ::SingleWriteMemoryRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::SingleWriteMemoryResponse>* PrepareAsyncSingleWriteRaw(::grpc::ClientContext* context, const ::SingleWriteMemoryRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MultiReadMemoryResponse>* AsyncMultiReadRaw(::grpc::ClientContext* context, const ::MultiReadMemoryRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MultiReadMemoryResponse>* PrepareAsyncMultiReadRaw(::grpc::ClientContext* context, const ::MultiReadMemoryRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MultiWriteMemoryResponse>* AsyncMultiWriteRaw(::grpc::ClientContext* context, const ::MultiWriteMemoryRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MultiWriteMemoryResponse>* PrepareAsyncMultiWriteRaw(::grpc::ClientContext* context, const ::MultiWriteMemoryRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderWriterInterface< ::MultiReadMemoryRequest, ::MultiReadMemoryResponse>* StreamReadRaw(::grpc::ClientContext* context) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::MultiReadMemoryRequest, ::MultiReadMemoryResponse>* AsyncStreamReadRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::MultiReadMemoryRequest, ::MultiReadMemoryResponse>* PrepareAsyncStreamReadRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderWriterInterface< ::MultiWriteMemoryRequest, ::MultiWriteMemoryResponse>* StreamWriteRaw(::grpc::ClientContext* context) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::MultiWriteMemoryRequest, ::MultiWriteMemoryResponse>* AsyncStreamWriteRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::MultiWriteMemoryRequest, ::MultiWriteMemoryResponse>* PrepareAsyncStreamWriteRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status MappingDetect(::grpc::ClientContext* context, const ::DetectMemoryMappingRequest& request, ::DetectMemoryMappingResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::DetectMemoryMappingResponse>> AsyncMappingDetect(::grpc::ClientContext* context, const ::DetectMemoryMappingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::DetectMemoryMappingResponse>>(AsyncMappingDetectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::DetectMemoryMappingResponse>> PrepareAsyncMappingDetect(::grpc::ClientContext* context, const ::DetectMemoryMappingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::DetectMemoryMappingResponse>>(PrepareAsyncMappingDetectRaw(context, request, cq));
    }
    ::grpc::Status SingleRead(::grpc::ClientContext* context, const ::SingleReadMemoryRequest& request, ::SingleReadMemoryResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SingleReadMemoryResponse>> AsyncSingleRead(::grpc::ClientContext* context, const ::SingleReadMemoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SingleReadMemoryResponse>>(AsyncSingleReadRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SingleReadMemoryResponse>> PrepareAsyncSingleRead(::grpc::ClientContext* context, const ::SingleReadMemoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SingleReadMemoryResponse>>(PrepareAsyncSingleReadRaw(context, request, cq));
    }
    ::grpc::Status SingleWrite(::grpc::ClientContext* context, const ::SingleWriteMemoryRequest& request, ::SingleWriteMemoryResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SingleWriteMemoryResponse>> AsyncSingleWrite(::grpc::ClientContext* context, const ::SingleWriteMemoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SingleWriteMemoryResponse>>(AsyncSingleWriteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SingleWriteMemoryResponse>> PrepareAsyncSingleWrite(::grpc::ClientContext* context, const ::SingleWriteMemoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SingleWriteMemoryResponse>>(PrepareAsyncSingleWriteRaw(context, request, cq));
    }
    ::grpc::Status MultiRead(::grpc::ClientContext* context, const ::MultiReadMemoryRequest& request, ::MultiReadMemoryResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MultiReadMemoryResponse>> AsyncMultiRead(::grpc::ClientContext* context, const ::MultiReadMemoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MultiReadMemoryResponse>>(AsyncMultiReadRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MultiReadMemoryResponse>> PrepareAsyncMultiRead(::grpc::ClientContext* context, const ::MultiReadMemoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MultiReadMemoryResponse>>(PrepareAsyncMultiReadRaw(context, request, cq));
    }
    ::grpc::Status MultiWrite(::grpc::ClientContext* context, const ::MultiWriteMemoryRequest& request, ::MultiWriteMemoryResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MultiWriteMemoryResponse>> AsyncMultiWrite(::grpc::ClientContext* context, const ::MultiWriteMemoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MultiWriteMemoryResponse>>(AsyncMultiWriteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MultiWriteMemoryResponse>> PrepareAsyncMultiWrite(::grpc::ClientContext* context, const ::MultiWriteMemoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MultiWriteMemoryResponse>>(PrepareAsyncMultiWriteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderWriter< ::MultiReadMemoryRequest, ::MultiReadMemoryResponse>> StreamRead(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriter< ::MultiReadMemoryRequest, ::MultiReadMemoryResponse>>(StreamReadRaw(context));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::MultiReadMemoryRequest, ::MultiReadMemoryResponse>> AsyncStreamRead(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::MultiReadMemoryRequest, ::MultiReadMemoryResponse>>(AsyncStreamReadRaw(context, cq, tag));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::MultiReadMemoryRequest, ::MultiReadMemoryResponse>> PrepareAsyncStreamRead(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::MultiReadMemoryRequest, ::MultiReadMemoryResponse>>(PrepareAsyncStreamReadRaw(context, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderWriter< ::MultiWriteMemoryRequest, ::MultiWriteMemoryResponse>> StreamWrite(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriter< ::MultiWriteMemoryRequest, ::MultiWriteMemoryResponse>>(StreamWriteRaw(context));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::MultiWriteMemoryRequest, ::MultiWriteMemoryResponse>> AsyncStreamWrite(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::MultiWriteMemoryRequest, ::MultiWriteMemoryResponse>>(AsyncStreamWriteRaw(context, cq, tag));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::MultiWriteMemoryRequest, ::MultiWriteMemoryResponse>> PrepareAsyncStreamWrite(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::MultiWriteMemoryRequest, ::MultiWriteMemoryResponse>>(PrepareAsyncStreamWriteRaw(context, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void MappingDetect(::grpc::ClientContext* context, const ::DetectMemoryMappingRequest* request, ::DetectMemoryMappingResponse* response, std::function<void(::grpc::Status)>) override;
      void MappingDetect(::grpc::ClientContext* context, const ::DetectMemoryMappingRequest* request, ::DetectMemoryMappingResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SingleRead(::grpc::ClientContext* context, const ::SingleReadMemoryRequest* request, ::SingleReadMemoryResponse* response, std::function<void(::grpc::Status)>) override;
      void SingleRead(::grpc::ClientContext* context, const ::SingleReadMemoryRequest* request, ::SingleReadMemoryResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SingleWrite(::grpc::ClientContext* context, const ::SingleWriteMemoryRequest* request, ::SingleWriteMemoryResponse* response, std::function<void(::grpc::Status)>) override;
      void SingleWrite(::grpc::ClientContext* context, const ::SingleWriteMemoryRequest* request, ::SingleWriteMemoryResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void MultiRead(::grpc::ClientContext* context, const ::MultiReadMemoryRequest* request, ::MultiReadMemoryResponse* response, std::function<void(::grpc::Status)>) override;
      void MultiRead(::grpc::ClientContext* context, const ::MultiReadMemoryRequest* request, ::MultiReadMemoryResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void MultiWrite(::grpc::ClientContext* context, const ::MultiWriteMemoryRequest* request, ::MultiWriteMemoryResponse* response, std::function<void(::grpc::Status)>) override;
      void MultiWrite(::grpc::ClientContext* context, const ::MultiWriteMemoryRequest* request, ::MultiWriteMemoryResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void StreamRead(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::MultiReadMemoryRequest,::MultiReadMemoryResponse>* reactor) override;
      void StreamWrite(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::MultiWriteMemoryRequest,::MultiWriteMemoryResponse>* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::DetectMemoryMappingResponse>* AsyncMappingDetectRaw(::grpc::ClientContext* context, const ::DetectMemoryMappingRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::DetectMemoryMappingResponse>* PrepareAsyncMappingDetectRaw(::grpc::ClientContext* context, const ::DetectMemoryMappingRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::SingleReadMemoryResponse>* AsyncSingleReadRaw(::grpc::ClientContext* context, const ::SingleReadMemoryRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::SingleReadMemoryResponse>* PrepareAsyncSingleReadRaw(::grpc::ClientContext* context, const ::SingleReadMemoryRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::SingleWriteMemoryResponse>* AsyncSingleWriteRaw(::grpc::ClientContext* context, const ::SingleWriteMemoryRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::SingleWriteMemoryResponse>* PrepareAsyncSingleWriteRaw(::grpc::ClientContext* context, const ::SingleWriteMemoryRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MultiReadMemoryResponse>* AsyncMultiReadRaw(::grpc::ClientContext* context, const ::MultiReadMemoryRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MultiReadMemoryResponse>* PrepareAsyncMultiReadRaw(::grpc::ClientContext* context, const ::MultiReadMemoryRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MultiWriteMemoryResponse>* AsyncMultiWriteRaw(::grpc::ClientContext* context, const ::MultiWriteMemoryRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MultiWriteMemoryResponse>* PrepareAsyncMultiWriteRaw(::grpc::ClientContext* context, const ::MultiWriteMemoryRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReaderWriter< ::MultiReadMemoryRequest, ::MultiReadMemoryResponse>* StreamReadRaw(::grpc::ClientContext* context) override;
    ::grpc::ClientAsyncReaderWriter< ::MultiReadMemoryRequest, ::MultiReadMemoryResponse>* AsyncStreamReadRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReaderWriter< ::MultiReadMemoryRequest, ::MultiReadMemoryResponse>* PrepareAsyncStreamReadRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReaderWriter< ::MultiWriteMemoryRequest, ::MultiWriteMemoryResponse>* StreamWriteRaw(::grpc::ClientContext* context) override;
    ::grpc::ClientAsyncReaderWriter< ::MultiWriteMemoryRequest, ::MultiWriteMemoryResponse>* AsyncStreamWriteRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReaderWriter< ::MultiWriteMemoryRequest, ::MultiWriteMemoryResponse>* PrepareAsyncStreamWriteRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_MappingDetect_;
    const ::grpc::internal::RpcMethod rpcmethod_SingleRead_;
    const ::grpc::internal::RpcMethod rpcmethod_SingleWrite_;
    const ::grpc::internal::RpcMethod rpcmethod_MultiRead_;
    const ::grpc::internal::RpcMethod rpcmethod_MultiWrite_;
    const ::grpc::internal::RpcMethod rpcmethod_StreamRead_;
    const ::grpc::internal::RpcMethod rpcmethod_StreamWrite_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // detect the current memory mapping for the given device by reading header:
    virtual ::grpc::Status MappingDetect(::grpc::ServerContext* context, const ::DetectMemoryMappingRequest* request, ::DetectMemoryMappingResponse* response);
    // read a single memory segment with a given size from the given device:
    virtual ::grpc::Status SingleRead(::grpc::ServerContext* context, const ::SingleReadMemoryRequest* request, ::SingleReadMemoryResponse* response);
    // write a single memory segment with given data to the given device:
    virtual ::grpc::Status SingleWrite(::grpc::ServerContext* context, const ::SingleWriteMemoryRequest* request, ::SingleWriteMemoryResponse* response);
    // read multiple memory segments with given sizes from the given device:
    virtual ::grpc::Status MultiRead(::grpc::ServerContext* context, const ::MultiReadMemoryRequest* request, ::MultiReadMemoryResponse* response);
    // write multiple memory segments with given data to the given device:
    virtual ::grpc::Status MultiWrite(::grpc::ServerContext* context, const ::MultiWriteMemoryRequest* request, ::MultiWriteMemoryResponse* response);
    // stream read multiple memory segments with given sizes from the given device:
    virtual ::grpc::Status StreamRead(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::MultiReadMemoryResponse, ::MultiReadMemoryRequest>* stream);
    // stream write multiple memory segments with given data to the given device:
    virtual ::grpc::Status StreamWrite(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::MultiWriteMemoryResponse, ::MultiWriteMemoryRequest>* stream);
  };
  template <class BaseClass>
  class WithAsyncMethod_MappingDetect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MappingDetect() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_MappingDetect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MappingDetect(::grpc::ServerContext* /*context*/, const ::DetectMemoryMappingRequest* /*request*/, ::DetectMemoryMappingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMappingDetect(::grpc::ServerContext* context, ::DetectMemoryMappingRequest* request, ::grpc::ServerAsyncResponseWriter< ::DetectMemoryMappingResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SingleRead : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SingleRead() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_SingleRead() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SingleRead(::grpc::ServerContext* /*context*/, const ::SingleReadMemoryRequest* /*request*/, ::SingleReadMemoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSingleRead(::grpc::ServerContext* context, ::SingleReadMemoryRequest* request, ::grpc::ServerAsyncResponseWriter< ::SingleReadMemoryResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SingleWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SingleWrite() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_SingleWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SingleWrite(::grpc::ServerContext* /*context*/, const ::SingleWriteMemoryRequest* /*request*/, ::SingleWriteMemoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSingleWrite(::grpc::ServerContext* context, ::SingleWriteMemoryRequest* request, ::grpc::ServerAsyncResponseWriter< ::SingleWriteMemoryResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MultiRead : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MultiRead() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_MultiRead() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MultiRead(::grpc::ServerContext* /*context*/, const ::MultiReadMemoryRequest* /*request*/, ::MultiReadMemoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMultiRead(::grpc::ServerContext* context, ::MultiReadMemoryRequest* request, ::grpc::ServerAsyncResponseWriter< ::MultiReadMemoryResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MultiWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MultiWrite() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_MultiWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MultiWrite(::grpc::ServerContext* /*context*/, const ::MultiWriteMemoryRequest* /*request*/, ::MultiWriteMemoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMultiWrite(::grpc::ServerContext* context, ::MultiWriteMemoryRequest* request, ::grpc::ServerAsyncResponseWriter< ::MultiWriteMemoryResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StreamRead : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StreamRead() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_StreamRead() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamRead(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::MultiReadMemoryResponse, ::MultiReadMemoryRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStreamRead(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::MultiReadMemoryResponse, ::MultiReadMemoryRequest>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(5, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StreamWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StreamWrite() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_StreamWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamWrite(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::MultiWriteMemoryResponse, ::MultiWriteMemoryRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStreamWrite(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::MultiWriteMemoryResponse, ::MultiWriteMemoryRequest>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(6, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_MappingDetect<WithAsyncMethod_SingleRead<WithAsyncMethod_SingleWrite<WithAsyncMethod_MultiRead<WithAsyncMethod_MultiWrite<WithAsyncMethod_StreamRead<WithAsyncMethod_StreamWrite<Service > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_MappingDetect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_MappingDetect() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::DetectMemoryMappingRequest, ::DetectMemoryMappingResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::DetectMemoryMappingRequest* request, ::DetectMemoryMappingResponse* response) { return this->MappingDetect(context, request, response); }));}
    void SetMessageAllocatorFor_MappingDetect(
        ::grpc::MessageAllocator< ::DetectMemoryMappingRequest, ::DetectMemoryMappingResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::DetectMemoryMappingRequest, ::DetectMemoryMappingResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_MappingDetect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MappingDetect(::grpc::ServerContext* /*context*/, const ::DetectMemoryMappingRequest* /*request*/, ::DetectMemoryMappingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* MappingDetect(
      ::grpc::CallbackServerContext* /*context*/, const ::DetectMemoryMappingRequest* /*request*/, ::DetectMemoryMappingResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SingleRead : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SingleRead() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::SingleReadMemoryRequest, ::SingleReadMemoryResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::SingleReadMemoryRequest* request, ::SingleReadMemoryResponse* response) { return this->SingleRead(context, request, response); }));}
    void SetMessageAllocatorFor_SingleRead(
        ::grpc::MessageAllocator< ::SingleReadMemoryRequest, ::SingleReadMemoryResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::SingleReadMemoryRequest, ::SingleReadMemoryResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SingleRead() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SingleRead(::grpc::ServerContext* /*context*/, const ::SingleReadMemoryRequest* /*request*/, ::SingleReadMemoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SingleRead(
      ::grpc::CallbackServerContext* /*context*/, const ::SingleReadMemoryRequest* /*request*/, ::SingleReadMemoryResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SingleWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SingleWrite() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::SingleWriteMemoryRequest, ::SingleWriteMemoryResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::SingleWriteMemoryRequest* request, ::SingleWriteMemoryResponse* response) { return this->SingleWrite(context, request, response); }));}
    void SetMessageAllocatorFor_SingleWrite(
        ::grpc::MessageAllocator< ::SingleWriteMemoryRequest, ::SingleWriteMemoryResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::SingleWriteMemoryRequest, ::SingleWriteMemoryResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SingleWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SingleWrite(::grpc::ServerContext* /*context*/, const ::SingleWriteMemoryRequest* /*request*/, ::SingleWriteMemoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SingleWrite(
      ::grpc::CallbackServerContext* /*context*/, const ::SingleWriteMemoryRequest* /*request*/, ::SingleWriteMemoryResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_MultiRead : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_MultiRead() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::MultiReadMemoryRequest, ::MultiReadMemoryResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::MultiReadMemoryRequest* request, ::MultiReadMemoryResponse* response) { return this->MultiRead(context, request, response); }));}
    void SetMessageAllocatorFor_MultiRead(
        ::grpc::MessageAllocator< ::MultiReadMemoryRequest, ::MultiReadMemoryResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::MultiReadMemoryRequest, ::MultiReadMemoryResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_MultiRead() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MultiRead(::grpc::ServerContext* /*context*/, const ::MultiReadMemoryRequest* /*request*/, ::MultiReadMemoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* MultiRead(
      ::grpc::CallbackServerContext* /*context*/, const ::MultiReadMemoryRequest* /*request*/, ::MultiReadMemoryResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_MultiWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_MultiWrite() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::MultiWriteMemoryRequest, ::MultiWriteMemoryResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::MultiWriteMemoryRequest* request, ::MultiWriteMemoryResponse* response) { return this->MultiWrite(context, request, response); }));}
    void SetMessageAllocatorFor_MultiWrite(
        ::grpc::MessageAllocator< ::MultiWriteMemoryRequest, ::MultiWriteMemoryResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::MultiWriteMemoryRequest, ::MultiWriteMemoryResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_MultiWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MultiWrite(::grpc::ServerContext* /*context*/, const ::MultiWriteMemoryRequest* /*request*/, ::MultiWriteMemoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* MultiWrite(
      ::grpc::CallbackServerContext* /*context*/, const ::MultiWriteMemoryRequest* /*request*/, ::MultiWriteMemoryResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_StreamRead : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_StreamRead() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackBidiHandler< ::MultiReadMemoryRequest, ::MultiReadMemoryResponse>(
            [this](
                   ::grpc::CallbackServerContext* context) { return this->StreamRead(context); }));
    }
    ~WithCallbackMethod_StreamRead() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamRead(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::MultiReadMemoryResponse, ::MultiReadMemoryRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerBidiReactor< ::MultiReadMemoryRequest, ::MultiReadMemoryResponse>* StreamRead(
      ::grpc::CallbackServerContext* /*context*/)
      { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_StreamWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_StreamWrite() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackBidiHandler< ::MultiWriteMemoryRequest, ::MultiWriteMemoryResponse>(
            [this](
                   ::grpc::CallbackServerContext* context) { return this->StreamWrite(context); }));
    }
    ~WithCallbackMethod_StreamWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamWrite(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::MultiWriteMemoryResponse, ::MultiWriteMemoryRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerBidiReactor< ::MultiWriteMemoryRequest, ::MultiWriteMemoryResponse>* StreamWrite(
      ::grpc::CallbackServerContext* /*context*/)
      { return nullptr; }
  };
  typedef WithCallbackMethod_MappingDetect<WithCallbackMethod_SingleRead<WithCallbackMethod_SingleWrite<WithCallbackMethod_MultiRead<WithCallbackMethod_MultiWrite<WithCallbackMethod_StreamRead<WithCallbackMethod_StreamWrite<Service > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_MappingDetect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MappingDetect() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_MappingDetect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MappingDetect(::grpc::ServerContext* /*context*/, const ::DetectMemoryMappingRequest* /*request*/, ::DetectMemoryMappingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SingleRead : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SingleRead() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_SingleRead() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SingleRead(::grpc::ServerContext* /*context*/, const ::SingleReadMemoryRequest* /*request*/, ::SingleReadMemoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SingleWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SingleWrite() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_SingleWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SingleWrite(::grpc::ServerContext* /*context*/, const ::SingleWriteMemoryRequest* /*request*/, ::SingleWriteMemoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MultiRead : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MultiRead() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_MultiRead() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MultiRead(::grpc::ServerContext* /*context*/, const ::MultiReadMemoryRequest* /*request*/, ::MultiReadMemoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MultiWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MultiWrite() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_MultiWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MultiWrite(::grpc::ServerContext* /*context*/, const ::MultiWriteMemoryRequest* /*request*/, ::MultiWriteMemoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StreamRead : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StreamRead() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_StreamRead() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamRead(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::MultiReadMemoryResponse, ::MultiReadMemoryRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StreamWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StreamWrite() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_StreamWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamWrite(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::MultiWriteMemoryResponse, ::MultiWriteMemoryRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_MappingDetect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MappingDetect() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_MappingDetect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MappingDetect(::grpc::ServerContext* /*context*/, const ::DetectMemoryMappingRequest* /*request*/, ::DetectMemoryMappingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMappingDetect(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SingleRead : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SingleRead() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_SingleRead() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SingleRead(::grpc::ServerContext* /*context*/, const ::SingleReadMemoryRequest* /*request*/, ::SingleReadMemoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSingleRead(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SingleWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SingleWrite() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_SingleWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SingleWrite(::grpc::ServerContext* /*context*/, const ::SingleWriteMemoryRequest* /*request*/, ::SingleWriteMemoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSingleWrite(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MultiRead : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MultiRead() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_MultiRead() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MultiRead(::grpc::ServerContext* /*context*/, const ::MultiReadMemoryRequest* /*request*/, ::MultiReadMemoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMultiRead(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MultiWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MultiWrite() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_MultiWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MultiWrite(::grpc::ServerContext* /*context*/, const ::MultiWriteMemoryRequest* /*request*/, ::MultiWriteMemoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMultiWrite(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StreamRead : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StreamRead() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_StreamRead() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamRead(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::MultiReadMemoryResponse, ::MultiReadMemoryRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStreamRead(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(5, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StreamWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StreamWrite() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_StreamWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamWrite(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::MultiWriteMemoryResponse, ::MultiWriteMemoryRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStreamWrite(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(6, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_MappingDetect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_MappingDetect() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MappingDetect(context, request, response); }));
    }
    ~WithRawCallbackMethod_MappingDetect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MappingDetect(::grpc::ServerContext* /*context*/, const ::DetectMemoryMappingRequest* /*request*/, ::DetectMemoryMappingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* MappingDetect(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SingleRead : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SingleRead() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SingleRead(context, request, response); }));
    }
    ~WithRawCallbackMethod_SingleRead() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SingleRead(::grpc::ServerContext* /*context*/, const ::SingleReadMemoryRequest* /*request*/, ::SingleReadMemoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SingleRead(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SingleWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SingleWrite() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SingleWrite(context, request, response); }));
    }
    ~WithRawCallbackMethod_SingleWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SingleWrite(::grpc::ServerContext* /*context*/, const ::SingleWriteMemoryRequest* /*request*/, ::SingleWriteMemoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SingleWrite(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_MultiRead : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_MultiRead() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MultiRead(context, request, response); }));
    }
    ~WithRawCallbackMethod_MultiRead() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MultiRead(::grpc::ServerContext* /*context*/, const ::MultiReadMemoryRequest* /*request*/, ::MultiReadMemoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* MultiRead(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_MultiWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_MultiWrite() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MultiWrite(context, request, response); }));
    }
    ~WithRawCallbackMethod_MultiWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MultiWrite(::grpc::ServerContext* /*context*/, const ::MultiWriteMemoryRequest* /*request*/, ::MultiWriteMemoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* MultiWrite(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_StreamRead : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_StreamRead() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackBidiHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context) { return this->StreamRead(context); }));
    }
    ~WithRawCallbackMethod_StreamRead() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamRead(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::MultiReadMemoryResponse, ::MultiReadMemoryRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerBidiReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* StreamRead(
      ::grpc::CallbackServerContext* /*context*/)
      { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_StreamWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_StreamWrite() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackBidiHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context) { return this->StreamWrite(context); }));
    }
    ~WithRawCallbackMethod_StreamWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamWrite(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::MultiWriteMemoryResponse, ::MultiWriteMemoryRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerBidiReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* StreamWrite(
      ::grpc::CallbackServerContext* /*context*/)
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MappingDetect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MappingDetect() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::DetectMemoryMappingRequest, ::DetectMemoryMappingResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::DetectMemoryMappingRequest, ::DetectMemoryMappingResponse>* streamer) {
                       return this->StreamedMappingDetect(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_MappingDetect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MappingDetect(::grpc::ServerContext* /*context*/, const ::DetectMemoryMappingRequest* /*request*/, ::DetectMemoryMappingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMappingDetect(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::DetectMemoryMappingRequest,::DetectMemoryMappingResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SingleRead : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SingleRead() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::SingleReadMemoryRequest, ::SingleReadMemoryResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::SingleReadMemoryRequest, ::SingleReadMemoryResponse>* streamer) {
                       return this->StreamedSingleRead(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SingleRead() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SingleRead(::grpc::ServerContext* /*context*/, const ::SingleReadMemoryRequest* /*request*/, ::SingleReadMemoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSingleRead(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::SingleReadMemoryRequest,::SingleReadMemoryResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SingleWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SingleWrite() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::SingleWriteMemoryRequest, ::SingleWriteMemoryResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::SingleWriteMemoryRequest, ::SingleWriteMemoryResponse>* streamer) {
                       return this->StreamedSingleWrite(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SingleWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SingleWrite(::grpc::ServerContext* /*context*/, const ::SingleWriteMemoryRequest* /*request*/, ::SingleWriteMemoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSingleWrite(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::SingleWriteMemoryRequest,::SingleWriteMemoryResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MultiRead : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MultiRead() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::MultiReadMemoryRequest, ::MultiReadMemoryResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::MultiReadMemoryRequest, ::MultiReadMemoryResponse>* streamer) {
                       return this->StreamedMultiRead(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_MultiRead() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MultiRead(::grpc::ServerContext* /*context*/, const ::MultiReadMemoryRequest* /*request*/, ::MultiReadMemoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMultiRead(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::MultiReadMemoryRequest,::MultiReadMemoryResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MultiWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MultiWrite() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::MultiWriteMemoryRequest, ::MultiWriteMemoryResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::MultiWriteMemoryRequest, ::MultiWriteMemoryResponse>* streamer) {
                       return this->StreamedMultiWrite(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_MultiWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MultiWrite(::grpc::ServerContext* /*context*/, const ::MultiWriteMemoryRequest* /*request*/, ::MultiWriteMemoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMultiWrite(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::MultiWriteMemoryRequest,::MultiWriteMemoryResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_MappingDetect<WithStreamedUnaryMethod_SingleRead<WithStreamedUnaryMethod_SingleWrite<WithStreamedUnaryMethod_MultiRead<WithStreamedUnaryMethod_MultiWrite<Service > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_MappingDetect<WithStreamedUnaryMethod_SingleRead<WithStreamedUnaryMethod_SingleWrite<WithStreamedUnaryMethod_MultiRead<WithStreamedUnaryMethod_MultiWrite<Service > > > > > StreamedService;
};

class DeviceFilesystem final {
 public:
  static constexpr char const* service_full_name() {
    return "DeviceFilesystem";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status ReadDirectory(::grpc::ClientContext* context, const ::ReadDirectoryRequest& request, ::ReadDirectoryResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ReadDirectoryResponse>> AsyncReadDirectory(::grpc::ClientContext* context, const ::ReadDirectoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ReadDirectoryResponse>>(AsyncReadDirectoryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ReadDirectoryResponse>> PrepareAsyncReadDirectory(::grpc::ClientContext* context, const ::ReadDirectoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ReadDirectoryResponse>>(PrepareAsyncReadDirectoryRaw(context, request, cq));
    }
    virtual ::grpc::Status MakeDirectory(::grpc::ClientContext* context, const ::MakeDirectoryRequest& request, ::MakeDirectoryResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MakeDirectoryResponse>> AsyncMakeDirectory(::grpc::ClientContext* context, const ::MakeDirectoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MakeDirectoryResponse>>(AsyncMakeDirectoryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MakeDirectoryResponse>> PrepareAsyncMakeDirectory(::grpc::ClientContext* context, const ::MakeDirectoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MakeDirectoryResponse>>(PrepareAsyncMakeDirectoryRaw(context, request, cq));
    }
    virtual ::grpc::Status RemoveFile(::grpc::ClientContext* context, const ::RemoveFileRequest& request, ::RemoveFileResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RemoveFileResponse>> AsyncRemoveFile(::grpc::ClientContext* context, const ::RemoveFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RemoveFileResponse>>(AsyncRemoveFileRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RemoveFileResponse>> PrepareAsyncRemoveFile(::grpc::ClientContext* context, const ::RemoveFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RemoveFileResponse>>(PrepareAsyncRemoveFileRaw(context, request, cq));
    }
    virtual ::grpc::Status RenameFile(::grpc::ClientContext* context, const ::RenameFileRequest& request, ::RenameFileResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RenameFileResponse>> AsyncRenameFile(::grpc::ClientContext* context, const ::RenameFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RenameFileResponse>>(AsyncRenameFileRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RenameFileResponse>> PrepareAsyncRenameFile(::grpc::ClientContext* context, const ::RenameFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RenameFileResponse>>(PrepareAsyncRenameFileRaw(context, request, cq));
    }
    virtual ::grpc::Status PutFile(::grpc::ClientContext* context, const ::PutFileRequest& request, ::PutFileResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::PutFileResponse>> AsyncPutFile(::grpc::ClientContext* context, const ::PutFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::PutFileResponse>>(AsyncPutFileRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::PutFileResponse>> PrepareAsyncPutFile(::grpc::ClientContext* context, const ::PutFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::PutFileResponse>>(PrepareAsyncPutFileRaw(context, request, cq));
    }
    virtual ::grpc::Status GetFile(::grpc::ClientContext* context, const ::GetFileRequest& request, ::GetFileResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GetFileResponse>> AsyncGetFile(::grpc::ClientContext* context, const ::GetFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GetFileResponse>>(AsyncGetFileRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GetFileResponse>> PrepareAsyncGetFile(::grpc::ClientContext* context, const ::GetFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GetFileResponse>>(PrepareAsyncGetFileRaw(context, request, cq));
    }
    virtual ::grpc::Status BootFile(::grpc::ClientContext* context, const ::BootFileRequest& request, ::BootFileResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::BootFileResponse>> AsyncBootFile(::grpc::ClientContext* context, const ::BootFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::BootFileResponse>>(AsyncBootFileRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::BootFileResponse>> PrepareAsyncBootFile(::grpc::ClientContext* context, const ::BootFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::BootFileResponse>>(PrepareAsyncBootFileRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void ReadDirectory(::grpc::ClientContext* context, const ::ReadDirectoryRequest* request, ::ReadDirectoryResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ReadDirectory(::grpc::ClientContext* context, const ::ReadDirectoryRequest* request, ::ReadDirectoryResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void MakeDirectory(::grpc::ClientContext* context, const ::MakeDirectoryRequest* request, ::MakeDirectoryResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void MakeDirectory(::grpc::ClientContext* context, const ::MakeDirectoryRequest* request, ::MakeDirectoryResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void RemoveFile(::grpc::ClientContext* context, const ::RemoveFileRequest* request, ::RemoveFileResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RemoveFile(::grpc::ClientContext* context, const ::RemoveFileRequest* request, ::RemoveFileResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void RenameFile(::grpc::ClientContext* context, const ::RenameFileRequest* request, ::RenameFileResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RenameFile(::grpc::ClientContext* context, const ::RenameFileRequest* request, ::RenameFileResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PutFile(::grpc::ClientContext* context, const ::PutFileRequest* request, ::PutFileResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PutFile(::grpc::ClientContext* context, const ::PutFileRequest* request, ::PutFileResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetFile(::grpc::ClientContext* context, const ::GetFileRequest* request, ::GetFileResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetFile(::grpc::ClientContext* context, const ::GetFileRequest* request, ::GetFileResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void BootFile(::grpc::ClientContext* context, const ::BootFileRequest* request, ::BootFileResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void BootFile(::grpc::ClientContext* context, const ::BootFileRequest* request, ::BootFileResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ReadDirectoryResponse>* AsyncReadDirectoryRaw(::grpc::ClientContext* context, const ::ReadDirectoryRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ReadDirectoryResponse>* PrepareAsyncReadDirectoryRaw(::grpc::ClientContext* context, const ::ReadDirectoryRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MakeDirectoryResponse>* AsyncMakeDirectoryRaw(::grpc::ClientContext* context, const ::MakeDirectoryRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MakeDirectoryResponse>* PrepareAsyncMakeDirectoryRaw(::grpc::ClientContext* context, const ::MakeDirectoryRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::RemoveFileResponse>* AsyncRemoveFileRaw(::grpc::ClientContext* context, const ::RemoveFileRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::RemoveFileResponse>* PrepareAsyncRemoveFileRaw(::grpc::ClientContext* context, const ::RemoveFileRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::RenameFileResponse>* AsyncRenameFileRaw(::grpc::ClientContext* context, const ::RenameFileRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::RenameFileResponse>* PrepareAsyncRenameFileRaw(::grpc::ClientContext* context, const ::RenameFileRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::PutFileResponse>* AsyncPutFileRaw(::grpc::ClientContext* context, const ::PutFileRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::PutFileResponse>* PrepareAsyncPutFileRaw(::grpc::ClientContext* context, const ::PutFileRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GetFileResponse>* AsyncGetFileRaw(::grpc::ClientContext* context, const ::GetFileRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GetFileResponse>* PrepareAsyncGetFileRaw(::grpc::ClientContext* context, const ::GetFileRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::BootFileResponse>* AsyncBootFileRaw(::grpc::ClientContext* context, const ::BootFileRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::BootFileResponse>* PrepareAsyncBootFileRaw(::grpc::ClientContext* context, const ::BootFileRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status ReadDirectory(::grpc::ClientContext* context, const ::ReadDirectoryRequest& request, ::ReadDirectoryResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ReadDirectoryResponse>> AsyncReadDirectory(::grpc::ClientContext* context, const ::ReadDirectoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ReadDirectoryResponse>>(AsyncReadDirectoryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ReadDirectoryResponse>> PrepareAsyncReadDirectory(::grpc::ClientContext* context, const ::ReadDirectoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ReadDirectoryResponse>>(PrepareAsyncReadDirectoryRaw(context, request, cq));
    }
    ::grpc::Status MakeDirectory(::grpc::ClientContext* context, const ::MakeDirectoryRequest& request, ::MakeDirectoryResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MakeDirectoryResponse>> AsyncMakeDirectory(::grpc::ClientContext* context, const ::MakeDirectoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MakeDirectoryResponse>>(AsyncMakeDirectoryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MakeDirectoryResponse>> PrepareAsyncMakeDirectory(::grpc::ClientContext* context, const ::MakeDirectoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MakeDirectoryResponse>>(PrepareAsyncMakeDirectoryRaw(context, request, cq));
    }
    ::grpc::Status RemoveFile(::grpc::ClientContext* context, const ::RemoveFileRequest& request, ::RemoveFileResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RemoveFileResponse>> AsyncRemoveFile(::grpc::ClientContext* context, const ::RemoveFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RemoveFileResponse>>(AsyncRemoveFileRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RemoveFileResponse>> PrepareAsyncRemoveFile(::grpc::ClientContext* context, const ::RemoveFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RemoveFileResponse>>(PrepareAsyncRemoveFileRaw(context, request, cq));
    }
    ::grpc::Status RenameFile(::grpc::ClientContext* context, const ::RenameFileRequest& request, ::RenameFileResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RenameFileResponse>> AsyncRenameFile(::grpc::ClientContext* context, const ::RenameFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RenameFileResponse>>(AsyncRenameFileRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RenameFileResponse>> PrepareAsyncRenameFile(::grpc::ClientContext* context, const ::RenameFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RenameFileResponse>>(PrepareAsyncRenameFileRaw(context, request, cq));
    }
    ::grpc::Status PutFile(::grpc::ClientContext* context, const ::PutFileRequest& request, ::PutFileResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::PutFileResponse>> AsyncPutFile(::grpc::ClientContext* context, const ::PutFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::PutFileResponse>>(AsyncPutFileRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::PutFileResponse>> PrepareAsyncPutFile(::grpc::ClientContext* context, const ::PutFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::PutFileResponse>>(PrepareAsyncPutFileRaw(context, request, cq));
    }
    ::grpc::Status GetFile(::grpc::ClientContext* context, const ::GetFileRequest& request, ::GetFileResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GetFileResponse>> AsyncGetFile(::grpc::ClientContext* context, const ::GetFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GetFileResponse>>(AsyncGetFileRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GetFileResponse>> PrepareAsyncGetFile(::grpc::ClientContext* context, const ::GetFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GetFileResponse>>(PrepareAsyncGetFileRaw(context, request, cq));
    }
    ::grpc::Status BootFile(::grpc::ClientContext* context, const ::BootFileRequest& request, ::BootFileResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::BootFileResponse>> AsyncBootFile(::grpc::ClientContext* context, const ::BootFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::BootFileResponse>>(AsyncBootFileRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::BootFileResponse>> PrepareAsyncBootFile(::grpc::ClientContext* context, const ::BootFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::BootFileResponse>>(PrepareAsyncBootFileRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void ReadDirectory(::grpc::ClientContext* context, const ::ReadDirectoryRequest* request, ::ReadDirectoryResponse* response, std::function<void(::grpc::Status)>) override;
      void ReadDirectory(::grpc::ClientContext* context, const ::ReadDirectoryRequest* request, ::ReadDirectoryResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void MakeDirectory(::grpc::ClientContext* context, const ::MakeDirectoryRequest* request, ::MakeDirectoryResponse* response, std::function<void(::grpc::Status)>) override;
      void MakeDirectory(::grpc::ClientContext* context, const ::MakeDirectoryRequest* request, ::MakeDirectoryResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void RemoveFile(::grpc::ClientContext* context, const ::RemoveFileRequest* request, ::RemoveFileResponse* response, std::function<void(::grpc::Status)>) override;
      void RemoveFile(::grpc::ClientContext* context, const ::RemoveFileRequest* request, ::RemoveFileResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void RenameFile(::grpc::ClientContext* context, const ::RenameFileRequest* request, ::RenameFileResponse* response, std::function<void(::grpc::Status)>) override;
      void RenameFile(::grpc::ClientContext* context, const ::RenameFileRequest* request, ::RenameFileResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PutFile(::grpc::ClientContext* context, const ::PutFileRequest* request, ::PutFileResponse* response, std::function<void(::grpc::Status)>) override;
      void PutFile(::grpc::ClientContext* context, const ::PutFileRequest* request, ::PutFileResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetFile(::grpc::ClientContext* context, const ::GetFileRequest* request, ::GetFileResponse* response, std::function<void(::grpc::Status)>) override;
      void GetFile(::grpc::ClientContext* context, const ::GetFileRequest* request, ::GetFileResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void BootFile(::grpc::ClientContext* context, const ::BootFileRequest* request, ::BootFileResponse* response, std::function<void(::grpc::Status)>) override;
      void BootFile(::grpc::ClientContext* context, const ::BootFileRequest* request, ::BootFileResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::ReadDirectoryResponse>* AsyncReadDirectoryRaw(::grpc::ClientContext* context, const ::ReadDirectoryRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ReadDirectoryResponse>* PrepareAsyncReadDirectoryRaw(::grpc::ClientContext* context, const ::ReadDirectoryRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MakeDirectoryResponse>* AsyncMakeDirectoryRaw(::grpc::ClientContext* context, const ::MakeDirectoryRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MakeDirectoryResponse>* PrepareAsyncMakeDirectoryRaw(::grpc::ClientContext* context, const ::MakeDirectoryRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::RemoveFileResponse>* AsyncRemoveFileRaw(::grpc::ClientContext* context, const ::RemoveFileRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::RemoveFileResponse>* PrepareAsyncRemoveFileRaw(::grpc::ClientContext* context, const ::RemoveFileRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::RenameFileResponse>* AsyncRenameFileRaw(::grpc::ClientContext* context, const ::RenameFileRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::RenameFileResponse>* PrepareAsyncRenameFileRaw(::grpc::ClientContext* context, const ::RenameFileRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::PutFileResponse>* AsyncPutFileRaw(::grpc::ClientContext* context, const ::PutFileRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::PutFileResponse>* PrepareAsyncPutFileRaw(::grpc::ClientContext* context, const ::PutFileRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GetFileResponse>* AsyncGetFileRaw(::grpc::ClientContext* context, const ::GetFileRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GetFileResponse>* PrepareAsyncGetFileRaw(::grpc::ClientContext* context, const ::GetFileRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::BootFileResponse>* AsyncBootFileRaw(::grpc::ClientContext* context, const ::BootFileRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::BootFileResponse>* PrepareAsyncBootFileRaw(::grpc::ClientContext* context, const ::BootFileRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_ReadDirectory_;
    const ::grpc::internal::RpcMethod rpcmethod_MakeDirectory_;
    const ::grpc::internal::RpcMethod rpcmethod_RemoveFile_;
    const ::grpc::internal::RpcMethod rpcmethod_RenameFile_;
    const ::grpc::internal::RpcMethod rpcmethod_PutFile_;
    const ::grpc::internal::RpcMethod rpcmethod_GetFile_;
    const ::grpc::internal::RpcMethod rpcmethod_BootFile_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status ReadDirectory(::grpc::ServerContext* context, const ::ReadDirectoryRequest* request, ::ReadDirectoryResponse* response);
    virtual ::grpc::Status MakeDirectory(::grpc::ServerContext* context, const ::MakeDirectoryRequest* request, ::MakeDirectoryResponse* response);
    virtual ::grpc::Status RemoveFile(::grpc::ServerContext* context, const ::RemoveFileRequest* request, ::RemoveFileResponse* response);
    virtual ::grpc::Status RenameFile(::grpc::ServerContext* context, const ::RenameFileRequest* request, ::RenameFileResponse* response);
    virtual ::grpc::Status PutFile(::grpc::ServerContext* context, const ::PutFileRequest* request, ::PutFileResponse* response);
    virtual ::grpc::Status GetFile(::grpc::ServerContext* context, const ::GetFileRequest* request, ::GetFileResponse* response);
    virtual ::grpc::Status BootFile(::grpc::ServerContext* context, const ::BootFileRequest* request, ::BootFileResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_ReadDirectory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ReadDirectory() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_ReadDirectory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadDirectory(::grpc::ServerContext* /*context*/, const ::ReadDirectoryRequest* /*request*/, ::ReadDirectoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReadDirectory(::grpc::ServerContext* context, ::ReadDirectoryRequest* request, ::grpc::ServerAsyncResponseWriter< ::ReadDirectoryResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MakeDirectory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MakeDirectory() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_MakeDirectory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MakeDirectory(::grpc::ServerContext* /*context*/, const ::MakeDirectoryRequest* /*request*/, ::MakeDirectoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMakeDirectory(::grpc::ServerContext* context, ::MakeDirectoryRequest* request, ::grpc::ServerAsyncResponseWriter< ::MakeDirectoryResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RemoveFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RemoveFile() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_RemoveFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveFile(::grpc::ServerContext* /*context*/, const ::RemoveFileRequest* /*request*/, ::RemoveFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRemoveFile(::grpc::ServerContext* context, ::RemoveFileRequest* request, ::grpc::ServerAsyncResponseWriter< ::RemoveFileResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RenameFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RenameFile() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_RenameFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RenameFile(::grpc::ServerContext* /*context*/, const ::RenameFileRequest* /*request*/, ::RenameFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRenameFile(::grpc::ServerContext* context, ::RenameFileRequest* request, ::grpc::ServerAsyncResponseWriter< ::RenameFileResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PutFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PutFile() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_PutFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PutFile(::grpc::ServerContext* /*context*/, const ::PutFileRequest* /*request*/, ::PutFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPutFile(::grpc::ServerContext* context, ::PutFileRequest* request, ::grpc::ServerAsyncResponseWriter< ::PutFileResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetFile() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_GetFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFile(::grpc::ServerContext* /*context*/, const ::GetFileRequest* /*request*/, ::GetFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetFile(::grpc::ServerContext* context, ::GetFileRequest* request, ::grpc::ServerAsyncResponseWriter< ::GetFileResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_BootFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_BootFile() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_BootFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BootFile(::grpc::ServerContext* /*context*/, const ::BootFileRequest* /*request*/, ::BootFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBootFile(::grpc::ServerContext* context, ::BootFileRequest* request, ::grpc::ServerAsyncResponseWriter< ::BootFileResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_ReadDirectory<WithAsyncMethod_MakeDirectory<WithAsyncMethod_RemoveFile<WithAsyncMethod_RenameFile<WithAsyncMethod_PutFile<WithAsyncMethod_GetFile<WithAsyncMethod_BootFile<Service > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_ReadDirectory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ReadDirectory() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::ReadDirectoryRequest, ::ReadDirectoryResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::ReadDirectoryRequest* request, ::ReadDirectoryResponse* response) { return this->ReadDirectory(context, request, response); }));}
    void SetMessageAllocatorFor_ReadDirectory(
        ::grpc::MessageAllocator< ::ReadDirectoryRequest, ::ReadDirectoryResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::ReadDirectoryRequest, ::ReadDirectoryResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ReadDirectory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadDirectory(::grpc::ServerContext* /*context*/, const ::ReadDirectoryRequest* /*request*/, ::ReadDirectoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ReadDirectory(
      ::grpc::CallbackServerContext* /*context*/, const ::ReadDirectoryRequest* /*request*/, ::ReadDirectoryResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_MakeDirectory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_MakeDirectory() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::MakeDirectoryRequest, ::MakeDirectoryResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::MakeDirectoryRequest* request, ::MakeDirectoryResponse* response) { return this->MakeDirectory(context, request, response); }));}
    void SetMessageAllocatorFor_MakeDirectory(
        ::grpc::MessageAllocator< ::MakeDirectoryRequest, ::MakeDirectoryResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::MakeDirectoryRequest, ::MakeDirectoryResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_MakeDirectory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MakeDirectory(::grpc::ServerContext* /*context*/, const ::MakeDirectoryRequest* /*request*/, ::MakeDirectoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* MakeDirectory(
      ::grpc::CallbackServerContext* /*context*/, const ::MakeDirectoryRequest* /*request*/, ::MakeDirectoryResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_RemoveFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_RemoveFile() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::RemoveFileRequest, ::RemoveFileResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::RemoveFileRequest* request, ::RemoveFileResponse* response) { return this->RemoveFile(context, request, response); }));}
    void SetMessageAllocatorFor_RemoveFile(
        ::grpc::MessageAllocator< ::RemoveFileRequest, ::RemoveFileResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::RemoveFileRequest, ::RemoveFileResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_RemoveFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveFile(::grpc::ServerContext* /*context*/, const ::RemoveFileRequest* /*request*/, ::RemoveFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RemoveFile(
      ::grpc::CallbackServerContext* /*context*/, const ::RemoveFileRequest* /*request*/, ::RemoveFileResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_RenameFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_RenameFile() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::RenameFileRequest, ::RenameFileResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::RenameFileRequest* request, ::RenameFileResponse* response) { return this->RenameFile(context, request, response); }));}
    void SetMessageAllocatorFor_RenameFile(
        ::grpc::MessageAllocator< ::RenameFileRequest, ::RenameFileResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::RenameFileRequest, ::RenameFileResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_RenameFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RenameFile(::grpc::ServerContext* /*context*/, const ::RenameFileRequest* /*request*/, ::RenameFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RenameFile(
      ::grpc::CallbackServerContext* /*context*/, const ::RenameFileRequest* /*request*/, ::RenameFileResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PutFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PutFile() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::PutFileRequest, ::PutFileResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::PutFileRequest* request, ::PutFileResponse* response) { return this->PutFile(context, request, response); }));}
    void SetMessageAllocatorFor_PutFile(
        ::grpc::MessageAllocator< ::PutFileRequest, ::PutFileResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::PutFileRequest, ::PutFileResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PutFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PutFile(::grpc::ServerContext* /*context*/, const ::PutFileRequest* /*request*/, ::PutFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PutFile(
      ::grpc::CallbackServerContext* /*context*/, const ::PutFileRequest* /*request*/, ::PutFileResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetFile() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::GetFileRequest, ::GetFileResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::GetFileRequest* request, ::GetFileResponse* response) { return this->GetFile(context, request, response); }));}
    void SetMessageAllocatorFor_GetFile(
        ::grpc::MessageAllocator< ::GetFileRequest, ::GetFileResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::GetFileRequest, ::GetFileResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFile(::grpc::ServerContext* /*context*/, const ::GetFileRequest* /*request*/, ::GetFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetFile(
      ::grpc::CallbackServerContext* /*context*/, const ::GetFileRequest* /*request*/, ::GetFileResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_BootFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_BootFile() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::BootFileRequest, ::BootFileResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::BootFileRequest* request, ::BootFileResponse* response) { return this->BootFile(context, request, response); }));}
    void SetMessageAllocatorFor_BootFile(
        ::grpc::MessageAllocator< ::BootFileRequest, ::BootFileResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::BootFileRequest, ::BootFileResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_BootFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BootFile(::grpc::ServerContext* /*context*/, const ::BootFileRequest* /*request*/, ::BootFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* BootFile(
      ::grpc::CallbackServerContext* /*context*/, const ::BootFileRequest* /*request*/, ::BootFileResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_ReadDirectory<WithCallbackMethod_MakeDirectory<WithCallbackMethod_RemoveFile<WithCallbackMethod_RenameFile<WithCallbackMethod_PutFile<WithCallbackMethod_GetFile<WithCallbackMethod_BootFile<Service > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_ReadDirectory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ReadDirectory() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_ReadDirectory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadDirectory(::grpc::ServerContext* /*context*/, const ::ReadDirectoryRequest* /*request*/, ::ReadDirectoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MakeDirectory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MakeDirectory() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_MakeDirectory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MakeDirectory(::grpc::ServerContext* /*context*/, const ::MakeDirectoryRequest* /*request*/, ::MakeDirectoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RemoveFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RemoveFile() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_RemoveFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveFile(::grpc::ServerContext* /*context*/, const ::RemoveFileRequest* /*request*/, ::RemoveFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RenameFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RenameFile() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_RenameFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RenameFile(::grpc::ServerContext* /*context*/, const ::RenameFileRequest* /*request*/, ::RenameFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PutFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PutFile() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_PutFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PutFile(::grpc::ServerContext* /*context*/, const ::PutFileRequest* /*request*/, ::PutFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetFile() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_GetFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFile(::grpc::ServerContext* /*context*/, const ::GetFileRequest* /*request*/, ::GetFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_BootFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_BootFile() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_BootFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BootFile(::grpc::ServerContext* /*context*/, const ::BootFileRequest* /*request*/, ::BootFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_ReadDirectory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ReadDirectory() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_ReadDirectory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadDirectory(::grpc::ServerContext* /*context*/, const ::ReadDirectoryRequest* /*request*/, ::ReadDirectoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReadDirectory(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MakeDirectory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MakeDirectory() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_MakeDirectory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MakeDirectory(::grpc::ServerContext* /*context*/, const ::MakeDirectoryRequest* /*request*/, ::MakeDirectoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMakeDirectory(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RemoveFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RemoveFile() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_RemoveFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveFile(::grpc::ServerContext* /*context*/, const ::RemoveFileRequest* /*request*/, ::RemoveFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRemoveFile(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RenameFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RenameFile() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_RenameFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RenameFile(::grpc::ServerContext* /*context*/, const ::RenameFileRequest* /*request*/, ::RenameFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRenameFile(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PutFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PutFile() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_PutFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PutFile(::grpc::ServerContext* /*context*/, const ::PutFileRequest* /*request*/, ::PutFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPutFile(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetFile() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_GetFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFile(::grpc::ServerContext* /*context*/, const ::GetFileRequest* /*request*/, ::GetFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetFile(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_BootFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_BootFile() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_BootFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BootFile(::grpc::ServerContext* /*context*/, const ::BootFileRequest* /*request*/, ::BootFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBootFile(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ReadDirectory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ReadDirectory() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ReadDirectory(context, request, response); }));
    }
    ~WithRawCallbackMethod_ReadDirectory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadDirectory(::grpc::ServerContext* /*context*/, const ::ReadDirectoryRequest* /*request*/, ::ReadDirectoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ReadDirectory(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_MakeDirectory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_MakeDirectory() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MakeDirectory(context, request, response); }));
    }
    ~WithRawCallbackMethod_MakeDirectory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MakeDirectory(::grpc::ServerContext* /*context*/, const ::MakeDirectoryRequest* /*request*/, ::MakeDirectoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* MakeDirectory(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_RemoveFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_RemoveFile() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RemoveFile(context, request, response); }));
    }
    ~WithRawCallbackMethod_RemoveFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveFile(::grpc::ServerContext* /*context*/, const ::RemoveFileRequest* /*request*/, ::RemoveFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RemoveFile(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_RenameFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_RenameFile() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RenameFile(context, request, response); }));
    }
    ~WithRawCallbackMethod_RenameFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RenameFile(::grpc::ServerContext* /*context*/, const ::RenameFileRequest* /*request*/, ::RenameFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RenameFile(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PutFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PutFile() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PutFile(context, request, response); }));
    }
    ~WithRawCallbackMethod_PutFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PutFile(::grpc::ServerContext* /*context*/, const ::PutFileRequest* /*request*/, ::PutFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PutFile(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetFile() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetFile(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFile(::grpc::ServerContext* /*context*/, const ::GetFileRequest* /*request*/, ::GetFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetFile(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_BootFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_BootFile() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->BootFile(context, request, response); }));
    }
    ~WithRawCallbackMethod_BootFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BootFile(::grpc::ServerContext* /*context*/, const ::BootFileRequest* /*request*/, ::BootFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* BootFile(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ReadDirectory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ReadDirectory() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::ReadDirectoryRequest, ::ReadDirectoryResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::ReadDirectoryRequest, ::ReadDirectoryResponse>* streamer) {
                       return this->StreamedReadDirectory(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ReadDirectory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ReadDirectory(::grpc::ServerContext* /*context*/, const ::ReadDirectoryRequest* /*request*/, ::ReadDirectoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedReadDirectory(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ReadDirectoryRequest,::ReadDirectoryResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MakeDirectory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MakeDirectory() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::MakeDirectoryRequest, ::MakeDirectoryResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::MakeDirectoryRequest, ::MakeDirectoryResponse>* streamer) {
                       return this->StreamedMakeDirectory(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_MakeDirectory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MakeDirectory(::grpc::ServerContext* /*context*/, const ::MakeDirectoryRequest* /*request*/, ::MakeDirectoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMakeDirectory(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::MakeDirectoryRequest,::MakeDirectoryResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RemoveFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RemoveFile() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::RemoveFileRequest, ::RemoveFileResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::RemoveFileRequest, ::RemoveFileResponse>* streamer) {
                       return this->StreamedRemoveFile(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RemoveFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RemoveFile(::grpc::ServerContext* /*context*/, const ::RemoveFileRequest* /*request*/, ::RemoveFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRemoveFile(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::RemoveFileRequest,::RemoveFileResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RenameFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RenameFile() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::RenameFileRequest, ::RenameFileResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::RenameFileRequest, ::RenameFileResponse>* streamer) {
                       return this->StreamedRenameFile(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RenameFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RenameFile(::grpc::ServerContext* /*context*/, const ::RenameFileRequest* /*request*/, ::RenameFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRenameFile(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::RenameFileRequest,::RenameFileResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PutFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PutFile() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::PutFileRequest, ::PutFileResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::PutFileRequest, ::PutFileResponse>* streamer) {
                       return this->StreamedPutFile(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PutFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PutFile(::grpc::ServerContext* /*context*/, const ::PutFileRequest* /*request*/, ::PutFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPutFile(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::PutFileRequest,::PutFileResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetFile() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::GetFileRequest, ::GetFileResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::GetFileRequest, ::GetFileResponse>* streamer) {
                       return this->StreamedGetFile(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetFile(::grpc::ServerContext* /*context*/, const ::GetFileRequest* /*request*/, ::GetFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetFile(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::GetFileRequest,::GetFileResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_BootFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_BootFile() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::BootFileRequest, ::BootFileResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::BootFileRequest, ::BootFileResponse>* streamer) {
                       return this->StreamedBootFile(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_BootFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status BootFile(::grpc::ServerContext* /*context*/, const ::BootFileRequest* /*request*/, ::BootFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedBootFile(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::BootFileRequest,::BootFileResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_ReadDirectory<WithStreamedUnaryMethod_MakeDirectory<WithStreamedUnaryMethod_RemoveFile<WithStreamedUnaryMethod_RenameFile<WithStreamedUnaryMethod_PutFile<WithStreamedUnaryMethod_GetFile<WithStreamedUnaryMethod_BootFile<Service > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_ReadDirectory<WithStreamedUnaryMethod_MakeDirectory<WithStreamedUnaryMethod_RemoveFile<WithStreamedUnaryMethod_RenameFile<WithStreamedUnaryMethod_PutFile<WithStreamedUnaryMethod_GetFile<WithStreamedUnaryMethod_BootFile<Service > > > > > > > StreamedService;
};

class DeviceInfo final {
 public:
  static constexpr char const* service_full_name() {
    return "DeviceInfo";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status FetchFields(::grpc::ClientContext* context, const ::FieldsRequest& request, ::FieldsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::FieldsResponse>> AsyncFetchFields(::grpc::ClientContext* context, const ::FieldsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::FieldsResponse>>(AsyncFetchFieldsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::FieldsResponse>> PrepareAsyncFetchFields(::grpc::ClientContext* context, const ::FieldsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::FieldsResponse>>(PrepareAsyncFetchFieldsRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void FetchFields(::grpc::ClientContext* context, const ::FieldsRequest* request, ::FieldsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void FetchFields(::grpc::ClientContext* context, const ::FieldsRequest* request, ::FieldsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::FieldsResponse>* AsyncFetchFieldsRaw(::grpc::ClientContext* context, const ::FieldsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::FieldsResponse>* PrepareAsyncFetchFieldsRaw(::grpc::ClientContext* context, const ::FieldsRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status FetchFields(::grpc::ClientContext* context, const ::FieldsRequest& request, ::FieldsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::FieldsResponse>> AsyncFetchFields(::grpc::ClientContext* context, const ::FieldsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::FieldsResponse>>(AsyncFetchFieldsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::FieldsResponse>> PrepareAsyncFetchFields(::grpc::ClientContext* context, const ::FieldsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::FieldsResponse>>(PrepareAsyncFetchFieldsRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void FetchFields(::grpc::ClientContext* context, const ::FieldsRequest* request, ::FieldsResponse* response, std::function<void(::grpc::Status)>) override;
      void FetchFields(::grpc::ClientContext* context, const ::FieldsRequest* request, ::FieldsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::FieldsResponse>* AsyncFetchFieldsRaw(::grpc::ClientContext* context, const ::FieldsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::FieldsResponse>* PrepareAsyncFetchFieldsRaw(::grpc::ClientContext* context, const ::FieldsRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_FetchFields_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status FetchFields(::grpc::ServerContext* context, const ::FieldsRequest* request, ::FieldsResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_FetchFields : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_FetchFields() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_FetchFields() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FetchFields(::grpc::ServerContext* /*context*/, const ::FieldsRequest* /*request*/, ::FieldsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFetchFields(::grpc::ServerContext* context, ::FieldsRequest* request, ::grpc::ServerAsyncResponseWriter< ::FieldsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_FetchFields<Service > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_FetchFields : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_FetchFields() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::FieldsRequest, ::FieldsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::FieldsRequest* request, ::FieldsResponse* response) { return this->FetchFields(context, request, response); }));}
    void SetMessageAllocatorFor_FetchFields(
        ::grpc::MessageAllocator< ::FieldsRequest, ::FieldsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::FieldsRequest, ::FieldsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_FetchFields() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FetchFields(::grpc::ServerContext* /*context*/, const ::FieldsRequest* /*request*/, ::FieldsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* FetchFields(
      ::grpc::CallbackServerContext* /*context*/, const ::FieldsRequest* /*request*/, ::FieldsResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_FetchFields<Service > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_FetchFields : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_FetchFields() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_FetchFields() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FetchFields(::grpc::ServerContext* /*context*/, const ::FieldsRequest* /*request*/, ::FieldsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_FetchFields : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_FetchFields() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_FetchFields() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FetchFields(::grpc::ServerContext* /*context*/, const ::FieldsRequest* /*request*/, ::FieldsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFetchFields(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_FetchFields : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_FetchFields() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->FetchFields(context, request, response); }));
    }
    ~WithRawCallbackMethod_FetchFields() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FetchFields(::grpc::ServerContext* /*context*/, const ::FieldsRequest* /*request*/, ::FieldsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* FetchFields(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_FetchFields : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_FetchFields() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::FieldsRequest, ::FieldsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::FieldsRequest, ::FieldsResponse>* streamer) {
                       return this->StreamedFetchFields(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_FetchFields() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FetchFields(::grpc::ServerContext* /*context*/, const ::FieldsRequest* /*request*/, ::FieldsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFetchFields(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::FieldsRequest,::FieldsResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_FetchFields<Service > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_FetchFields<Service > StreamedService;
};

class DeviceNWA final {
 public:
  static constexpr char const* service_full_name() {
    return "DeviceNWA";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status NWACommand(::grpc::ClientContext* context, const ::NWACommandRequest& request, ::NWACommandResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::NWACommandResponse>> AsyncNWACommand(::grpc::ClientContext* context, const ::NWACommandRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::NWACommandResponse>>(AsyncNWACommandRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::NWACommandResponse>> PrepareAsyncNWACommand(::grpc::ClientContext* context, const ::NWACommandRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::NWACommandResponse>>(PrepareAsyncNWACommandRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void NWACommand(::grpc::ClientContext* context, const ::NWACommandRequest* request, ::NWACommandResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void NWACommand(::grpc::ClientContext* context, const ::NWACommandRequest* request, ::NWACommandResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::NWACommandResponse>* AsyncNWACommandRaw(::grpc::ClientContext* context, const ::NWACommandRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::NWACommandResponse>* PrepareAsyncNWACommandRaw(::grpc::ClientContext* context, const ::NWACommandRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status NWACommand(::grpc::ClientContext* context, const ::NWACommandRequest& request, ::NWACommandResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::NWACommandResponse>> AsyncNWACommand(::grpc::ClientContext* context, const ::NWACommandRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::NWACommandResponse>>(AsyncNWACommandRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::NWACommandResponse>> PrepareAsyncNWACommand(::grpc::ClientContext* context, const ::NWACommandRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::NWACommandResponse>>(PrepareAsyncNWACommandRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void NWACommand(::grpc::ClientContext* context, const ::NWACommandRequest* request, ::NWACommandResponse* response, std::function<void(::grpc::Status)>) override;
      void NWACommand(::grpc::ClientContext* context, const ::NWACommandRequest* request, ::NWACommandResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::NWACommandResponse>* AsyncNWACommandRaw(::grpc::ClientContext* context, const ::NWACommandRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::NWACommandResponse>* PrepareAsyncNWACommandRaw(::grpc::ClientContext* context, const ::NWACommandRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_NWACommand_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status NWACommand(::grpc::ServerContext* context, const ::NWACommandRequest* request, ::NWACommandResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_NWACommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_NWACommand() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_NWACommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NWACommand(::grpc::ServerContext* /*context*/, const ::NWACommandRequest* /*request*/, ::NWACommandResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestNWACommand(::grpc::ServerContext* context, ::NWACommandRequest* request, ::grpc::ServerAsyncResponseWriter< ::NWACommandResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_NWACommand<Service > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_NWACommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_NWACommand() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::NWACommandRequest, ::NWACommandResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::NWACommandRequest* request, ::NWACommandResponse* response) { return this->NWACommand(context, request, response); }));}
    void SetMessageAllocatorFor_NWACommand(
        ::grpc::MessageAllocator< ::NWACommandRequest, ::NWACommandResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::NWACommandRequest, ::NWACommandResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_NWACommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NWACommand(::grpc::ServerContext* /*context*/, const ::NWACommandRequest* /*request*/, ::NWACommandResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* NWACommand(
      ::grpc::CallbackServerContext* /*context*/, const ::NWACommandRequest* /*request*/, ::NWACommandResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_NWACommand<Service > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_NWACommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_NWACommand() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_NWACommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NWACommand(::grpc::ServerContext* /*context*/, const ::NWACommandRequest* /*request*/, ::NWACommandResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_NWACommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_NWACommand() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_NWACommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NWACommand(::grpc::ServerContext* /*context*/, const ::NWACommandRequest* /*request*/, ::NWACommandResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestNWACommand(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_NWACommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_NWACommand() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->NWACommand(context, request, response); }));
    }
    ~WithRawCallbackMethod_NWACommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NWACommand(::grpc::ServerContext* /*context*/, const ::NWACommandRequest* /*request*/, ::NWACommandResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* NWACommand(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_NWACommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_NWACommand() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::NWACommandRequest, ::NWACommandResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::NWACommandRequest, ::NWACommandResponse>* streamer) {
                       return this->StreamedNWACommand(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_NWACommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status NWACommand(::grpc::ServerContext* /*context*/, const ::NWACommandRequest* /*request*/, ::NWACommandResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedNWACommand(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::NWACommandRequest,::NWACommandResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_NWACommand<Service > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_NWACommand<Service > StreamedService;
};


#endif  // GRPC_sni_2eproto__INCLUDED
